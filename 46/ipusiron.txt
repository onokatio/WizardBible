x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座・第21回 〜Rabin暗号の拡張〜 ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　WB42では公開鍵暗号の一種であるRabin暗号は、大きい桁の合成数の素因数分解
が効率的にできないという仮定の下で、OW-CPA安全であることを（直観的に）証
明した。しかしながらRabin暗号は一意に復号できないという特徴を持っていた。
まずはこの課題を解決することを目指したい。次に、OW-CPA安全よりも高い安全
性を持つ、平方剰余を用いた公開鍵暗号について紹介したい。

　今回は調べながら書いた部分も多々あるので、説明になっていない箇所や間違
いがありましたら掲示板の方にお知らせください（掲示板が干上がっていまって
いるので…）。


■0x02.) 数学的概念の復習

　まず数学的概念の復習を行う。

[定義]
a≡b^2 (mod N)の形にあるとき、aはNを法とするbの平方剰余、bはNを法とするa
の平方根である。そして、aを全部集めた集合をQR_Nと記述する。

[定理]
・「a,b：平方剰余」⇒「ab：平方剰余」
・「a：平方剰余」かつ「b：平方非剰余」⇒「ab：平方非剰余」

[定理]「a：法N(=pq)の平方剰余」⇔「a：法pの平方剰余」かつ「a：法qの平方剰
余」

言い換えれば、「(a/n)=1」⇔「(a/p)=(a/q)=1」

[定理]h=(p-1)/2とする。
・「a：法pの平方剰余」⇒「a^h≡1 (mod p)」
・「a：法pの平方非剰余」⇒「a^h≡-1 (mod p)」

[定理]
・|Z_p^*|=p-1
そのうち半分、即ち(p-1)/2個は法pの平方剰余である。
・|Z_N^*|=φ(N)=(p-1)(q-1)
そのうち1/4個は法Nの平方剰余である。

[定理]
・(1/N)=1
・(2/N)=(-1)^{(n^2-1)/8}
・GCD(m,n)=1ならば、(m/n)=(n/m)・(-1)^{(m-1)(n-1)/4}
・GCD(a,n)=GCD(g,n)=1ならば、(ab/n)=(a/n)(b/n)
・(a/n)=((a mod n)/n)
・a≡b (mod N)⇒(a/N)=(b/N)

[定理]
「x^{(p-1)/2}≡1 (mod p)」⇔「(x/p)=1」


■0x03.) Rabin暗号の復習

　Rabin暗号についてはすでに紹介済みだが、改めて紹介する。

●改良Rabin暗号の仕様

　Rabin暗号は次の3つのアルゴリズムの組であった。

Rabin=(KeyGen,Enc,Dec)

○KeyGen

1：1^kを入力とする。

2：kビットの素数p,qを生成する。

3：pk=N=pq,sk=(p,q)とし、pk,skを出力する。

○Enc

1：平文m、公開鍵pkを入力とする。

2：c=m^2 mod Nを計算して、cを出力する。

○Dec

1：暗号文c、秘密鍵skを入力とする。

2：平方根を解くアルゴリズムにc,pを入力し、法pにおけるcの平方根を求める。
それを±m_pとする。
　同様に、c,qを入力として、法qにおけるcの平方根を求める。それを±m_qとす
る。

3：CRTのアルゴリズムに±m_p,±m_q,(p,q)を入力して、法Nにおけるcの平方根（
4つの値）を出力する。Decは4つの値（m1,m2,m3,m4）を出力する。


●改良Rabin暗号の仕様の解説

　以上がRabin暗号の各アルゴリズムの動きを単純化したものである。完全性につ
いてはすでに確認済み（Encで法Nの世界で2乗して、Decで平方根の計算をして、
4つの候補のうち1つが平文と一致）なので、内部のアルゴリズムについて簡単に
復習しておく。

　平方根を解くアルゴリズムの存在について考察する、素数pを法とする平方根を
解くアルゴリズムならばいくつか提案されている（Rabinのアルゴリズム[R89]、
Berlekampのアルゴリズム[BER67]、Bernsteinのアルゴリズム[B01]、Chirstophら
のアルゴリズム[CP03]など）。ここでは、Shanksのアルゴリズムを紹介する[S73]。

　まず、素数pが3型か1型かによって、平方根を解くアルゴリズムを使い分けると
よい。

[1]pが3型の素数であるとき

　cの平方根（m_pとする）を解く場合は、単にc^{(p+1)/4} (mod p)を計算すれば
よい。なぜならば、(p+1)/4∈Zのとき、

(m_p)^2
≡c^{(p+1)/2}
≡c^{(p-1)/2}・c
≡c (mod p)　（∵(c/p)=1ならば、c^{(p-1)/2}≡1 (mod p)）

よって、m_pはcの平方根である。

（図）http://security2600.sakura.ne.jp/main2/image4/find_square_roots.jpg

[2]pが1型の素数であるとき

　一般の奇素数pを法とする平方根を求めることができるShanks-Tonelliのアルゴ
リズムを用いればよい。アルゴリズムの詳細は次の章で紹介する。

　一方、素因数分解を効率的に計算できない（効率的に計算するアルゴリズムが
存在しない）ならば、合成数Nを法とする平方根を効率的に解くアルゴリズムは存
在しない。

（図）http://security2600.sakura.ne.jp/main2/image4/heihoukonn.jpg

　次にCRTアルゴリズムの存在について考察する。このアルゴリズムの詳細は今後
のWBで紹介する予定だが、このようなアルゴリズムは存在し、それも効率的に計
算可能である。ここでは内部アルゴリズムは無視して、法pでのcの平方根と法qで
のcの平方根を入力とすると、法N(=pq)でのcの平方根が出力されるとだけ知って
もらえればよい（2つのp,qを与えてNにリフトする話はWB42で言及済み）。
　平方根を解くアルゴリズムを2回使って法p,qでのcの平方根（pの世界には2つの
値、qの世界には2つの値。合計4つの値）が求まり、その後CRTアルゴリズムによ
り法Nでのcの平方根が求まる。直観的に言うと、Nの世界にリフトされるわけであ
る（Nの世界に4つの値）。

　今後Rabin暗号の内部の動きをあまり意識したくないので、Encの計算をRabin関
数と呼ぶことにする。即ち、暗号化はy=Rabin_N(x)と書ける（xが平文、Nが法、
yが暗号文に対応）。一方、復号はRabin関数の逆関数x=Rabin^(-1)_N(y)に対応す
る。
　先に述べた事実により、Nの素因数であるp,qを知らないときはRabin関数の逆関
数を解くことができず、p,qを知っているときはRabin関数の逆関数を解くことが
できる。Rabin関数は入力が4つのパターンにつき、出力が1つになるので、関数で
ある（置換ではない）。またNの素因数を知らないと逆計算ができないので、一方
向性である。よって、Rabin関数は一方向性関数である（暗号理論においては一方
向性置換の方が扱いやすい）。

　以上より、Rabin暗号の課題は一意に復号できないことと、IND安全を持たない
ということである。


■0x04.) 1型の素数を法の平方根の求め方

　Shanks-TonelliのアルゴリズムはAlberto Tonelliによって提案され、Daniel 
Shanksにより改良されたものである。

　p（奇素数）、t（奇数）、s（整数）はp-1=(2^s)・tを満たす数である。例えば、
p=3であれば、p-1=2=2^1・1となり、s=t=1である。また、p=11であれば、p-1=10=
2・5=2^1・5となり、s=1,t=5となる。
　つまり、sはp-1をバイナリ表現したときに1桁目から見て1が出るまでの0の個数
と同じである。また、tはp-1をsビット分右シフトした結果の数である。p=11の例
で言えば、p-1=10d=1010bであり、1桁目は0で、2桁目で1が出る。つまり、1が出
るまでにs=1個の0が現れた。s=1ビット分だけ1010bを右シフトすると、101bにな
る。これは10進数で5なのでt=5となる。

　pは奇素数なので、p-1は偶数になる。よって、常にs≧1が成り立つ。
　ただし、s=1、p-1=2^1・tのときは特殊ケースである。tは奇数なので、t=2l+1
(l∈Z)と書ける。このtをp=2t+1に代入すると、p=2(2l+1)+1=4l+2+1=4l+3≡3 (m
od 4)となる。つまり、pは3型の素数となり、[1]の方法で平方根を求めることが
できる。

●Shanks-Tonelliのアルゴリズム

　Shanks-Tonelliのアルゴリズムは次のような仕組みで実装される。

入力：a∈QR_p、p：奇素数
出力：x s.t. x^2≡a (mod p)

1 : p-1=2^s・tを満たすs,tを計算する。
2 : u∈QNR_pを生成する。
3 : z←u^t (mod p)
4 : x←a^{(t+1)/2} (mod p)
5 : b←a^t (mod p)
6 : k=s
7 : while(b≠1 (mod p)) {
8 :	b^(2^m)≡1 (mod p)を満たす最小のmを計算する。
9 :	t←z^{2^(k-m-1)} (mod p)
10:	z←t^2 (mod p)
11:	b←bz (mod p)
12:	x←xt (mod p)
13:	k←m
14: }
15: output x.

　もし入力aがQR_pでない場合も考慮するならば、「a^{(p-1)/2}≡-1 (mod p)」
（オイラー規準）かどうかのチェックを最初に行い、成り立てばそのaはQNR_pに
含まれるのでabortすればよい。

　ステップ2〜6、ステップ7、ステップ8、ステップ9〜13をそれぞれステージ1,2,
3,4と呼ぶことにする。

○ステージ1

　ステップ2はZ_p^*からランダムに要素を選択し、オイラー規準を適用してチェ
ックすればよい。
　ステップ3〜6は各パラメータの初期設定である。xはaの平方根の最初の候補で
ある。

　ステージ1が完了すると、2^t=2^sを満たす。
　また、x^2≡ab (mod p)　←(*)という関係も満たす。なぜならば、(左辺)=(a^
{(t+1)/2})^2=a^(t+1)、(右辺)=a・a^q=a^(q+1)であるから。この(*)はすべての
ステージで維持されていることに注意して欲しい。

○ステージ2

　ループが終える度にbの位数が減っていき、なおかつ位数は毎回2のべき乗の形
になっている。
　ループ回数はせいぜいs回であることが知られている。せいぜいs回のループが
終わると、ord_p(b)=1になり、b≡1 (mod p)を満たす。つまり、x^2≡ab≡a (mo
d p)を満たす。つまり、出力値は平方根になる。

○ステージ3

　位数の定義より、ステップ8はord_p(b)=2^mを満たすmを探していることを意味
する。

○ステージ4

　ステージ4はx^2≡ab (mod p)かつord_p(z)=2^mを維持しながら、zが何らかのべ
き乗になるように変換させていく。
　ステップ11でbはbzに置き換わるので、新しいbの位数はせいぜい2^(m-1)になる。

　ステージ4の完了後、x^2≡ab (mod p)を満たしていることを確認する。(左辺)
=(古いx)^2=(xt)^2=(x・z^2^(k-m-1))^2=x^2・z^2^(k-m)、(右辺)=a・(古いb)=a
・bz=abt^2=abz^2^(k-m)である。ここでステップ2,3の時点でx^2≡ab (mod p)な
ので、(左辺)=(右辺)になり、ステージ4の完了後もx^2≡ab (mod p)が成り立つ。

　特にNがBlum数のときは、p,qがどちらも3型なので、上記の[1]のアルゴリズム
を使えばよいので、効率がよい。


■0x05.) 制限Rabin暗号

　Rabin暗号は一意に復号するために、WB45で紹介したBlum数が役に立つ。Blum数
とは、p,qが4で割って3余る素数（3型の素数という）のときのN=pqのことである。
　「NがBlum数」ならば「x∈QR_Nとし、y^2≡x (mod N)を満たす4つのyをy1,y2,
y3,y4とすると、それぞれが次の4つの集合Q^(1,1)_N, Q^(0,1)_N, Q^(1,0)_N, Q
^(0,0)_Nに含まれる。つまり、y1∈Q^(1,1)_N, y2∈Q^(0,1)_N, y3∈Q^(1,0)_N,
 y4∈Q^(0,0)_Nとなる。さらにy1≡-y4 (mod N), y2≡-y3 (mod N)である」とい
う定理が存在する。

-------------------------
|           |           |
| Q^(1,1)_N | Q^(0,1)_N |
|           |           |
|-----------+-----------|
|           |           |
| Q^(1,0)_N | Q^(0,0)_N |
|           |           |
-------------------------

　各集合の意味は、次の通りである。

・Q^(1,1)_N：(y1/p)=(y1/q)=1を満たすy1の集合、即ちQR_p,QR_qを満たす集合
・Q^(0,1)_N：(y2/p)=-1,(y2/q)=1を満たすy2の集合、即ちQNR_p,QR_qを満たす集合
・Q^(1,0)_N：(y3/p)=1,(y2/q)=-1を満たすy3の集合、即ちQR_p,QNR_qを満たす集合
・Q^(0,0)_N：(y4/p)=(y4/q)=-1を満たすy4の集合、即ちQNR_p,QNR_qを満たす集合

　例えば、p=11,q=13とすると、N=pq=143になる。

(7/143)
=(7/11)(7/13)
=(-1)(-1)
=1

　よって、7∈QNR_143、もう少し厳密に言えば7∈Q^(0,0)_143である。よって、
x^2=7 (mod 143)を満たす整数xは存在しない。　◇

　このとき、(y1/N)=(y4/N)=1, (y2/N)=(y3/N)=-1であること、y1+y4≡0 (mod N)
, y2+y3≡0 (mod N)であることに注意して欲しい（この事実を制限Rabin暗号の設
計で利用する）。

　また、法Nの平方剰余と非平方剰余と各集合の関係は次の通りである。

・QR_N=Q^(1,1)_N
・QNR_N=Q^(0,1)_N ∪ Q^(1,0)_N ∪ Q^(0,0)_N
・Z_N^*=QR_N ∪ QNR_N

　以上の関係は複雑に見えるが、次の図を参考にすれば直観的に理解できるはず
である。

（図）http://security2600.sakura.ne.jp/main2/image4/QR_N.jpg

　以上より、NをBlum数とすると、Rabin関数の逆計算結果の4つの値がきれいに各
集合に分かれる。(y/N)の値と0＜y＜N/2に属するか否かという2つの状況さえわか
れば、4つの集合のどれにyが属するかどうかが一意に決まるのである。
　例えば、(y/N)=1かつ0＜y＜N/2であれば、yはQ^(1,1)_Nに含まれることがわかる。

　Rabin暗号の鍵生成アルゴリズムでステップ2でp,qとして3型の素数を生成する
ことで、NがBlum数になる。さらに、平文空間をQ^(1,1)_Nとする。即ち、暗号化
アルゴリズムの入力の平文mは、(m/N)=1かつ0＜m＜N/2を満たすということである。
このようにRabin暗号を改良したものを制限Rabin暗号と呼ぶことにする（本によ
っては制限付きRabin暗号とも呼ぶ）。制限Rabin暗号の復号アルゴリズムはRabi
n暗号の復号アルゴリズムと同じことを実行し、それに加えて(m/N)=1かつ0＜m＜
N/2を満たすものを選べば、それが平文になる。つまり、制限により4つの平文候
補を正しい平文1つに絞り込むことができるのである。

●制限Rabin暗号の仕様

　制限Rabin暗号の各アルゴリズムを次にまとめておく。

制限Rabin暗号=(KeyGen,Enc,Dec)

○KeyGen

1：1^kを入力とする。

2：kビットの3型の素数p,qを生成する。

3：pk=N=pq,sk=(p,q)とし、pk,skを出力する。

○Enc

1：平文m（(m/N)=1かつ0＜m＜N/2を満たすm）、公開鍵pkを入力とする。

2：c=Rabin_N(m)=m^2 mod Nを計算して、cを出力する。

○Dec

1：暗号文c、秘密鍵skを入力とする。

2：Rabin^(-1)_N(c)を計算して（p,qを知っているので可能）、その結果をm1〜m4
とする。

3：m1〜m4のうちで、(m/N)=1かつ0＜m＜N/2を満たすものを選択して、出力する。

●改良Rabin暗号の仕様の解説

　±aはcのmod pの平方根、±bはcのmod qの平方根とした場合、Decのステップ2
で生成される4つの平文候補を次のようにおいたとする。

・m1=[a,b]
・m2=[-a,b]
・m3=[a,-b]
・m4=[-a,-b]

　ただし、[*,*]の記号の意味は次の通りである。

「m=[a,b]」⇔「a≡m (mod p) ∧ b≡m (mod q)」

　このとき、ステップ3の絞込みの第1条件の(m/N)=1より、m1かm4だけが残る。な
ぜならば、次のように計算されるからである。

・(m1/N)=(m1/p)(m1/q)=1・1=1
・(m2/N)=(m2/p)(m2/q)=(-1)・1=-1
・(m3/N)=(m3/p)(m3/q)=1・(-1)=-1
・(m4/N)=(m4/p)(m4/q)=(-1)・(-1)=1

　次に、絞込みの第2条件の0＜m＜N/2より、どちらかだけが残る。なぜならばm4
≡-m1 mod Nという関係より、片方だけが0＜m＜N/2に含まれるからである。

（図）http://security2600.sakura.ne.jp/main2/image4/rabin1.jpg


　これで一意に復号できることがわかった。しかしながら、平文空間に制限を設
けたということは、実用上問題になりかねない。


■0x06.) 改良Rabin暗号

　この問題を解決するには、平文空間に制限を設けるのではなく、暗号文の中に
ヒントを混ぜておく方法が考えられる。つまり、Rabin_N(m)の計算結果だけでな
く、(m/N)の値と0＜m＜N/2に属するか否かという情報を含めるのである。前者・
後者とも2択なので、1ビットの情報が2つあれば、復号結果を絞り込める。このよ
うな改良を加えた暗号方式を改良Rabin暗号と呼ぶことにする。

●改良Rabin暗号の仕様

改良Rabin暗号=(KeyGen,Enc,Dec)

○KeyGen

1：1^kを入力とする。

2：kビットの3型の素数p,qを生成する。

3：pk=N=pq,sk=(p,q)とし、pk,skを出力する。

○Enc

1：平文m、公開鍵pkを入力とする。

2：c1=Rabin_N(m)=m^2 mod Nを計算する。

3：(m/N)=1ならばc2=1、(m/N)=-1ならばc2=0とする。

4：0＜m＜N/2ならばc3=1、N/2≦m＜Nならばc3=0とする。

5：c=(c1,c2,c3)を出力する。

○Dec

1：暗号文c、秘密鍵skを入力とする。

2：Rabin^(-1)_N(c)を計算して（p,qを知っているので可能）、その結果をm1〜m4
とする。

3：c2,c3の結果を使って、m1〜m4から1つmを絞り込んで出力する。


■0x07.) Williams暗号

　pが8で割って3余る素数、qが8で割って7余る素数のとき、N=pqをWilliams数と
呼ぶ。例えば、N=21はWilliams数である。なぜならばp=3≡3 (mod 8)、q=7≡7 (
mod 8)だからである。
　Williams数はBlum数の定義を満たすので、Blum数の性質を持つ。それに加えて、
次の定理が成り立つ。

[定理]N：Williams数とする。このとき∀x∈Z_N^*；x, -x, 2x, -2xのどれかがQ
R_Nに含まれる。

　NがBlum数の場合のy1,y2,y3,y4が、この定理のx,2x,-2x,-xに対応しており、確
かにy1+y4≡x-x≡0 (mod N), y2+y3≡2x-2x≡0 (mod N)が成り立っていることが
わかる。さらに、NがWilliams数の場合は、2番目の数は1番目の数にも2倍になる
という関係さえ存在する。つまり、NがWilliams数の場合、Rabin関数の逆計算が
公式のようにきれいに表現できそうだ。
　このWillimas数を利用してRSA暗号を改良した暗号をWilliams暗号と呼ぶ（Wil
liamsらはその後に別の方式も提案している）[W80]。暗号化・復号のときに、ヤ
コビ記号の結果によって場合分けを行っている点がRSA暗号と異なる。

●Williams暗号の仕様

Williams暗号=(KeyGen,Enc,Dec)

○KeyGen

1：1^kを入力とする。

2：8で割って3余る素数であるp、8で割って7余る素数であるqを生成する。ただし、
p,qはkビットとする。

3：N=pq、λ=LCM((p-1),(q-1))とする。

4：(λ,e)=1∧e＜λを満たすe（∈Z）を選択する。

5：δ={(p-1)(q-1)/4+1}/2とする。

6：ed≡δ (mod λ)を満たすdを求める。

7；pk=(N,e),sk=(p,q,d)とし、pk,skを出力する。

○Enc

1：平文空間Mを以下を満たすすべての正の整数全体とする。

・((2m+1)/N)=1のとき、4(2m+1)＜N
・((2m+1)/N)=-1のとき、2(2m+1)＜N

　そして、平文m∈M、公開鍵pkを入力とする。

2：c'=E1(m)を計算する。E1は以下の関数である。

・((2m+1)/N)=1のとき、E1(m)=4(2m+1)
・((2m+1)/N)=-1のとき、E1(m)=2(2m+1)

3：c=E2(c')を計算する。E2は以下の関数である。

・c=E2(c')=(c')^(2e) (mod N)

4：cを出力する。

○Dec

1：暗号文c、秘密鍵skを入力とする。

2：l=D2(c)を計算する。D2は以下の関数である。

・l=D2(c)=c^d (mod N)

3：m'=D1(l)を計算する。D1は以下の関数である。

・l≡0 (mod 4)のとき、m'=D1(l)=(l/4-1)/2
・l≡1 (mod 4)のとき、m'=D1(l)=((N-l)/4-1)/2
・l≡2 (mod 4)のとき、m'=D1(l)=(l/2-1)/2
・l≡3 (mod 4)のとき、m'=D1(l)=((N-l)/2-1)/2

●Williams暗号の仕様の解説

　Encのステップ1ではWilliams暗号が利用できる平文空間Mを定義している。この
Mの大きさはNの値、つまりp,qの値に依存している。
　Encのステップ2では((2m+1)/N)を計算する必要がある。この計算量は5log_10(
2m+1)以下であることが知られている。

●Williams暗号の完全性

　以上のことを踏まえて完全性を確認する。つまり、Dec(Enc(m))=m、即ちD1(D2
(E2(E1(m)))=mが成り立つことを示す。
　c'=E1(m)は偶数（∵これが成り立つようなメッセージ空間からmを選択したから）、
かつ0＜c'＜Nである。
　一方、N=pq=3・7=21≡5 (mod 8)より、(2/N)=(-1)^{(N^2-1)/8}=(-1)^{(25-1)
/8}=(-1)^3=-1
　よって、c'は偶数なのでc=2rとおくと、(c'/N)=(2/N)(r/N)
　ここで、(2/N)=-1である。また、((2m+1)/N)=1のときにr=2(2m+1)、((2m+1)/N
))=-1のときにr=2m+1なので、(r/N)=(2/N)=-1である。よって、(c'/N)=(-1)(-1)
=1
　次に、lを計算する。

l
=D2(E2(c'))
=c'^(2ed) (mod N)
≡c'^(2δ) (mod N)　（∵(ed≡δ (mod φ(N)))
≡c'^{(p-1)(q-1)/4}・c' (mod N)　（∵δ={(p-1)(q-1)/4+1}/2）
≡±c' (mod N)　（∵(c'/N)=1より、c'^{(p-1)(q-1)/4}≡±1 (mod N)）

　さらに、lは偶奇により、c',Nを使って一意に表すことができる。

・l：偶数のとき、l=c'　←(*)
・l：奇数のとき、l=N-c'　←(**)

　上記であることを考慮しながら、lを法4で場合分けする。

[1]l≡0 (mod 4)のとき

m'
=(l/4-1)/2
=(c'/4-1)/2　（∵(*)）
=(2m+1-1)/2　（∵c'=E1(m)=4(2m+1)）
=m

[2]l≡1 (mod 4)のとき

m'
=((N-l)/4-1)/2
=(c'/4-1)/2　（∵(**)）
=(2m+1-1)/2　（∵c'=E1(m)=4(2m+1)）
=m

[3]l≡2 (mod 4)のとき

m'
=(l/2-1)/2
=(c'/2-1)/2　（∵(*)）
=(2m+1-1)/2　（∵c'=E1(m)=2(2m+1)）
=m

[4]l≡3 (mod 4)のとき

m'
=((N-l)/2-1)/2
=(c'/2-1)/2　（∵(**)）
=(2m+1-1)/2　（∵c'=E1(m)=2(2m+1)）
=m

　以上で完全性を示すことができた。

　安全性についてはまだ論文を読みきれていないので、今後の回したいと思う。


■0x08.) シングルビットRabin暗号

　改良Rabin暗号により、平文を一意に特定できることがわかった。次の課題はO
W-CPA安全よりも高い安全性を満たすことである。ここではIND-CPA安全を満たす
ことを目指す。

　まずBlum数と平方剰余の関係を確認しておく。
　Z_N^*から元を1つ選択して2乗してできた集合はQR_Nであり、Z_N^*の部分群に
なっている。このQR_Nの元をさらに2乗すると、またQR_Nに含まれる。NをBlum数
とし、このようにQR_NからQR_Nへのへの写像fを考える。この写像fは1対1なので、
置換になる。
　よって、Rabin関数の定義域をZ_N^*にすれば入力と出力が4対1になり（だから
一方向性関数）、定義域をQR_Nにすれば入力と出力は1対1になる（だから一方向
性置換）。

（図）http://security2600.sakura.ne.jp/main2/image4/QR_N_map.jpg

　また、Blum数の素因数分解が困難と仮定する。このとき、rをQR_N（NはBlum数）
からランダムに選択して、x=Rabin_N(r)=r^2 (mod N)を計算する。そして、Nとx
を入力として、LSB(r)を出力する（確率的多項式時間）アルゴリズムは存在しな
いことが知られている（[ACGS88],[AGS03]）。ここでLSB(・)は最下位ビット、即
ちmod 2で計算することを意味する。Z_N^*から一様ランダムに元aを選択して、そ
の元を二乗してできるa^2は集合QR_N上で一様分布している（これがサンプリング
する対象の集合をQR_Nに使いやすい理由である）。
　NがBlum数であれば、Nとr^2 (mod n)から、rの最下位ビット、即ちr (mod 2)を
計算するのは困難ということである。

　この数学的事実を踏まえると、拡張Rabin暗号を改良してIND-CPA安全な、1ビッ
トの暗号を構成できる。これをシングルビットRabin暗号と呼ぶことにする（Katz
とLindellの『Introduction to modern cryptography』ではこのスキームをRabin
暗号として紹介し、素朴なRabin暗号の方を教科書的Rabin暗号と呼んでいる）。

●シングルビットRabin暗号の仕様

シングルビットRabin暗号=(KeyGen,Enc,Dec)

○KeyGen

1：1^kを入力とする。

2：kビットの3型の素数p,qを生成する。

3：pk=N=pq,sk=(p,q)とし、pk,skを出力する。

○Enc

1：平文b∈{0,1}、公開鍵pkを入力とする。

2：QR_Nからランダムにrを選択する。

3：s=Rabin_N(r)=r^2 (mod N)を計算する。

4：c1=b XOR LSB(r)を計算する。

5：c=(c1,s)を出力する。

○Dec

1：暗号文c、秘密鍵skを入力とする。

2：Rabin^(-1)_N(s)を計算して（p,qを知っているので可能）、その結果をr'とす
る。

3：c1 XOR LSB(r')を出力する。


●シングルビットRabin暗号の完全性

　まずは完全性から確認する。仕様通りに暗号化アルゴリズムEncで計算して得ら
れた暗号文を、仕様通りに復号アルゴリズムDecで復号した結果、Encに入力した
平文と同じことを確認すればよい。

Dec(Enc(b,pk),sk)
=Dec(Enc(b,N),(p,q))
=Dec(c,(p,q))
=c1 XOR LSB(r')
=b XOR LSB(r) XOR LSB(r')
=b XOR LSB(r) XOR LSB(r)　（∵NがBlum数より、r'=r)
=b XOR 1
=b

　これで完全性が満たされていることがわかった。


●シングルビットRabin暗号のCCA安全性

　次に敵が暗号文cを盗聴したときに、bの情報が漏れていないことを直観的に確
認する。敵Aにc=(c1,s)=(c,r^2 (mod N))とpk=Nが与えれたとしても、LSB(r)はわ
からない。LSB(r)が分からなければ、c1からbを求めることはできない。よって、
シングルビットRabin暗号はBlum数の素因数分解が困難という仮定の下で、IND安
全である。きちんと証明したければ、帰着法を使えばよい。つまり、シングルビ
ットRabin暗号のIND安全を破るアルゴリズムを用いて、Blum数の素因数分解をす
るアルゴリズムを構成すればよい。

　nビットの平文を暗号化したければ、このシングルビットRabin暗号をn回繰り返
せばよいが、効率が悪い。毎回、暗号化アルゴリズムでQR_Nからrを生成する必要
があり、さらにrに関連するsが暗号文に含まれてしまっている。そのため、nビッ
トの平文の暗号であれば、c1がnビット、sがnビットで、合わせて2nの暗号文の長
さになってしまう。
　次の課題はシングルビットRabin暗号の暗号文の長さを短くすることである。


■0x09.) BBS擬似乱数生成器

　シングルビットRabin暗号の暗号文の長さを短くするために利用できるのがBBS
（Blum-Blum-Shub）擬似乱数生成器である（[BBS86]）。これは平方剰余の性質を
利用した擬似乱数生成器である。

●BBS擬似乱数生成器の仕様

　BBS擬似乱数生成器の入出力と、そのアルゴリズムは次のようになる。

1：p≡q≡3 (mod 4) ∧ |p|=|q|=k/2を入力とする。

2：N=pqを計算する。

3：QR_Nからランダムにs0を選択する。

4：s0をRabin関数に入力してx1を計算し、それをまたRabin関数に入力する。こう
してl個の{x1,…,x_l}を計算する。これらの計算をまとめると次のようになる。

x1←Rabin_N(s0)
x2←Rabin_N(x1)
…
x_l←Rabin_N(x_(l-1))

5：x=LSB(x1)||LSB(x2)||…||LSB(x_l)を計算して、x（lビット）を出力する。

　x0がBBS擬似乱数生成器の種となり、f(x0)=xを満たすfが(k,l)-PRNGであるBBS
擬似乱数生成器そのものである。

　ステップ1でp,qは3型の素数なので、NはBlum数である。よって、ステップ4で使
っているRabin関数はQR_N上の置換になっている。
　ステップ2を実装するには、Z_Nからランダムに1つ選択して、Nと素かどうか判
定し、素ならば2乗すればよい。x^2 mod nからxの最下位ビット、即ちLSB(x)を計
算するのには全xを計算するぐらい困難なので、LSB(x1),LSB(x2),…,LSB(x_l)は
それぞれx1,x2,…,x_lの情報を完全に隠している（LSBの値がハードコアビットに
なっている）。つまり、ステップ5で計算されるxからはx1,x2,…,xlの情報が1ビ
ットも漏れていない。

例：p=91,q=59のとき（p≡q≡3 (mod 4)を満たす）、N=pq=5369

s0=2009^2≡754 (mod 5369)
x1=x0^2=754^2≡1978 (mod 5369)　→LSB(x1)=0
x2=x1^2=1978^2≡961 (mod 5369)　→LSB(x2)=1
x3=x2^2=961^2≡1390 (mod 5369)　→LSB(x3)=0
…

　よって、x0を種としてBBS擬似乱数生成器によって生成される最初の3ビットは
"010"になる。　◇


●QR問題とQR仮定

　x∈Z_N^*かつ(x/N)=1を満たすxとN(=pq)が与えられたときに、xがQR_Nに属する
かどうか（xがNの平方剰余かどうか）を1/2よりも有意の確率で判定することは困
難であると信じられている（山勘で答えれば1/2の確率で判定可能）。この問題を
QR（Quadratic Residuosity）問題という。このQR問題が困難であるという仮定を
QR仮定という。

（図）http://security2600.sakura.ne.jp/main2/image4/QR_N_hantei.jpg

　QR仮定と素因数分解が困難という仮定を比べると、QR仮定の方が強い仮定であ
る。なぜならば、素因数分解が容易であれば、Nを素因数分解し、p,qを知ること
ができ、QR問題も容易に解けるからである。一方、QR問題が解けたからといって、
素因数分解の問題が解けるとは限らない。素因数分解をしないでQR問題を解くう
まい方法があるかもしれないからである。

　ところで、a∈QR_Nのときは、(a/N)と(-a/N)の両方ともが1になってしまう。こ
れを先ほどの集合Qで説明すると、a,-aは次を満たすことを意味する。

・a∈Q^(1,1)_N
・-a∈Q^(0,0)_N

　Q^(1,1)_Nは法Nの平方剰余、Q^(0,0)_Nは法Nの擬似平方（pseudo-square）剰余
と呼ばれる。

　この事実を定理の形にまとめておく。

[定理]a∈QR_N⇒(a/N)=(-a/N)=1

[証明]仮定「a：法N=pqにおいて平方剰余」より、「a：法p,qにおいて平方剰余」
である。

　また「a：法p,qにおいて平方剰余」⇒「-a：法p,qにおいて平方非剰余」になる。

　よって、(a/p)=-(-a/p) ∧ (a/q)=-(-a/q)が成り立つ。

　したがって、(a/N)=(a/p)(a/q)=(-1)^2・(-a/p)(-a/q)=(-a/N)　□


●BBS擬似乱数生成器の安全性

　次にBBS擬似乱数生成器の安全性について考察する[S05]。
　BBS擬似乱数生成器の安全性はQR仮定に基づいている。よって、BBS擬似乱数生
成器を破るアルゴリズム（Aとする）を利用して、QR問題を解くアルゴリズム（QR
-TESTとする）が構成できればよい。

　(k,l)-擬似乱数生成器の安全性は、擬似乱数生成器で生成されるlビットの擬似
乱数と、lビットの真の乱数が区別できないということである。つまり、擬似乱数
のZ_2^l上の確率分布と、Z_2^lの一様確率分布が有意の確率で識別できないこと
である。
　今は(k,l)-BBS擬似乱数生成器を破るアルゴリズムAが存在するとしているので、
lビットの（BBS擬似乱数生成器の出力である）擬似乱数と真の乱数を識別するア
ルゴリズムが存在するということになる。このA（識別する確率をηとする）が存
在すると、(η,l)-前ビット推定器を構成できる。
　この(η,l)-前ビット推定器（このアルゴリズムをPBPとする）とは、fを(l,l)
-PRNGとするとき、fによって生成されるビット列z1,…,z_lを入力として取り、f
の種の偶奇、即ちfがBBS擬似乱数生成器のときはLSB(s0)を少なくとも1/2+η(η
＞0)の確率で予測できるアルゴリズムのことである。
　Aが存在すれば、(η,l)-前ビット推定器が存在することが知られている。よっ
て、Bの構成に、(η,l)-前ビット推定器を利用することができる。このとき、Bの
構成方法は次の通りになる。

1：QR-TESTの入力として、x∈Z_N^*∧(x/N)=1を満たすxとNが入力される。

2：s1=x^2 (mod N)、z1=LSB(s1)を計算する。

3：BBS擬似乱数生成器の仕様通りにs1を種として、z2,…,z_lを計算する。

4：QR-TESTは内部でPBPにz1,…,z_lを入力して起動し、出力結果としてz1の種の
推測値の最下位ビット、即ちLSB(x)を受け取る。

5：LSB(x)=zならば1を出力し、そうでなければ0を出力する。ただし、Bの出力が
1のときは入力値xがQ_N^(1,1)に含まれ、出力が0のときは入力値xがQ_N^(0,0)に
含まれると定義する。

　以上でBの構成は終わりである。このBが1/2+ηの確率でQR問題を解くことを調
べる。

　N：Blum数かつ(1/N)=1より、(-1/N)=1である（∵NがBlum数ならば、y1+y4=Nか
つy4∈Q_N^(0,0)より、y4=N-1に対応するので、(y4/N)=(N-1/N)=(-1/N)=1）。よ
って、-1∈Q_N^(0,0)である。
　s0をs1の平方根（s0∈Q_N^(1,1)）とする。(x/N)=1なので、x∈Q_N^(1,1)なら
s0=x、x∈Q_N^(0,0)ならs0=-xとなる。
　z1,…,z_lはs0を種としてBBS擬似乱数生成器によって生成されたlビットの擬似
乱数である。このlビットの擬似乱数を入力としてPBPはz（∈{0,1}）を出力する。
z1=LSB(s1)=LSB(s0^2 mod N)なのでz1にはxの情報が含まれており、PBPはz1を含
む入力から、出力zとしてxの情報であるLSB(s0)を出力するのである。
　さらに、Nは奇数なので、xと-x(=N-x)は偶奇が異なる。つまり、LSB(x)≠LSB
(-x)である。つまり、s0がxか-xかはLSB(s0)がLSB(x)かLSB(-x)かということに対
応する。
　よって、x∈Q_N^(1,1)のとき（s0=xのとき）に、PBPが正しくz=s0と出力すると
きに、QR-TESTは完全に1を出力する。よって、少なくとも1/2＋ηの確率でxがQ_
N^(1,1)に含まれることを識別できる。
　一方、x∈Q_N^(0,0)のとき（s0=-xのとき）に、PBPが正しくz=s0を出力すると
き、QR-TESTは完全に0を出力する。よって、少なくとも1/2＋ηの確率でxがQ_N^
(0,0)に含まれることを識別できる。

　以上の[1][2]より、入力値がx,-xのどちらであっても、QR-TESTは1/2+ηの確率
でQ_N^(1,1)に含まれるか否かを識別できる。　□



■0x0A.) BG暗号

　シングルビットRabin暗号とBBS擬似乱数生成器を組み合わせることで、シング
ルビットRabin暗号をn回繰り返すよりも効率のよい暗号方式を構成できる。ここ
ではBlumとGoldwasserによって提案されたBG暗号を紹介する。

●BG暗号の仕様

BG暗号=(KeyGen,Enc,Dec)

○KeyGen

1：1^kを入力とする。

2：kビットの8で割って3余る素数p,qを生成する。

3：pk=N=pq,sk=(p,q)とし、pk,skを出力する。

○Enc

1：平文m∈{0,1}^n、公開鍵pkを入力とする。

2：QR_Nからランダムに要素を選択し、x0とする。

3：i=1,…,nに対して、x_i=x_(i-1)^2 mod Nを計算する。

4：mask=LSB(x0)||LSB(x1)||…||LSB(x_(n-1))とし、c1=mask XOR mを計算する。

5：c=(c1,x_n)を出力する。

○Dec

1：暗号文c、秘密鍵skを入力とする。

2：Rabin^(-1)_N(x_n)を計算して（p,qを知っているので可能）、その結果x_(n-1)
を得る。これを繰り返せば、x_0,x_2,…,x_nをすべて求めることができる。

3：mask=LSB(x0)||LSB(x1)||…||LSB(x_(n-1))を計算して、c1 XOR maskを計算し
て出力する。

●BG暗号の仕様の解説

　KeyGenのステップ2ではNがBlum数になるようにp,qを生成しているが、NがWill
iams数になるようにp,qを生成してもよい。もし、NがWilliams数であれば、復号
時にx_lからx_0を効率的に求める方法があることが知られている（らしい）。

　Encのステップ2でx0をランダムに生成しているが、これはZ_Nからランダムに要
素zを選択し、x0=z^2 mod Nとすればよい。この乱数x0をうまく利用してBG暗号が
確率暗号の性質を満たすようにしている。もしこのような乱数がまったく暗号化
アルゴリズムに存在しなければ、確定暗号になってしまう。
　Encのステップ5でc1だけを出力すると、正当な受信者（秘密鍵sk=(p,q)を知っ
ている）であっても復号できなくなってしまう。そのため、鍵を計算することの
ヒントになるものであるx_lも添付される。
　一方、不正な受信者である敵（p,qを知らない）はx_lからx_(l-1)のhard-core
ビットであるLSB(x_(l-1))がわからない。ただし、敵はx_(l-1)のうちLSB(x_(l-
1))を除くすべての部分情報を知っている可能性はある。さらに、x_(l-1)を完全
に知っていたとしても、LSB(x_(l-2))は同様にわからない。ここでは、的はx_(l
-1)を完全に知らないはずだから（少なくともhard-coreビットの部分は知らない）
、LSB(x_(l-2))はわかるはずがない。以下同様な議論により、敵はLSB(LSB(x0),
…,LSB(x_(l-1))がわからないので、maskがまったくわからない。よって、c1から
1ビットも情報が漏れていないことがわかる。このアイデアはバーナム暗号が平文
と同じビット長の乱数でXOR演算により隠すことと非常に似ている。

　Decのステップ2でx_l(=(x_0)^(2^l))からx_(l-1)(=(x_0)^(2^(l-1)))、x_(l-1)
からx_(l-2)、…とどんどんNを法とする平方根を求めている。このとき一意に決
まっていくのは、NがBlum数であり、なおかつRabin関数が常にQR_NからQR_Nへの
写像になっているからである。


●BG暗号の安全性

　BG暗号はQR仮定の下でIND-CPA安全であるが、IND-CCA安全ではない。なぜなら
ば、敵が公開鍵pk(=N)とターゲット暗号文c^*=(c1^*,x_l^*)を得たとする。この
とき、復号オラクルを利用して、c_1^*の平文を特定できたら敵の勝ちである。
　敵はQR_Nからランダムにc1'を選択し、(c1',x_l^*)を復号オラクルに送信する。
すると、復号オラクルはm'=mask XOR c1'を満たすm'を返信する。敵はc1' XOR m'
 XOR c1^*を計算して出力すればよい。するとこの出力値は必ずc1^*の平文になっ
ている。なぜならば、次のように計算できるからである。

c1' XOR m' XOR c1^*
=c1' XOR (mask XOR c1') XOR (mask XOR m1^*)　（c1^*の平文をm1^*とした）
=(c1' XOR c1') XOR (mask XOR mask) XOR m1^*
=1 XOR 1 XOR m1^*
=m1


■0x0B.) まとめ

　本当はQR仮定の下でIND-CPA安全GM暗号も紹介する予定だったが、WBの締め切り
までにまとめることができなかったので、今後に回す予定である。

　これまでのWBで紹介した暗号方式をまとめると次のような表になる。ここで素
因数分解が困難であるという仮定をHF仮定と略することにする。

------------------------------------------------------------------------------
| 暗号名                  | 仮定           | 安全性  | 特徴                  |
|============================================================================|
| ElGamal暗号             | CDH仮定        | OW-CPA  |                       |
|-------------------------+----------------+---------+-----------------------|
| 拡張ElGamal暗号         | DDH仮定        | IND-CPA |                       |
|-------------------------+----------------+---------+-----------------------|
| 教科書的RSA暗号         | RSA仮定        | OW-CPA  | CRTを使えば高速化可能 |
|-------------------------+----------------+---------+-----------------------|
| Rabin暗号               | HF仮定         | OW-CPA  | 一意に復号できない    |
|-------------------------+----------------+---------+-----------------------|
| 制限Rabin暗号           | Blum数のHF仮定 | OW-CPA  | 平文空間に制限がある  |
|-------------------------+----------------+---------+-----------------------|
| 改良Rabin暗号           | Blum数のHF仮定 | OW-CPA  | 部分情報の漏れが多い  |
|-------------------------+----------------+---------+-----------------------|
| Williams暗号        | Williams数のHF仮定 | OW-CPA  | 平文空間に制限がある  |
|-------------------------+----------------+---------+-----------------------
| シングルビットRabin暗号 | Blum数のHF仮定 | IND-CPA | 1ビットずつ暗号化     |
|-------------------------+----------------+---------+-----------------------|
| BG暗号                  | QR仮定         | IND-CPA | Williams数だと高速    |
|-------------------------+----------------+---------+-----------------------|

　仮定の強弱についても復習しておく。
　CDH仮定はDDH仮定より弱い仮定である（弱い仮定の方がよい）。
　一方、HF仮定はQR仮定やRSA仮定より弱い仮定である。Blum数のHF仮定、Willi
ams数のHF仮定は通常のHF仮定と同等の妥当性があるとされている（素数に制約が
あっても、素因数分解は同程度に難しいとされている）。

　また安全性はIND-CPA安全はOW-CPA安全よりも強い安全性である（強い安全性の
方がよい）。

　次回のネタはまだ考えていないが、せっかく平方剰余を解説してきたので、さ
らに平方剰余に関係する暗号技術を紹介する予定である。例えば、GM暗号、QR仮
定に基づくコイントスプロトコルやIDベース暗号、Solvey-Strassenアルゴリズム
などを考えている。


■0x0C.) 参考文献

・[W80] H. C. Williams. A modification of the RSA public-key encryption 
procedure. IEEE Transactions on Information Theory, IT-26(6):726?729, No
vember 1980.
・[ACGS88] Werner Alexi, Benny Chor, Oded Goldreich, Claus-Peter Schnorr:
 RSA and Rabin Functions: Certain Parts are as Hard as the Whole. SIAM J.
 Comput. 17(2): 194-209 (1988)
・[AGS03] A. Akavia, S. Goldwasser, and S. Safra. Proving hard-core pred
icates using list decoding. In in Proc. of the 44th Annual IEEE Symposium
 on Foundations of Computer Science, 2003.
・[B01] Daniel J. Bernstein, Faster square roots in annoying finite fields.
・[BBS86] Blum, Leonore, Blum, Manuel, and Shub, M., A Simple Unpredicta
ble Pseudo-random Number Generator, SIAM Journal of Computing, vol. 15, 
no. 2, May 1986, pp 364-383.
・[BER67] Berlekamp, E. R., Factoring Polynomials over Finite Field, Bel
l System Technical Journal, Vol. 46, 1967, pp. 1853-1859.
・[CP03] J. Christoph, S. Puchta, On Shank's Algorithm for Modular Squar
e Roots. Applied Mathe- matics E-Notes, 5 (2005), 84-88. 3.
・[R89]T. Rabin and M. Ben-Or, Verifiable Secret Sharing and Multi-party
 Protocols with Honest Majority・ In 21st ACM Symposium on the Theory of
 Computing, pages 73-85, 1989
・[S73]D. Shanks, Five number-theoretic algorithms, in: Proceedings of t
he Second Manitoba Conference on Numerical Mathematics, Congressus Numer
antium, No. VII,1973, 51-70.


