x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: VMware Server使いの憂鬱 ---

著者：金床

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　ﾎﾟｳﾝﾆﾁﾜ。筆者の会社のｻｰﾊﾞｰでは、VMware Serverの1系列を本格的に運用して
いる。ﾎｽﾄOSはLinuxである。今回はこの「Linux上で走らせるVMware Serverの1.0
系列」で筆者がはまりにはまった数々の点について検証をおこなっていく。以下
の記事の内容はﾎｽﾄOSがWindowsの場合とは全く関係がないので注意していただき
たい。


■0x02.) ﾒﾓﾘがﾃﾞｨｽｸに書き込まれる？？

　ｹﾞｽﾄOSを起動すると、vmxﾌｧｲﾙが置かれているﾃﾞｨﾚｸﾄﾘ内に拡張子が.vmemのﾌｧｲ
ﾙが生成される。筆者の環境で、この.vmemﾌｧｲﾙをlsｺﾏﾝﾄﾞで確認すると次のように
なる。

-----
[root@raptor CentOS5_4]# ls -l *.vmem
-rw------- 1 root root 2344615936 Oct  3 15:36 564def5e-64dc-af0a-2c64-7bbc2c6ee46d.vmem
-----

　ちょｗｗｗｻｲｽﾞでかすぎｗｗｗｱﾘｴﾅｽｗｗｗ
　…という感じである。桁数が大きすぎてよくわからないので-hｵﾌﾟｼｮﾝも付ける
と次のようになる。

-----
[root@raptor CentOS5_4]# ls -lh *.vmem
-rw------- 1 root root 2.2G Oct  3 15:36 564def5e-64dc-af0a-2c64-7bbc2c6ee46d.vmem
-----

　2.2Gでつか…。
　この2.2という数字は、実はｹﾞｽﾄOSに割り当てたﾒﾓﾘの量そのものである。ｹﾞｽﾄ
OSを起動すると、このように必ず割り当てたﾒﾓﾘの量と同じｻｲｽﾞのﾌｧｲﾙが生成され
てしまう。2.2Gのﾌｧｲﾙというのは決して無視できるｻｲｽﾞではなく、ﾃﾞｨｽｸの圧迫や
ﾊﾟﾌｫｰﾏﾝｽへの影響が懸念される。

　さてVMwareにはｻｽﾍﾟﾝﾄﾞという機能がある。ﾒﾓﾘの内容を一時的にすべてﾃﾞｨｽｸに
退避し、ｹﾞｽﾄOSを一時的に停止する。そして後ほどまたﾃﾞｨｽｸからﾒﾓﾘへと内容を
読み込み、その時点から作業を再開するための機能だ。このことを知っているｴﾝ
ｼﾞﾆｱであれば「ああ、なるほどこのvmemﾌｧｲﾙはｻｽﾍﾟﾝﾄﾞのために使われるのだな」
と思うだろう。

　筆者はひとつ実験をしてみた。2.2Gほどのﾒﾓﾘを割り当てたｹﾞｽﾄOSを起動する（
ここではｹﾞｽﾄにもLinuxを使った）。起動したら、すぐにｻｽﾍﾟﾝﾄﾞさせる。このｻｽﾍﾟ
ﾝﾄﾞの処理がどのくらいの時間を要するかを調べてみた。すると驚くことに、一瞬、
わずか数秒でｻｽﾍﾟﾝﾄﾞが終了してしまった。

　筆者が以前使っていた、Windows上で動作するVMware Workstationの3系列では、
ｻｽﾍﾟﾝﾄﾞはそれなりの時間を要する処理だった。つまり、「ああ、ﾒﾓﾘの内容をそ
のままﾃﾞｨｽｸに書き込んでいますね」という感じの時間が掛かっていた。これは新
しいVMwareであるVMware Serverの動きとまったく異なっていた。2.2Gものﾒﾓﾘの
内容をﾃﾞｨｽｸに書き込むためには、かなりの時間が必要なはずだ。にもかかわらず、
VMware Serverは一瞬でｻｽﾍﾟﾝﾄﾞを完了した。

　これらのことから、筆者は次のような動きを想像した。

　1. VMware Serverは、常にﾒﾓﾘの内容を.vmemﾌｧｲﾙに同期させている
　2. そのため、ｻｽﾍﾟﾝﾄﾞは一瞬で終わる
　3. 起動する際には割り当てたﾒﾓﾘと同ｻｲｽﾞの巨大なﾌｧｲﾙが毎回生成される

　仮に1が事実だとすると、とんでもないことになる。ﾒﾓﾘへの書き込みがあるた
びにﾃﾞｨｽｸにも書き込みが発生することになり、ﾊﾟﾌｫｰﾏﾝｽが大きく低下してしまう
だろう。そのため筆者は「これはとんでもない改悪だな」と思っていた。
　しかし幸いなことに筆者の想像は間違っていた。まずは.vmemﾌｧｲﾙのｻｲｽﾞについ
ての勘違いから説明する。
　このファイルは実は「スパースファイル」と呼ばれる、実際のサイズと見た目
のサイズが異なるものなのだ。普通にls -lやllなどで確認すると2.2Gあるように
見えるが、lsコマンドの-sオプションを使うと実際のサイズを確認することがで
きる。

-----
[root@raptor CentOS5_4]# ls -lsh *.vmem
184M -rw------- 1 root root 2.2G Oct  4 23:35 CentOS5.vmem
-----

　このように、実際にディスク上に占めるサイズは184Mなのである。straceを使
って確認したところ、次のようなシステムコールによってこのスパースファイル
が生成されていることが確認できた。

-----
pwrite64(106, "\0", 1, 3774873599) = 1
-----

　ここで106はこのときのﾌｧｲﾙﾃﾞｨｽｸﾘﾌﾟﾀである。これは3.6Gほどのﾒﾓﾘを割り当て
てみたときのﾄﾚｰｽとなっている。巨大なﾌｧｲﾙの最後の1ﾊﾞｲﾄだけNULLを書き込んで
いることがわかる。ﾌｧｲﾙが巨大だが書き込みはわずか1ﾊﾞｲﾄなので、この処理は一
瞬で終了する。


■0x03.) .vmemﾌｧｲﾙは更新されているのか？？

　さて筆者がさらにこの.vmemﾌｧｲﾙではまったのが、「このﾌｧｲﾙはいつ更新されて
いるのか？」という点である。ls -lによって.vmemﾌｧｲﾙの更新日時を見ていたの
だが、どうにも更新されない。いつまでたってもﾀｲﾑｽﾀﾝﾌﾟが古いままなのである。

　結論から書くと、Linuxではファイルの（いわゆる）更新日時には3種類のデー
タが存在し、筆者が見ていたのはmtimeと呼ばれるものだったのだ。詳しくは「U
NIXの部屋 」に素晴らしい記事があるので、そちらを参照願いたい。

http://x68000.q-e-d.net/~68user/unix/pickup?%A5%BF%A5%A4%A5%E0%A5%B9%A5%BF%A5%F3%A5%D7

　.vmemファイルがいつ更新されたかを確認するにはls -luが適切である。

　これはVMware Serverが.vmemファイルを更新する際に（readやwriteではなく）
mmap2というシステムコールを使っていることが原因である。


■0x04.) .vmemファイルはなぜ184Mしかないのか？

　さて順序がばらばらで申し訳ないのだが、再び先ほどのｻｽﾍﾟﾝﾄﾞに話を戻す。
2.2Gのメモリを割り当てたゲストOSを起動直後にｻｽﾍﾟﾝﾄﾞさせたところ、.vmemﾌｧ
ｲﾙの実際のｻｲｽﾞはわずか184Mしかない。これは実は、起動直後のｹﾞｽﾄOSは、実際
にはﾒﾓﾘへのｱｸｾｽをその程度しか行っていないからである。

　古いVMwareでは、ｹﾞｽﾄOSが起動した瞬間にﾎｽﾄOSは実際に2.2Gのﾒﾓﾘを確保し、
ｹﾞｽﾄOSのために割り当てていた。しかし新しいVMwareでは、ｹﾞｽﾄOSが実際にﾒﾓﾘを
使うときになってはじめてﾎｽﾄOSのﾒﾓﾘを確保するのである。このため複数のｹﾞｽﾄ
OSを使う場合に効果的にﾒﾓﾘを使うことができる、ということになる。

　ｹﾞｽﾄOS上でﾒﾓﾘを実際に大量に消費するﾌﾟﾛｾｽ（例えばmallocでｷﾞｶﾞﾚﾍﾞﾙのﾒﾓﾘを
確保し、さらにそのﾒﾓﾘのすべての領域に書き込みを行うもの）を走らせた後にｻ
ｽﾍﾟﾝﾄﾞを行うと、ｻｽﾍﾟﾝﾄﾞの処理に時間がかかり、さらに.vmemﾌｧｲﾙの実際のｻｲｽﾞ
も大きくなることが確認できる。

　これらのﾒﾓﾘ管理や.vmemﾌｧｲﾙへのｱｸｾｽはすべてmmap2というシステムコールによ
って行われており、straceによって調査してみると非常に大量のmmap2やmunmapが
呼び出されていることが確認できる。


■0x05.) mainMem.useNamedFile = "FALSE"の罠

　筆者と同じく「最近のVMwareはメモリの内容を常にディスクに同期させている」
と勘違いしている人はたくさんいたようで、「この同期をoffにする方法はないか
？」という議論が各地で行われていた。つまり、ゲストが起動したら問答無用で
ホストOSのメモリをたっぷり（例えば2.2G）割り当てる。そしてサスペンドを行
うときになって初めてディスクに書き込めばよいではないか、という意見である。
これは「メモリはたくさんあるから、とにかくパフォーマンスを重視したい」と
いう人々の願いであった（結論を先に書くと、Linuxではこれは実現できない。W
indowsはしらないｗ）。

　これらの熱心な願いに、神は答えを与えた。「汝、.vmxファイルにmainMem.us
eNamedFile = "FALSE"の行を追加すべし」と。

　この行を.vmxファイルをエディタで編集し追加することで、次回起動時から.v
memファイルが生成されなくなるのである。…なんだ、最初からそうしてよ！とい
う感じである。

　しかし筆者が調べてみたところ、動作がおかしい。ゲストOSを起動しても、相
変わらずホストOSのメモリがたいして消費されないのだ。つまり「ゲストが起動
したら問答無用でホストOSのメモリをたっぷり（例えば2.2G）割り当てる」とい
うことができていないのである。

　vmware関連の英語のフォーラムでさかんに議論されていたので苦労して解読し
たのだが、やはりこの行を追加しても（少なくともLinuxでは）ゲストにメモリを
いきなり使わせることはできないと書いてあった。そしてstraceによって動作を
観察してみたところ、またひとつとんでもない事実が発覚した。次の一連のシス
テムコールである。

-----
open("/tmp/vmware-root/mm0", O_RDWR|O_CREAT|O_EXCL|O_LARGEFILE, 0600) = 102
unlink("/tmp/vmware-root/mm0")          = 0
pwrite64(102, "\0", 1, 268435455)       = 1
-----

　なんと/tmp以下にﾌｧｲﾙを作成し、すぐにunlinkしているのだ。そしてそのﾌｧｲﾙ
ﾃﾞｨｽｸﾘﾌﾟﾀを実質.vmemﾌｧｲﾙとして使い続けているのである。

　筆者はしらなかったのだが、Linuxではこのように、あるﾌﾟﾛｾｽ中でopenによっ
て作成したﾌｧｲﾙをunlink（一般的に「ﾌｧｲﾙの削除」とされる処理）した後でもそ
のﾌｧｲﾙについて書き込んだり読み込んだりすることができるのだ。そしてこのﾌｧ
ｲﾙはﾌﾟﾛｾｽの終了時に実際に削除される。いわゆる隠しﾌｧｲﾙという感じである。

　unlinkされているためｼｪﾙからはこのﾌｧｲﾙは見えない。例えばls -lなどで確認
しようとしても見ることができない。しかしこのﾌﾟﾛｾｽ（ここではVMwareのそれぞ
れのｹﾞｽﾄOSのﾌﾟﾛｾｽであるvmware-vmx）は稼働中このﾌｧｲﾙを使い続ける。このﾌｧｲ
ﾙは.vmemそのものであり、使用を続けていればかなり大きなｻｲｽﾞになる。かなり
大きな隠しﾌｧｲﾙが勝手に/tmp以下に作成されることになるため、これにハマって
しまう人もいることだろう（実際に筆者の身内に一名確認されている）。例えば
/tmpのサイズが小さいとか、/tmpが特殊なファイルシステム（たとえばメモリ）
になっている場合などには激しく地雷である。

　このように、Linuxでは「mainMem.useNamedFile = "FALSE"」の行は

　・.vmemファイルを/tmp以下の隠しファイルにしてしまう

　という意味しか持たない。これによって何かが改善されることは普通はないと
思われるので、この行の追加はやる必要がないと筆者は考える。


■0x06.) いきなりスワップする罠

　ゲストOSを複数起動している場合、当然ながら「今、どのくらいのメモリが空
いているか？」ということが気になるだろう。そんなあなたは「free」コマンド
を打ち、その結果に満足するはずだ。しかしまだまだメモリが大量に空いている
はずなのに、いきなりスワップがはじまって狼狽した経験はないだろうか。

　Linuxでは、ぶっちゃけfreeコマンドは役に立たない。freeでは、そのとき使用
されている「共有系」メモリがまったくカウントされないからだ。「共有系」メ
モリとして、筆者が知っているのは以下の2つである（ちなみに筆者はLinuxのOS
そのものについての知識はたいしたことないというか、かなり詳しくない方なの
でﾖﾛｽｺ）。

　1. 共有メモリ
　2. MAP_SHAREDでmmapされたメモリ

　1は異なるプロセス間でメモリ領域を共有するための仕組みで、shmgetというシ
ステムコールによって確保することができる。PostgreSQLのようなデータベース
でよく使用されるようだ。

　ここでひとつ余談である。筆者は昔PostgreSQLのチューニングに失敗したこと
がある。PostgreSQLに大量の共有メモリの使用を許可してしまったためPostgreS
QLはOSのメモリを大量に消費し、そのあおりをくらったTomcatがｼﾎﾞﾘ。ウェブサ
ーバーの様子がおかしい、とアラートのメールが携帯に到着。ﾔﾝﾏｶﾞの立ち読みを
中断してあわててリモートからログインしたものの、psがsegmentation faltにな
ってしまうためOSの状態をまったく把握できない。脂汗をかきながら超高速で「
reboot」と打ち込んだところ、無事に再起動して九死に一生を得たのである。そ
の後も数日おきに同じようなﾒﾓﾘ不足が発生するが、なかなか原因を突き止めるこ
とができなかった。言うまでもないが、freeの結果からはﾒﾓﾘが大量に空いている
ように見えたからだ。PostgreSQLが大量に消費していた共有ﾒﾓﾘは、freeからはま
ったく確認できなかったのである。

　共有ﾒﾓﾘの様子は、ipcsｺﾏﾝﾄﾞで確認することができる。しかし共有メモリもス
パースファイルの場合と似ていて、「確保はしてあるが実際には消費されていな
い」ことがある。例えば次のようなコードで共有メモリが確保されたとする。

-----
#define SHM_SIZE 1024 * 1024 * 1024
（中略）
shmget(IPC_PRIVATE, SHM_SIZE, 0700 | IPC_CREAT )
-----

　このときipcs -mすると次のようになるため、1Gの共有メモリが存在するように
見える。

-----
------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status
0x00000000 589835     root      700        1073741824 0
-----

　しかし確保された領域に対して実際にアクセス（書き込み？）が行われたとき
はじめて本当にメモリが消費される。このことはipcsでは確認できず、/proc/me
minfoのMAPPEDなどを見ることで確認することができる。

　次に2だが、これはmmapシステムコールをMAP_SHAREDで呼び出した場合に確保さ
れるメモリ領域である。例えば次のようなコードで確保することができる。

-----
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <unistd.h>

int main( int argc, char* argv[] )
{
int fd;
int i;
int size;
char* p;
fd = open( "hoge", O_RDWR );

size = 1024 * 1024 * 1024;
p = mmap( NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0 );
for( i = 0; i < size; ++i )
        {
        *p = 0x61;
        ++p;
        }

sleep( 1000 );

return 0;
}
-----

　エラー処理まったくしていませんがﾅﾆか。このコードを使う場合、あらかじめ
ddでhogeという名前の1Gのファイルを作成しておく必要がある。

　このようにmmapで確保されたﾒﾓﾘもfreeからはまったく確認できない（共有ﾒﾓﾘ
ではないため、ipcsからも見えない）。topｺﾏﾝﾄﾞのSHRの行か、あるいは/proc/m
eminfoのMAPPEDなどを見ることで確認することができる。VMware Serverが確保す
る大量のﾒﾓﾘはこのﾀｲﾌﾟであるので、知らない場合には非常にやっかいだ。


■0x07.) VMwareﾁｭｰﾆﾝｸﾞまとめ

　ということで以下に筆者的なまとめを書いておく。

　・すべてのｹﾞｽﾄOSがﾌﾙにﾒﾓﾘを消費しても大丈夫な量のﾒﾓﾘをﾎｽﾄOSに載せておく
　・ﾎｽﾄのﾒﾓﾘが実際にいくつ消費されているのかはぶっちゃけわからないので、
気にしないｗｗｗ
　・どうしても気になる場合は/proc/meminfoを見る
　・mainMem.useNamedFile = "FALSE"は使わない
　・そのほかは普通にやる（Fit all virtual…やDisable memory page trimming
など）

　役に立たないfreeｺﾏﾝﾄﾞは解放してやりましょう。free free!



