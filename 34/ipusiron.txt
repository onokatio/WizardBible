x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座 ～ 第10回 ～ ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　WB32とWB33を通じて、公開鍵暗号の一種であるElGamal暗号の安全性がDH問題に
帰着されることを見た。今回は公開鍵暗号の中でも最も有名といえるRSA暗号を紹
介し、その安全性を直観的に説明する。

・WB32（http://wizardbible.org/32/32.txt）
・WB33（http://wizardbible.org/33/33.txt）


■0x02.) RSA暗号

　今回WBで説明するRSA暗号は最も単純なタイプである。よく本などに登場するも
のなので、教科書的RSA暗号とも俗に呼ばれる。この教科書的RSA暗号は、いくつ
か問題点を含んでいるので、実装される場合は教科書的RSA暗号はそのまま使われ
ないことに注意してもらいたい（問題点に関しては後述する）。


■0x03.) 準備

　まず、記号や基本となる数学的概念を直観的に定義しておく。

・素数：2以上の整数で、1かそれ自身でしか割り切れない整数。
・N=pq：素数p,qの積
・a≡b mod c：「a-bはcで割り切れる」という意味。つまり、「aをcで割った余
りがcになる」ということ。
・Z：整数の集合（普通は太文字で表記される）
・Z_N＝{0,1,…,N-1}：整数をNで割ったときに現れる数の集合
・∀○：「任意の○に対して」という意味
・○∈△：○は集合△の要素
・A⇒B：AならばB（Aが成り立つならば、Bが成り立つ）
・GCD（○,△）：○と△の最大公約数
・l=ψ(N)=(p-1)(q-1)：Nのオイラー関数値
・○←△：△を○に代入（C言語とかの＝をイメージすればよい）
・1^k：1がk桁ならんだバイナリ（2進）列。kはセキュリティパラメータと呼ばれ、
暗号強度を与える数である。鍵長を意味しているとイメージしてもらえればよい。

　N=pqのオイラー関数に代入した結果が(p-1)(q-1)になるということは、ここで
は省略する。今回はNの値はこう決まっていると考えて、読み進めて欲しい。

　このとき、次のような数学的事実が成り立つ。

「ed≡1 mod l」⇒「∀a∈Z_N;a^ed≡1 mod N」

　これは、「ed≡1 mod l」が成り立つならば、「∀a∈Z_N;a^ed≡1 mod N」が成
り立つという意味である。まず、「ed≡1 mod l」は「ed-1はl=(p-1)(q-1)で割り
切れる」という意味である。次に、「∀a∈Z_N;a^ed≡1 mod N」は「集合Z_N={1,
2,…,N-1}のすべての要素において、(a^ed)-1がNで割り切れる」という意味である。


■0x04.) 公開鍵暗号の復習

●公開鍵暗号系の定義

　公開鍵暗号は3つの効率的アルゴリズムで構成される。ここでいう効率的とは現
実的に計算できるということである。
　また、3つのアルゴリズムとは鍵生成アルゴリズムG、暗号化アルゴリズムE、復
号アルゴリズムDである。これらは次のような動きをする。

[1]鍵生成アルゴリズムG

(pk,sk)←G(1^k)

　pkは公開鍵（public key）、skは秘密鍵（secret key）である。

[2]暗号化アルゴリズムE

c←E(pk,m)

[3]復号アルゴリズムD

m←D(sk,c)

　さらに、次の条件を満たさなければならなかった。

[a]完全性

　任意の鍵ペア(pk,sk)と任意の平文mを考えたとき、暗号文アルゴリズムの定義
通りに暗号化して作られた暗号文は、復号アルゴリズムで正しく平文に復号でき
るという意味である。式で書けば次のようになる。

∀(pk,sk),∀m;D(sk,E(pk,m))=m

[b]一方向性

　「任意のアルゴリズムAでも、pkとcからmを求めることはできない」ということ
である。どんな敵を想定したとしても、秘密鍵を知らずに暗号文から平文を効率
的に求めることはできないという意味である。

　一方、正当な受信者は秘密鍵は自分自身で所有しているので、効率的に暗号文
から平文を求めることができるわけだ。このように秘密情報（ここでは秘密鍵）
を知っているかいないかで、平文を計算できるか否かの能力の差異ができること
を、暗号では利用している。


●特徴

　上記の定義からわかるように、公開鍵暗号系による暗号化では受信者だけが鍵
ペア（公開鍵と秘密鍵）を作ればよい。つまり、送信者は面倒な鍵生成という作
業をしなくても（作業をしたらきちんと秘密鍵を保管するという面倒な仕事があ
る）、よいのである。
　例えば、オンラインショッピング中はSSLで暗号化されているが、このとき購入
者は単にクリック作業だけで買い物できることはご存知の通りである。こうした
ところにも、暗号文の送信者が、鍵を生成しなくてもよいということの恩恵に預
かっていることになる。


■0x05.) RSA暗号の定義

　（教科書的）RSA暗号はアルゴリズムの組(G,E,D)で構成される。この3つのG,E
,Dは次に示すアルゴリズムである。暗号文の送信者をAlice、受信者をBobとする。
ここはRSA暗号の定義なので、各アルゴリズムの内部の動きを書く。

[1]鍵生成アルゴリズムG

　BobはGに1^kを入力して、公開鍵pkと秘密鍵skを作る。公開鍵は一般に公開され
（もちろんBobも見える）、秘密鍵はAlice自身が秘密に持っておく。Gは次のよう
な仕組みで公開鍵と秘密鍵を生成する。

1：大きな素数pとqを生成する。

2：N=pqを計算する。

3：GCD((p-1)(q-1),e)=1となるeをランダムに選択する。

4：拡張ユークリッドの互除法より、ed≡1 mod (p-1)(q-1)を満たすようなdを求
める。

5：公開鍵をpk=(N,e)、秘密鍵をsk=dを出力する。

[2]暗号化アルゴリズムE

　Aliceは、Bobの公開鍵pk=(N,e)と平文m∈Z_Nを入力として、次のように暗号文c
を作る。

c=m^e mod N

　このcをBobに送信する。

[3]復号アルゴリズムD

　Bobは受信した暗号文cと自分自身の秘密鍵sk=dを使って、次のように計算して、
暗号文cから平文mに復号する。

c^d mod N


■0x06.) 確認すべきこと

　（教科書的）RSA暗号の定義はすでに述べた。しかし、本当にこの定義で暗号と
して成立する要件が満たされているかどうかは、確認してみる必要はある。

[1]完全性

　まず、完全性（completeness）を確認しなければならない。これはRSA暗号に限
らず、すべての暗号・暗号プロトコルでもいえる。完全性とは、Aliceが定義通り
に暗号文cを生成したなら、Bobは定義通りに計算すれば平文mを計算できるという
ことである。それでは、Bobが定義通りに復号アルゴリズムDを実行して、その結
果がmになるかどうかを確認してみる。

c^d mod N
≡(m^e)^d mod N　（∵c=m^e）
≡m^ed mod N 
≡m mod N　（∵数学的事実1）

　きちんと平文mと一致することが確認できた。

[2]一方向性

　次に、確認すべきことは一方向性である。敵Aが暗号文c（=m^e）と公開鍵pk=
(N,e)を入手しても、平文mが計算できないということである。これはちょうど「
与えられた(N,e,c)から、c=m^e mod Nを満たすmを求める」という問題に置き換え
られる。この問題はRSA仮定と呼ばれている。

　このRSA問題を解くアプローチとしては、次が考えられる。

①p,qを計算するアプローチ
②l=ψ(N)=(p-1)(q-1)を計算するアプローチ
③それ以外のアプローチ

　①番目のアプローチを考えてみる。もしAが素因数分解が成功してp,qを知るこ
とができたら、秘密鍵であるdも効率的に計算できる（単に鍵生成アルゴリズムと
同じように作ればよい）。秘密鍵さえ知っていれば、mを計算できるのは完全性か
らわかる。

　②番目のアプローチを考えてみる。lの値はp,qを知らなくても、うまい方法で
計算できる可能性がある（もちろんp,qを知っていれば計算は可能なのは明らか）。
もしlを何らかの方法で知ることできれば、実はNを素因数分解できてしまうので
ある。これを見てみる。

l=(p-1)(q-1)=pq-(p+q)+1=N-(p+q)+1

　上記が成り立つので、p+q=N+1-lが成り立つ。ここでN,lは既知なので、今p+qは
既知である。

　根と係数の関係より、一般に解をp,qとしたとき、「x^2-(p+q)x+pq=0」が成り
立つ。これに、pq=Nとp+q=N+1-lを代入すると、次が成り立つ。

x^2-(N+1-l)x+N=0

　この2次方程式を解けば、p,qが求まる。2次方程式を求めるのは効率的にできる。
よって、p,qも効率的に計算できるということである。つまり、Nを素因数分解で
きたことを意味する。

　③番目のアプローチを考えてみる。もしかしたら、①と②のアプローチ以外に
ももっとうまい計算方法でmを求められる可能性も残っている。

　以上のことより、RSA暗号が安全であるためには最低限素因数分解が困難でなけ
ればならない。しかし、素因数分解を解くのが困難だとしても、RSA問題を解くの
が困難だとは限らない（これは暗号の世界でもまだ未解決）。よって、RSA問題は
素因数分解よりも易しいかもしれないわけである（易しくないとしても同等は確
定）。

　RSA問題を効率的に解くアルゴリズムが存在しないという仮定をRSA仮定と呼ぶ。
RSA問題はRSA仮定に基づく暗号ということである。


■0x07.) 教科書的RSA暗号の問題点

　RSA暗号は多くの場面で使われていて、なおかつよく知られている暗号なので、
様々な論文が発表されている。ここではすべて解説できないので、典型的な問題
点だけを紹介する。

●確定的

　教科書的RSA暗号の場合、暗号化アルゴリズムの中でまったくランダム値を利用
していない。つまり、同じ平文に対して、同じ暗号文が生成されるということで
ある。もちろん暗号としては、同じ平文であったとしても、別の暗号文が生成さ
れるほうが安全である。前者のタイプの暗号は確定的暗号、後者のタイプの暗号
は確率的暗号と呼ばれる。

http://s-akademeia.sakura.ne.jp/main/image8/kakuteiteki.jpg

　今回のRSA暗号は確定的暗号であり、WB32で解説したElGamal暗号は確率的暗号
になる。実装で利用されているPKCS#1では、RSA暗号を確率的に改良している。ま
たRSA暗号を改良したRSAP暗号は識別不可能性という強い安全性を持つ。


●素数の選び方

　教科書的RSA暗号の鍵生成アルゴリズムでは素数p,qの選び方として、大きいと
いう指定しかなかった。
　実際にpとqは大きいが、差|p-q|が極端に小さいとき、フェルマーの素因数分解
アルゴリズムを使って、N=pqを素因数分解できてしまう。
　また、数p±1,q±1が小さな因数だけしか持たない場合だと、効率的にNの素因
数分解ができるアルゴリズムが知られている。よって、実際のRSA暗号ではこうし
た素数が利用されることを防ぐために、素数の生成後に大きな因数を持つことを
チェックする。チェック後、大きな因数を持てば、その素数を利用するというこ
とになるわけだ。


●共用法攻撃

　RSA暗号を利用しているAliceとBobが法Nを共用していて、Aliceの公開鍵が(e1,
N)、Bobの公開鍵が(e2,N)で、さらにe1,e2が互いに素であるとする。AliceとBob
がそれぞれの公開鍵で暗号化した同一の平文は、その2つの暗号文の組とAliceと
Bobの公開鍵のみを使って復号できてしまうのである。これを確かめてみる。

　同一の平文mを、それぞれアリスの公開鍵(e1,N)、ボブの公開鍵(e2,N)で暗号化
する。このとき、「c1≡m^e1 mod N」∧「c2≡m^e2 mod Nが成り立つ。

　また、e1,e2は互いに素だから、「r・e1+s・e2=1」となる整数の組(r,s)が存在
する。ここで、r＜0と仮定しても一般性を失われない。そのときはs・e2=1+(-r)
・e1になる。

(c2)^s
=m^(se2)
≡m(m^(r))^e1
≡m(c1)^(-r) mod N

　よって、「{(c2)^s}{(c1)^r}≡m mod N」が成り立つ。ゆえに、平文mが解読で
きてしまった。


●ヤコビ記号から平文の部分情報が漏れる

　RSA暗号の場合は、「c=m^e mod N」かつ「e：奇数」のとき、次のように計算で
きる。ただし、括弧はヤコビ記号を意味する。

(c/N)
=(m^e/N)
=(m/N)^e　（∵分子分解）
=(m/N)　（∵eは奇数）

　よって、敵Aは暗号文cから平文mの部分情報(m/N)を計算できる。つまり1ビット
部分情報が漏れたことになる。


■0x07.) 終わりに

　今回はRSA暗号について解説した。RSA暗号の定義で登場したアルゴリズム群は、
素数を生成したり、ed≡1 mod Nを満たすeを計算したりしていた。そもそもa^xと
いうべき乗の計算も何度も登場している。こうした計算をコンピュータが効率的
に計算できるかどうかについてきちんとまだ議論していなかった。そこで、次回
からはこうした処理を効率的に計算するためのアルゴリズムを少しずつ紹介して
いく。一通りアルゴリズムが揃ったら、公開鍵暗号のRabin暗号や逆数暗号なども
解説していきたいと思う。



