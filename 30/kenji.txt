x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 暗号プログラミング　〜後編〜 ---

著者：Kenji Aiko

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　かの有名なP2Pソフト「Winny」の通信内容は、TCP接続確立後の初期パケットの
「先頭から3バイト目以降の4バイト」を鍵としたRC4で暗号化されています。とこ
ろが、一般的に暗号通信を行う場合はネットワーク上に流れるパケットデータの
中にそのままの状態の共通鍵は入れません。このような実装だと通信内容を確認
しただけで暗号を解読される恐れがあります。Winnyはそういった意味で、通信内
容の暗号化に関しては、あまり労力を割かなかったことがうかがえます。
　しかし、共通鍵暗号を使用する以上、通信相手と同じ鍵を共有しなければなり
ません。WinnyはRC4の鍵を乱数で生成しているため、その鍵をどうにかして相手
に送る必要があり、そのためにはどうしても鍵を送信しなければなりません。た
だ、鍵を送信するということは、通信データを傍受されることで暗号が解読され
てしまう危険性を伴います。
　これは不特定多数のコンピュータが相互に通信を確立する可能性があるインタ
ーネットという世界に、共通鍵暗号方式があまり向いていないことを意味してい
ます。もちろん実行ファイル（バイナリ）の中に鍵を入れておけば、送信せずと
も暗号通信を行うことは可能ですが、それだとすべての通信で鍵が同じになるた
めあまりお勧めできません。
　このようにインターネット上で共通鍵暗号のみの暗号通信を行う場合、鍵の送
信をどうするかといった問題が発生します。この問題を解決するために、一般的
に「公開鍵暗号」が使用されます。公開鍵暗号ならば、相手に公開鍵を送り、そ
の公開鍵でデータを暗号化して、その暗号データを送信元に送ってもらえれば、
安全にデータをやり取りできます。もし最初に共通鍵の交換を行いたいならば、
その共通鍵を公開鍵暗号でやり取りして、双方に共通鍵が渡った時点で共通鍵暗
号で暗号通信を行うことができます。こうすることで安全に暗号通信を行えます。
もちろん共通鍵暗号を使わずに、公開鍵暗号だけで以後の通信を行うこともでき
ますが、処理速度に問題が出るため、時と場合に応じて使い分ける必要があるで
しょう。


■0x02.) 認証

　「認証」とは、相手が誰であるかを確認することです。コンピュータやインタ
ーネットを利用しているとよくログイン名とパスワードを入力しますが、仮に世
界中の人が善人だったなら、パスワードは必要ありません。誰もが善人ですから、
他人のアカウントを利用することはないでしょう。よってパスワードなんて必要
ありません。しかし、世の中には他人に成りすまそうとする悪人がいるために、
パスワードという仕組みを導入し、アクセスしてきたユーザが本当に「本人」で
あるかどうかを確認しなければなりません。これを「認証」と呼びます。
　共通鍵暗号は鍵を持っている者しか暗号文を作成できませんが、公開鍵暗号は
誰もが鍵（公開鍵）を持っています。そして公開鍵は基本的にすべての人に公開
しますから、当然すべての人が暗号文を作成できます。ということは、公開鍵暗
号では、誰かに成り代わって暗号文を作成し、その暗号文を相手に送信すること
ができるのです。

+-- 鈴木さん ----------------------------------------------+
| 田中さんの公開鍵「Tpub」で、平文「私は加藤です」を暗号化 |
| 暗号文「..........」を田中さんに送信                     |
+----------------------------------------------------------+

      ↓ 暗号文「..........」

+-- 田中さん ----------------------------------------------+
| 田中さんの秘密鍵「Tpri」で、暗号文「..........」を復号化 |
| 平文「私は加藤です」を得る                               |
+----------------------------------------------------------+

　田中さんの公開鍵「Tpub」はすべての人に公開されています。よってこの公開
鍵を使って、誰もが田中さん宛ての暗号文を作成できます。つまり送信者を簡単
に偽ることができます。しかしそれでは困るので、その対策として公開鍵暗号で
は署名と検証という仕組みが存在します。


■0x03.) 署名と検証

　誰でも暗号文を作成できるため、自分が確かにそのデータを作成した本人であ
ることを相手に証明する必要があります。そのために「署名」という技術があり
ます。署名とは、簡単にいうと「データの作成者が自分であること」と「データ
が改ざんされていないこと」を証明するデータを付加することです。
　例えば「こんにちは、私は鈴木です」というデータを、相手に送信したいとし
ます。しかしこのデータだけを相手に送信しても、相手はこのデータを送信して
きた者が本当に鈴木さんであるかを確認することができません。よって送信者は
「こんにちは、僕は鈴木です」というデータのハッシュ値を「秘密鍵」で暗号化
し、その暗号化したデータと「こんにちは、僕は鈴木です」を相手の公開鍵で暗
号化したデータをいっしょに送信します。すると受信者はこの暗号化されたデー
タを「公開鍵」で復元して、ハッシュ値を求めることができます。そしてこのハ
ッシュ値と「こんにちは、僕は鈴木です」というデータのハッシュ値とを比較す
ることで、本当に鈴木さんから送られてきたものかどうかを確認できるのです。

+-- 鈴木さん ----------------------------------------------+
| 田中さんの公開鍵「Tpub」で、平文「私は鈴木です」を暗号化 |
| 暗号文「..........」を作成                               |
| 平文「私は鈴木です」のハッシュ値「ABCDEFGHIJK」を得る    |
| 鈴木さんの秘密鍵「Spri」で、「ABCDEFGHIJK」を暗号化      |
| 暗号文「ABCDEFGHIJK_Spri」を得る                         |
| 暗号文「..........」と暗号文「ABCDEFGHIJK_Spri」を送信   |
+----------------------------------------------------------+

      ↓ 暗号文「..........」「ABCDEFGHIJK_Spri」

+-- 田中さん ----------------------------------------------+
| 田中さんの秘密鍵「Tpri」で、暗号文「..........」を復号化 |
| 平文「私は鈴木です」を得る                               |
| 平文「私は鈴木です」のハッシュ値「ABCDEFGHIJK」を得る    |
| 暗号文「ABCDEFGHIJK_Spri」を                             |
| 鈴木さんの公開鍵「Spub」で復号化し「ABCDEFGHIJK」を得る  |
| 「ABCDEFGHIJK」と「ABCDEFGHIJK」を比較する（本物と判断） |
+----------------------------------------------------------+

　署名データは「データの作成者が自分であること」と「データが改ざんされて
いないこと」を証明するためのものであり、本人しか作成できないものでなけれ
ばなりません。よって自分しか知ることのできない「秘密鍵」を利用し、平文の
ハッシュ値を暗号化します。
　ちなみに、ここでは秘密鍵を利用して「暗号化する」と記述していますが、こ
の暗号文は公開鍵で復号化できるため、結局のところ誰でも読むことができます。
よって、厳密には「暗号化」とは呼べません。しかしこのテキストでは便宜上、
これも暗号化という言葉を使わせていただきます。

　さて、今度は鈴木さんが他人に成りすまそうとした場合の通信の流れを見てい
くことにします。

+-- 鈴木さん ----------------------------------------------+
| 田中さんの公開鍵「Tpub」で、平文「私は加藤です」を暗号化 |
| 暗号文「A.A.A.A.A.」を作成                               |
| 平文「私は加藤です」のハッシュ値「AbCdEfGhIjK」を得る    |
| 鈴木さん秘密鍵「Spri」で、「AbCdEfGhIjK」を暗号化        |
| 暗号文「AbCdEfGhIjK_Spri」を得る                         |
| 暗号文「A.A.A.A.A.」と暗号文「AbCdEfGhIjK_Spri」を送信   |
+----------------------------------------------------------+

      ↓ 暗号文「A.A.A.A.A.」「AbCdEfGhIjK_Spri」

+-- 田中さん ----------------------------------------------+
| 田中さんの秘密鍵「Tpri」で、暗号文「A.A.A.A.A.」を復号化 |
| 平文「私は加藤です」を得る                               |
| 平文「私は加藤です」のハッシュ値「AbCdEfGhIjK」を得る    |
| 暗号文「AbCdEfGhIjK_Spri」を                             |
| 加藤さんの公開鍵「Kpub」で復号化しても                   |
| 鈴木さんの秘密鍵「Spri」で暗号化されたものであるため     |
| 復号化できない（偽者と判断）                             |
+----------------------------------------------------------+

　このように他人に成りすまそうとしても、鈴木さんの秘密鍵で暗号化されたデ
ータは加藤さんの公開鍵では復号化できないため、結果的に、送信者が偽者であ
ることが分かります。これが署名と検証の仕組みです。

　では、実際に署名と検証を行うプログラムを書くことにします。


■0x04.) 署名検証プログラム（RSA）

　OpenSSLを使い、書名と検証を行うプログラムを作成します。OpenSSLについて
はWB29の「暗号プログラミング　〜前編〜」を参照してください。

-----  rsatest2.cpp
#include <stdio.h>
#include <string.h>
#include <openssl/rsa.h>
#include <openssl/objects.h>
#include <openssl/md5.h>

#pragma comment(lib, "libeay32.lib")
#pragma comment(lib, "ssleay32.lib")

int hexoutput(char *first_str, unsigned char *data, int len)
{
    int i;
    printf("%s", first_str);
    for(i=0; i < len; i++)
        printf("%02X", data[i]);
    printf("\n");
    return 0;
}

int tanaka(RSA *myrsa, BIGNUM *Spub_e, BIGNUM *Spub_n, 
           unsigned char *plain, unsigned int plain_len, 
           unsigned char *encrypt, unsigned int *encrypt_len,
           unsigned char *sigret, unsigned int *sigret_size)
{
    RSA *yoursa;
    unsigned char hash[16];
    
    yoursa = RSA_new();
    BN_hex2bn(&(yoursa->e), BN_bn2hex(Spub_e));  // copy public key e
    BN_hex2bn(&(yoursa->n), BN_bn2hex(Spub_n));  // copy public key n
    
    // encryption by suzuki public key
    *encrypt_len = RSA_public_encrypt(plain_len, plain, 
        encrypt, yoursa, RSA_PKCS1_OAEP_PADDING);

    // sign by tanaka private key (MD5 and sign)
    MD5(plain, plain_len, hash);
    RSA_sign(NID_md5, hash, 16, sigret, sigret_size, myrsa);
    
    // print data
    hexoutput("ENCRYPT = ", encrypt, *encrypt_len);
    hexoutput("ENCSIGN = ", sigret, *sigret_size);
    
    RSA_free(yoursa);
    return 0;
}

int suzuki(RSA *myrsa, BIGNUM *Tpub_e, BIGNUM *Tpub_n, 
           unsigned char *encrypt, unsigned int encrypt_len,
           unsigned char *decrypt, unsigned int *decrypt_len, 
           unsigned char *sigret, unsigned int sigret_size)
{
    RSA *yoursa;
    unsigned char hash[16];
    
    yoursa = RSA_new();
    BN_hex2bn(&(yoursa->e), BN_bn2hex(Tpub_e));  // copy public key e
    BN_hex2bn(&(yoursa->n), BN_bn2hex(Tpub_n));  // copy public key n
    
    // decryption by suzuki private key
    *decrypt_len = RSA_private_decrypt(encrypt_len, encrypt, 
        decrypt, myrsa, RSA_PKCS1_OAEP_PADDING);

    // sign by tanaka public key (MD5 and verify)
    MD5(decrypt, *decrypt_len, hash);
    if( ! RSA_verify(NID_md5, hash, 16, sigret, sigret_size, yoursa)){
        printf("verify error\n");
        return -1;
    }
    
    hexoutput("DECRYPT = ", decrypt, *decrypt_len);
    
    RSA_free(yoursa);
    return 0;
}

int main(int argc, char *argv[])
{
    RSA *rsa_t, *rsa_s;
    unsigned char encryptdata[1024], decryptdata[1024], sign[1024];
    unsigned int datalen, encryptlen, decryptlen, signlen;
    
    if(argc < 2){
        fprintf(stderr, "%s <RSA data>\n", argv[0]);
        return 1;
    }
    
    datalen = strlen(argv[1]);
    hexoutput("PLAIN   = ", (unsigned char *)argv[1], datalen);

    // make private key & public key
    rsa_t = RSA_generate_key(256 * 2, RSA_F4, NULL, NULL);
    rsa_s = RSA_generate_key(256 * 2, RSA_F4, NULL, NULL);

    // encrypt and sign by tanaka
    tanaka(rsa_t, rsa_s->e, rsa_s->n, (unsigned char *)argv[1], datalen, 
        encryptdata, &encryptlen, sign, &signlen);

    // decrypt and verify by suzuki
    suzuki(rsa_s, rsa_t->e, rsa_t->n, encryptdata, encryptlen, 
        decryptdata, &decryptlen, sign, signlen);

    RSA_free(rsa_t);
    RSA_free(rsa_s);
    return 0;
}
-----

-----  コマンドプロンプト
C:\>bcc32 -w rsatest2.cpp
Borland C++ 5.6.4 for Win32 Copyright (c) 1993, 2002 Borland
rsatest2.cpp:
Turbo Incremental Link 5.65 Copyright (c) 1997-2002 Borland
C:\>rsatest2 AAAA
PLAIN   = 41414141
ENCRYPT = 530F1153E6C5078B47FCDD737227C1A782D2A878DEA499CF65F086EF046F98522042B1
C6CDE5AFD03346CAA5F4014D73412D280BCA2C3C2A185572FB28487E01
ENCSIGN = 2588A2DF9AA429BEE4A6EEC60E71ACB75FCA1D6A87FF67A89115F2ECC878FD813CE5A9
5DF7862D5E97A82FF1316BC98DD6A192A499B7D34B8F20ECD85A9C9A26
DECRYPT = 41414141
C:\>
-----

　rsatest2.cppをコンパイルし実行すると、暗号文と署名データが出力されます。
署名データはサイズが16バイトのデータ（MD5ハッシュ値）を秘密鍵で暗号化して
いるため、上記のプログラムでは0x80バイトの固定値になります。暗号文は平文
のサイズによって、任意バイト（上記のプログラムでは0x80バイト）ごとに大き
くなるため、平文のサイズが4バイト（AAAA）の場合は残りの0x7Cバイトがパディ
ングされて暗号化されます。
　またプログラムでは署名を行うためにRSA_sign関数を検証を行うためにRSA_ve
rify関数を使っています。

-----  RSA_sign関数
int RSA_sign(              // 戻り値は、成功時1、失敗時0
    int type,              // ハッシュタイプ
    unsigned char *m,      // ハッシュデータ
    unsigned int m_len,    // ハッシュデータサイズ
    unsigned char *sigret, // 署名データ格納バッファ
    unsigned int *siglen,  // 署名データサイズ格納バッファ
    RSA *rsa               // 秘密鍵（RSA構造体）
);
-----

-----  RSA_verify関数
int RSA_verify(            // 戻り値は、成功時1、失敗時0
    int type,              // ハッシュタイプ
    unsigned char *m,      // ハッシュデータ
    unsigned int m_len,    // ハッシュデータサイズ
    unsigned char *sigbuf, // 署名データ
    unsigned int siglen,   // 署名データサイズ
    RSA *rsa               // 公開鍵（RSA構造体）
);
-----

　typeにはハッシュタイプを指定します。これはNID_sha1、NID_ripemd160、NID
_md5辺りから選択します。そしてここで指定したアルゴリズムを用いて計算した
ハッシュ値を次の引数であるmに渡します。上記のプログラムではMD5を使用した
ため、typeをNID_md5とし、mに16バイトのMD5ハッシュ値を入れています。
　あとは署名データ格納バッファと秘密鍵、もしくは署名データと公開鍵を入れ
て、署名や検証を行います。検証の成功はRSA_verify関数の戻り値で確認します。
検証が成功したら1、何かしらのエラーで失敗したら0が返ります。
　OpenSSLを使えば、基本的な暗号知識だけで本格的な暗号プログラミングを行う
ことができます。ぜひ活用してみてください。


■0x05.) 署名と検証を行うための条件

　ここでもう一度、検証について考えてみます。検証を行うためには相手の公開
鍵が必要であることはわかりました。よって検証を行うためにはどこかから相手
の公開鍵を手に入れなければなりません。もちろん通信の相手からもらってもよ
いですし、知り合いからもらってもよいのですが、ここでひとつの問題が発生し
ます。それは「あなたが持っている公開鍵は本当に相手の公開鍵なのか？」とい
うことです。
　もう一度、署名と検証の流れを示します。

+-- 鈴木さん ----------------------------------------------+
| 田中さんの公開鍵「Tpub」で、平文「私は加藤です」を暗号化 |
| 暗号文「A.A.A.A.A.」を作成                               |
| 平文「私は加藤です」のハッシュ値「AbCdEfGhIjK」を得る    |
| 鈴木さん秘密鍵「Spri」で、「AbCdEfGhIjK」を暗号化        |
| 暗号文「AbCdEfGhIjK_Spri」を得る                         |
| 暗号文「A.A.A.A.A.」と暗号文「AbCdEfGhIjK_Spri」を送信   |
+----------------------------------------------------------+

      ↓ 暗号文「A.A.A.A.A.」「AbCdEfGhIjK_Spri」

+-- 田中さん ----------------------------------------------+
| 田中さんの秘密鍵「Tpri」で、暗号文「A.A.A.A.A.」を復号化 |
| 平文「私は加藤です」を得る                               |
| 平文「私は加藤です」のハッシュ値「AbCdEfGhIjK」を得る    |
| 暗号文「AbCdEfGhIjK_Spri」を                             |
| 加藤さんの公開鍵「Kpub」で復号化しても                   |
| 鈴木さんの秘密鍵「Spri」で暗号化されたものであるため     |
| 復号化できない（偽者と判断）                             |
+----------------------------------------------------------+

　この署名と検証という仕組みでもっとも重要なことは、田中さんが持っている
「加藤さんの公開鍵」が必ず「加藤さんの公開鍵」でなければならないというこ
とです。これがもし鈴木さんの公開鍵であったなら、残念ながら検証は成功して
しまいます。
　いやいや、「加藤さんの公開鍵」と書かれてあるから、加藤さんの公開鍵なん
じゃないの？　と思われるかもしません。しかし田中さんが持っている「加藤さ
んの公開鍵」が本当に「加藤さんの公開鍵」であるかどうかは、実は誰にも保証
できません。もしかしたら「これは加藤さんの公開鍵だよ」といわれて、鈴木さ
んの公開鍵を渡されているかもしれません。つまり「公開鍵の受け渡しの時点で
すでに相手が偽者であった場合」は、検証で偽者だと判断することはできなくな
ります。よって署名と検証を行う場合は、前提条件として次の2つのことが成り立
っている必要があります。

・田中さんの公開鍵を鈴木さんが持っていることが証明されている
・鈴木さんの公開鍵を田中さんが持っていることが証明されている

　この2つが成り立っていれば仮に誰かが他人に成りすましたとしても、検証を行
うことで、偽者であることを確認できます。しかしこの2つのどちらかが成り立っ
ていなければ、残念ながら署名と検証はあまり意味をなしません。
　では、どうやってこの2つの条件をクリアするのでしょうか？　その答えとなる
のが認証局の存在です。


■0x06.) 認証局

　認証局とは、簡単にいうと「どの公開鍵が誰のものであるか？」を管理してく
れるシステムです。そして認証局は「電子証明書」という、いかにも堅苦しいデ
ータを発行してくれます。その電子証明書には「登録された公開鍵」「その公開
鍵の持ち主の情報」「発行元の認証局の情報」「発行元の認証局の署名」といっ
たものが記述されています。
　つまり認証局が発行した電子証明書には、「公開鍵」と「誰の公開鍵であるか」
ということが正確に記述されており、ここ（認証局）から取得した公開鍵は「基
本的に」誰のものであるかが証明されていると考えることができます。これによ
って「田中さんの公開鍵を鈴木さんが持っていること」、そして「鈴木さんの公
開鍵を田中さんが持っていること」を証明することができるわけです。
　ただ、実は電子証明書は誰でも発行することができます。とてもお手軽です（
ぉぃ。なので、認証局自身も発行する電子証明書に対して署名を行っています。
それが電子証明書に書かれてある「発行元の認証局の署名」です。
　ということは、この電子証明書に対して検証を行わなければならないわけです
が、検証には公開鍵が当然必要です。よって認証局が発行した電子証明書を検証
するために「認証局の公開鍵」を入手しなければなりません。では、この「認証
局の公開鍵」はいったい誰が発行しているのかというと、さらに上位の認証局が
存在し、その上位の認証局が発行していたりします。じゃあ、その上位の認証局
が発行する電子証明書を検証するためにはどうするのかというと、さらにさらに
上位の認証局が発行する公開鍵を手に入れて…、ではさらにさらに上位の認証局
が発行する電子証明書を検証するためには……、さらにさらにさらに上位の……
…、以後無限ループ。
　しかし無限ループさせるわけにはいかないので、どこかで認証局自身が公開鍵
を発行することになります。結局、認証局の公開鍵は「上位の認証局」もしくは
「その認証局自身」が発行することになります。
　実のところ私は認証局や公開鍵の信頼性関連の話題について、あまり詳しくあ
りません。というか、ほぼ知りません(^^;。ただ、まぁプログラマなら、認証局
というのがあって、そこが公開鍵の信頼性を保っているのだろうというくらいの
認識で良いかと思います（ホントか？）。つまり結局のところ、認証局というあ
る程度信頼できるシステムから受け取った電子証明書（公開鍵）を、信頼できる
ものと考えて、暗号通信に使用するということだと思います。
　この辺りに関連して、金床さんがWB15にて「SSL Man In The Middle Attack」
という記事を書かれています。こちらはとても興味深い内容なので、ぜひ一読し
てみてください。


■0x07.) さいごに

　署名と検証を行うことでデータの改ざんと送信者を保証することができる、と
いうのはわかりました。ではWinnyのようなP2Pネットワークにおいて、公開鍵暗
号と署名検証というシステムを利用し、送信者を保証することは可能でしょうか？
　署名と認証には相手の公開鍵を自分が持っているという証明が必要です。しか
し現在のP2Pネットワークには認証局という概念が存在しないため、接続完了後に
自前で公開鍵を相手に送信する必要があります。しかし公開鍵を送信する時点で
その通信を中継している者が公開鍵を変更してしまったら、検証はできません。
つまりWinnyを含めた存続のP2Pソフトは、例え公開鍵暗号で通信したとしても、
暗号アルゴリズムさえ特定されてしまえば、以後は中継者によってその暗号を解
読されてしまうことになります。
　ところが、それでもWinnyを始めとする国産のP2Pソフトウェアの多くはプロト
コルを非公開とし、通信内容にもある程度の暗号化を施しています。海外のP2Pソ
フトウェアの多くがオープンであるのとは対照的に、日本のP2Pソフトウェアは驚
くほど秘匿なネットワークとなっています。
　この違いが今後の日本のP2P技術の進化にどう影響するかはわかりませんが、海
外とは異なった方向で独自の進化を進めていけば、また面白いP2Pソフトウェアが
開発されるかもしれません。
　というわけで、今回の記事を楽しんでいただけたなら幸いですが、実は私自身
暗号もP2Pも最近勉強し始めたばかりですので、このテキストの内容が間違ってい
る可能性があります(^^;。もし間違いを見つけたら、kenji@ruffnex.oc.toか、私
のHPのBBSへ書き込んでもらえると有難いです。

　さて、最後になりましたが、ここまで読んでくれて本当にありがとうございま
す。
　では、また会う日まで...


