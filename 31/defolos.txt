x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: はじめてのハッキング　〜プログラミングの基礎〜 ---

著者：Defolos

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回に引き続き、初学者のためのハッキング技術の解説を行います。今回は基
礎知識の確認としまして、ハッカーの必須知識であるプログラミングの基礎につ
いて解説します。個々のプログラミング言語の文法はWizard Bibleの読者の方々
は私よりもよほど精通していらっしゃると予想されますので、文法よりも一般的
かつ重要な概念を確認することに主軸を置きました。
　これからの予定は、次回にも引き続き基礎知識の確認としてハードウェアの基
礎知識を確認し、その次の回でバッファオーバフローの仕組みと実践を解説する
予定です。


■0x02.) プログラミング

　プログラミングとはコンピュータに与える命令を記述することです。ハッキン
グの技術にはなくてはならない知識であり、コンピュータを知るうえでも重要な
分野です。プログラミングというと難しそうなイメージがあるかもしれませんが、
概念自体は普段の人間生活で自然に活用しているものです。例えばカップラーメ
ンを作る場合を考えてください。おそらくほとんどの人は次の手順に従ってカッ
プラーメンを作ると思います。

1：カップラーメンのふたを取りはずす

2：お湯を用意する

3：お湯をカップラーメンに注ぐ

4：3分立ったかどうかを判断する

5：もし3分たってなかったならしばらく待つ

　このような手順はれっきとしたプログラムの考え方です。プログラムの基礎と
題して解説している、後述の技術を、例としてカップラーメン作成など、身近な
物事と対比して考えてもらえれば、いかにプログラミングが身近なものであるか
がご理解いただけると思います。


■0x03.) アルゴリズムとデータ

　プログラムは大きく分けて、2つの部分からなっています。ひとつはデータをど
のような手順で加工し、問題を解くかを記述した部分です。これはアルゴリズム
（algorithm）と呼ばれます。もうひとつは加工対象となるデータを記述した部分
です。これらの概念も生活のなかでは非常に一般的なものです。例えば私たちは
「りんごを食べる」という行為を行います。この例の場合、「食べる」という行
為がアルゴリズムであり「りんごを」という部分がアルゴリズムの対象となるデ
ータです。先述のカップラーメンの例で考えるなら、「カップラーメン」や「お
湯」がデータであり、「注ぎ、観測し、待つ」という一連のカップラーメン作成
行為がアルゴリズムであると言えます。

　アルゴリズムの語源ははっきりとしてはいませんが、9世紀のバグダットで活躍
した数学者アル・フワーリズミー（al-Khwarizmi）が語源だと考えられています。
やはり数学者の名前が語源になっているだけあり、多くは数学的な問題解決手順
がアルゴリズムと呼ばれます。


■0x04.) コンピュータとプログラムの関係

　私たちは日本語や英語など、様々な言語を理解できます。コンピュータも言語
を理解することはできますが、コンピュータが理解できる言語は私たちが普段使
っている言語とは大きく異なります。
　現在のコンピュータは皆さんがご存知のように2進数、つまり0か1しか理解でき
ません。電気的に強い電流が流れたら0、弱い電流が流れた場合は1といったよう
に、2つの状態しか理解できません。当然ですが、人間が理解できる言語で命令を
与えてもコンピュータは理解できません。コンピュータが理解できるのは2つの値
だけですので、コンピュータに命令を与える時はこの0と1の組み合わせで命令を
記述します。これは機械語と呼ばれます。次に機械語の例を挙げます。

-----
1011000000000001
1011100001001100
-----

　上記のような0と1の羅列が延々続きます。これをみて理解しやすいと思う方は
稀でしょう。機械語はコンピュータが理解できる唯一の言語ではありますが、私
たちは機械語以外にも多くの言語を理解できます。その中にはもっと理解しやす
い言語がたくさんありますので、機械語は非常にわかりにくいように感じます。
　昔はこの0と1だけで構成された機械語を直接人間が記述し、コンピュータに命
令を与えていましたが、これは大変非効率です。コンピュータが登場した初期の
ころはトルグ式スイッチ（http://www.otax.co.jp/item/if/m.html）で0と1を打
ち込んでいましたが、2進数は桁上がりが頻発するため桁数が長くなり、結果的に
大変な労力をようすることになります。そこで桁数を少なくするため2進数を16進
数で表す方法がとられました。16進数で上記の例を表すと次のようになります。

-----
B0 01
B8 4C
-----

　2進数のときよりもスマートに記述できます。しかし、16進数で表現しても見た
目が簡単になるだけで2進数と同じです。結局はCPUのために符号化された記号を
人間が読み取るというところに無理があるのです。次に登場したのが、2進数の機
械語に1対1で対応したアルファベットでプログラムを記述し、それをプログラミ
ング後に機械語に変換する方法です。このアルファベットで記述する言語をアセ
ンブリ言語といいます。アセンブリ言語で上記の機械語を記述すると次のように
なります。

-----
MOV AL, 0x01
MOV CL, 0x4C
-----

　MOVはMobileの略で「移動」という意味を持ちます。ALはレジスタと呼ばれる一
時的な記憶領域です。0x01は16進数で表された数字です。MOVの意味が移動なので、
機械語を知らなくても「ALに0x01を移動させる」という意味が読み取れると思い
ます。
　アセンブリ言語は機械語に比べれば人が理解しやすい言語といえます。機械語
と1対1で対応しているため機械語への変換は容易に実現できますが、簡単な処理
でもCPUが用意している複数の命令を組み合わせて実現しなければなりません。
「ALの値を3倍しBLに代入する」という処理はアセンブリ言語では次のようになり
ます。

-----
ADD AL, AL
ADD AL, AL
MOV BL, AL
-----

　簡単な処理であるにもかかわらず3命令も使用します。私たちの感覚では「BL 
= AL * 3」のように記述したいと思うでしょう。そこで現在では「BL = AL * 3」
のように、人間がより簡単に理解できる言語でプログラムを記述し、それを機械
語に変換するソフトウェアに入力して機械語を出力します。このソフトウェアの
ことをコンパイラといいます。

+------------------------+                          +--------------------+
| 人間が理解できる言語で |----------[変換]--------→| 機械語に変換される |
| プログラムを記述       |                          |                    |
+------------------------+                          +--------------------+

　英語ができない日本人がアメリカで本を出版したいと思ったとき、英語を学ん
でから英語で本を書くのは非効率です。普通は本の内容を日本語で記述し、それ
を翻訳者に頼んで英語に翻訳してもらい、それを出版します。下図を参照しても
らいますと、コンピュータのプログラムを記述する場合となんら変わりないこと
がわかると思います。

+------------------------+                          +--------------------+
| 日本語で本の内容を記述 |----------[翻訳]--------→| 英語に翻訳される   |
|                        |                          |                    |
+------------------------+                          +--------------------+

　翻訳者は両方の言語に堪能でなければなりませんが、やはり母国語の方がうま
く扱えますし、後から覚えた言葉は母国語より不得意な場合が多いです。コンパ
イラも同じで、両方の言葉を完璧に使えるわけではありません。コンパイラもソ
フトウェアですので、機械語を母国語とします。そしてコンパイラが理解できる
言語も比較的母国語に近い、コンピュータ専用の言語だけです。
　機械の理解できる機械語に近い言語は低級言語と呼ばれ、人が理解しやすい言
語は高級言語と呼ばれます。低級・高級とは性能の良い悪いではなく、より詳し
いところまでプログラマが制御できるかどうかです。低級言語の代表例はアセン
ブリ言語であり、高級言語として有名なものにC言語やBASICなどがあります。


■0x05.) コンパイルの手順

　コンパイル（Compile）とはコンパイラによって行われる、先述の例で挙げたよ
うに翻訳のような行為です。人間基準に書かれた命令を機械基準で書かれた命令
へ変換することです。人間基準に書かれた命令のことをソースコードと呼びます。
　C言語のコンパイルは次のような手順を経て完了します。コンパイルとは下図に
あるようにソースコードを変換し、オブジェクトコードを生成する行為までを指
します。オブジェクトコードはソースコードを機械語に変換しただけのもので、
これだけではまだ実行はできません。実行可能な形式にするにはコンパイルの他
にリンクと言う作業が必要になります。リンク作業はリンカという独立したプロ
グラムによって行われますが、多くのコンパイラはリンカも含められて配布され
ているため、コンパイルと同時にリンクも行います。ですので実行が可能なロー
ドモジュールの生成が可能です。

+------------+
|ソースコード|
+-----+------+
      |
      | ←プリプロセス---[文字列の調整]
      |
+--------------------+
|調整済みソースコード|
+-----+--------------+        +---[字句解析]
      |                       |      ↓
      | ←コンパイル----------+---[構文解析]
      |                       |      ↓
+-----+------------+          +---[意味解析]
|オブジェクトコード|          |      ↓
+-----+------------+          +---[最適化]
      |
      | ←リンク------[他のオブジェクトコード等の結合]
      |
+-----+----------+
|ロードモジュール|
+----------------+


●字句解析

　ソースコードを字句ごとに区切り、使われている字句を明らかにします。例え
ば、「a+b-cd」という部分は「a」,「+」,「b」,「-」,「cd」という5つの字句に
分解されます。コンパイラの用語では、この基本単位をトークン（token）と呼び
ます。C言語のソースコードで具体的な例をみてみましょう。次のようなソースコ
ードを字句解析します。

-----
while(count <= x){ count++; }
-----

　これはC言語のソースコードの一部です。ソースコードの意味はわからなくても
結構です。字句解析の結果、次のように11個のトークンに分けられます。

・while
・(
・count
・<=
・x
・)
・{
・count
・++
・;
・}

　ソースコードにおかしな字句が含まれているなどのエラーはここで検出されま
す。

●構文解析

　文法をチェックします。字句解析で切り出したトークンを、構文規則に基づい
て導出木に構成する過程が構文解析です。文法エラーはここで検出されます。

●意味解析

　構文のチェックでは誤りかどうか判断できない部分をチェックします。例えば
「c = a + b;」という命令は構文はエラーになりませんが、aがchar型でbがfloa
t型であった場合、演算対象の型がそれぞれ違いますからエラーになります。意味
としてみた場合に間違えているかどうかで判断します。

●最適化

　不要な命令の省略やより高速な命令への置き換えなどを行います。簡単な例で
は「5+5+5+5」という4命令を「5*4」という1命令に置き換えるような処理のこと
です。近年のコンパイラは非常に高性能な最適化ルーチンを搭載しており、並み
の人間が最適化を行うよりも高度な最適化を行える場合もあるようです。


■0x06.) C言語

　C言語は1972年にAT&Tベル研究所のカーニハン（B.W.Kernighan）とリッチー（
D.M.Richie）によって開発されたプログラミング言語です。非常に汎用的な言語
で、組み込みシステムからOSの記述まで様々なところで利用されています。機械
語に比べて人が理解しやすい形式で記述できるため、開発効率は高いですがコン
ピュータはC言語を直接理解することはできません。先述のようにコンパイラを通
して機械語に変換します。
　現在では、C言語はプログラミング言語で最も有名な言語であり、ハッカーが熟
知しておくべき言語のひとつとなっています。Wizard Bibleの読者の方は私より
よほどC言語に熟達していると思われますので、ここではC言語の特徴や知ってお
くべき最低限の解説を行い、細かなC言語の仕様については割愛します。

●C言語の特徴

　C言語は記述方法が簡単で、表現に制約が少ないという点が最も特徴的といえる
でしょう。システム記述用という背景から移植性にも優れ、構造化プログラミン
グがしやすい点も大きな特徴です。その他にも演算子・データ構造・制御構造を
豊富に備えており、高級言語でありながら低水準言語に近いビット操作も行えま
す。
　C言語は多くの技術者が自分たちが書きやすいように仕様を変えてきたため、方
言のような派生した書き方が無数に存在しました。これは表現の多様化という見
解からは利点となりますが、はじめてC言語にふれる人にとっては混乱を招く原因
になりかねません。現在では1989年に機能が改良・拡張された標準規格がANSIに
よって制定され、ANSI-Cとして広まっています。ここでもC言語の規格はANSI-Cに
沿った文法で解説します。
　一般的にC言語にはエラーを自動で処理する機能はありません。エラーが発生し
た場合の処理はプログラマーが自分で考え、自分で実装しなければなりません。

●サンプルコード

　実際にC言語で簡単なプログラムを書いてみましょう。次に解説するプログラム
は初めて作成するC言語プログラムの定番です。テキストエディタで以下のコード
を打ち込んでください。改行やスペースの挿入は適当にしてもらって結構ですが、
改行は単語の途中等ではしないようにしてください。先の説明で出てきた言葉を
使うと、トークンの途中で改行を入れることはできません。また、ソースコード
中には全角文字を含めることはできません。全角文字を使うときは「"」で囲むか、
コメントアウトしなければなりません。
　入力できたらhello.cという名前で保存してください。

-----　hello.c
/**********************************/
/* 2006-12-13 Defolos hello.c     */
/**********************************/
#include <stdio.h>

int main (){

   printf("Hello hackers!\n");

   return 0;
}
-----

　このレポートではLinux上での作業を想定しています。Linuxには標準でC言語の
コンパイラであるgccがインストールされていますので、コンパイルするには次の
ようにコマンドを入力します。

-----
defolos@glazheim:~$ gcc -o hello.exe hello.c
-----

　gccのoオプションはコンパイルによって生成される実行形式のファイルの名前
を変更するオプションです。oオプションを省略するとコンパイル後の実行形式フ
ァイル名は指定できず、自動的にa.outあるいはa.exeという名前になります。こ
こではhello.exeという名前に変更しています。最後に指定されているhello.cは
元となるソースコードを指定します。
　コンパイルとはソースコードを翻訳し、オブジェクトコードを生成する行為の
ことをいいますが、gccは自動的にリンクまで行いますので実行可能なファイルが
生成されます。コンパイルによって生成された実行可能ファイルを実行すると次
のようになります。

-----
defolos@glazheim:~$ ./hello.exe
Hello hackers!
-----

　実行すると画面に「Hello hackers!」と表示されました。上記のサンプルプロ
グラムは「Hello hackers!」と表示するプログラムでしたので、予期した動作で
す。プログラム名の先頭に「./」という記号がついていますが、これはカレント
ディレクトリを意味する記号です。Linuxはセキュリティを考慮した結果、システ
ムに登録されていないプログラムは全てディレクトリを指定して実行する必要が
あります。

●プリプロセッサについて

　「/* Comment */：は、「/*」と「*/」で囲まれた部分をコメントとします。つ
まり、注釈として人が読むための部分で、コンピュータには見えない部分です。
同じように// Comment のように「//」より右から改行までをコメントとしますが、
こちらはC++で定義されているコメントですからC言語環境ではエラーになること
もあります。コメントは入れ子にすることはできません。例えば次のようなコメ
ントの書き方はエラーになります。

-----
/*　コメント1
	/*
	コメント2
	*/
*/
-----

　コメント2が入れ子になっています。コンパイラによっては入れ子のコメントを
解釈するコンパイラも存在しますが、コメントの入れ子は控えるように気をつけ
てください。プログラミングを行っていると、デバッグのときなど上記のように
コメントを含むソースコードの一部を全部無視したい場合がでてきます。このよ
うな場合はコメントを入れ子にするかわりに次のようにすることでコンパイル時
にソースコードの一部を無視することができます。

-----
#ifdef DEBUG
	/*
	コメント2
	*/
#endif
-----

　コメントを無視して考えると、上記のサンプルコードは次のようになります。
今後はこのコードを用いて解説します。

-----
#include <stdio.h>

int main (){

   printf("Hello hackers!\n");

   return 0;
}
-----

　C言語ではコンパイルの過程で、最もはじめにプリプロセッサにソースコードを
渡します。プリプロセッサは渡されたソースコードの文字列調整を行います。具
体的にはコメントの削除、改行のスペースへの置き換え、複数のスペースをひと
つにまとめる、文字列を定義したほかの文字列に置き換えるなどの前処理を行い
ます。プリプロセッサで文字列調整が行われたソースはコンパイラに戻され、コ
ンパイルが続行されます。プリプロセッサもコンパイラとリンカのように独立し
たプログラムですが、gccはプリプロセッサも自動的に通してコンパイルを行いま
す。
　プリプロセッサで特別に処理される命令は先頭に「#」がついたものです。サン
プルコードの1行目には「#include <stdio.h>」という行があります。includeと
いう命令はプリプロセッサでは「ファイルの埋め込み」を意味する命令です。つ
まり、「#include <stdio.h>」という命令は「この場所にstdio.hというファイル
の内容を展開する」という意味になります。stdio.hは表示・読み込み処理命令を
扱うときに必要となるファイルで、画面に文字を表示させるときやキーボードか
ら入力を読み込むときに必要になります。後述するprintfという命令は画面に文
字を表示する命令ですので、このstdio.hが必要です。
　プリプロセッサは改行をスペースに置き換えてしまいますので、1行の終わりは
「;」で識別することになります。そのため、命令の後に「;」を忘れますとコン
パイル時にエラーが発生します。

●関数

　関数とは、ある値を入力すると加工して違う値を出力するもののことです。た
とえば、りんごを入れると中で何やら加工してアップルパイを出してくれるよう
な箱を思い浮かべてください。アップルパイの作り方を知らなくても、材料を入
れればアップルパイが出てきます。このような仕組みのことを関数と呼びます。
　関数は数学などでよく出てきますが、プログラムの関数と数学の関数はまった
く別のものです。ただ動作が似ているのでこのような仕組みのことを数学用語で
あった「関数」と呼んでいるだけです。ただし、数学用語を用いているだけあっ
て、りんごの例を数学的に考えることができます。りんごをx、アップルパイをy
とおきます。アップルパイ製造ボックスをf()で表現するなら、f(x) = yと表すこ
とができます。数学の教科書などでよく出てくるような形となりましたが、これ
はアップルパイ製造ボックスの中にx（りんご）を入力「f(x)」するとy（アップ
ルパイ）が出力されるということを表しています。

         x：りんご=入力値
         ↓
+------------------+
|        f()       |：アップルパイ製造ボックス=関数
+------------------+
         ↓
         y：アップルパイ=出力値

　サンプルコードの5行目には「printf ("Hello hackers!\n")」という命令があ
ります。先述の説明ではこれは文字を画面に表示する命令だと解説しましたが、
それは正確にいえば誤りです。本来画面への出力というのはよりハードウェアに
近い処理が必要となるため、1行やそこらの命令では到底記述できません。
　実は「printf("Hello hackers!\n")」というのは関数です。"Hello hackers!\
n"という文字列をprintf()という関数に入力値として入力し、出力値は画面への
表示という形で返されます。画面へ文字を出力する仕組みを知らなくても、材料
を入れれば結果が出てきます。

　仕組みを知らなくても結果が出てくるということには大きな利点があります。
画面に文字を表示するという処理は非常に複雑な仕組みが関係して文字を表示し
ています（実際には私は仕組みを知りません）。これをブラックボックスとして、
表示したい文字を渡せば画面に表示してくれるように隠蔽すれば、すべてのプロ
グラマーがハードウェアに近い複雑な処理を知る必要がなくなり開発効率が向上
します。

   "Hello hackers!\n"：入力値
         ↓
+------------------+
|      printf()    |：関数（内部の仕組みは知らなくてよい）
+------------------+
         ↓
     Hello hackers!：出力値

　関数は処理を小分けするのにも便利です。世の中の仕事は、どんな大きな仕事
であっても小さな仕事の集まりです。小さな仕事を細かく見すぎると全体を把握
できなくなりますが、大まかな内容に分けてトップダウン的に仕事を考えると全
体を見失うことなく大きな仕事を小分けできます。
　例えば、A社に自社で販売している商品の販売契約をとるという仕事があったと
します。これ自体は非常に大きな仕事です。しかし、よく見るとこれはいくつか
の仕事の集まりで構成されています。

+------------契約をとる-----------------+
|                                       |
|　・上司に相談する                     |
|　・A社にアポイントメントをとる        |
|　・プレゼンテーションの資料作成       |
|　・契約書の準備                       |
|　・A社へ訪問                          |
|　・プレゼンテーションを行う           |
|　・契約                               |
|                                       |
+------------[仕事達成]-----------------+

　どうやってA社にアポイントメントをとるかといった細かい方法はこの時点では
わかりません。しかし、全体としてどういった流れで仕事を行えばよいのかを把
握することができます。小分けした仕事を関数として扱えば、細かい方法を考え
ずに、全体の仕事を遂行するために必要なサブルーチン（小分けした仕事）がど
ういうものか把握できます。さらにA社にアポイントメントをとるというサブルー
チンを見ていくと次のようなサブルーチンが必要になります。

+------A社にアポイントメントをとる------+
|                                       |
|　・A社の電話番号を調べる              |
|　・電話をかける                       |
|　・用件を伝える                       |
|　・場所と日時を決める                 |
|　・電話を切る                         |
|                                       |
+------------[仕事達成]-----------------+

　このままさらに細部まで小分けしていけばA社とアポイントメントをとる方法は
明らかになります。関数の概念を用いれば、大きな仕事であっても全体を見逃す
ことなく細部の処理を考えることができます。
　プログラミングにおいて関数化は非常に重要な概念であり、効率的に開発する
のには必須の考え方です。通常ならひとつの関数は内部でさらに細かい仕事に分
けられるため60行以内に収まります。

●ポインタ

　ポインタはC言語で特につまずきやすい鬼門として有名です。
　変数というのはプログラムで利用するデータを格納しておく箱のようなもので
す。プログラム内で宣言し、利用している変数は全てコンピュータ上のどこか（
正解はメモリ内のどこか）に配置されています。その場所自体のことをアドレス
といいます。ここで駅のロッカーを考えてください。ちょうどロッカーは箱状に
なっていて内部に荷物を格納しますので、変数のようなものだと考えることがで
きます。ロッカーには1番から順番にロッカー番号が振られていて、その番号があ
るおかげで私たちはどのロッカーを借りたのか探すことができます。

+--------+--------+--------+--------+--------+--------+
| 1      | 2      | 3      | 4      | 5      | 6      |
|        |        |        |        |        |        |
+--------+--------+--------+--------+--------+--------+
| 7      | 8      | 9      | 10     | 11     | 12     |
|        |        |        |        |        |        |
+--------+--------+--------+--------+--------+--------+

　7番ロッカーを借りたとしますと、私たちは7番という数値だけ覚えておけばロ
ッカー内の荷物を出し入れすることができます。ロッカーの例ではロッカー番号
がアドレスという概念になります。

　ポインタはアドレスを格納するための変数です。ポインタを解説するに当たり、
変数の宣言時にどのようにメモリ（ロッカーと置き換えてもらって結構です）に
変数のための領域が確保されるのかを見てみましょう。例えば、変数int test =
 30はメモリ上に次のように確保されます。

番地  [メモリ]
1   +---------+
    |         |
2   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |   30    |←test
102 +---------+
    !         !

　この例ではメモリ101番地をtestと名づけ、その番地に30を格納しています。t
estと名づけることでアドレス番号を指定しなくても、testという文字列で指定で
きるようになったわけです。このように番地に別名をつけるのはアセンブラでラ
ベルにあたるものだと思います。ポインタの部分がわかりにくいと感じましたら、
先にアセンブリの解説を読んだうえでもう一度ポインタの解説をお読みください。
　この例で変数testというものは101番地であると定義されています。このtestと
いうラベルのついた番地を他の変数に格納する仕組みをポインタといいます。ポ
インタも変数の一種ですから当然メモリの番地の一画に確保されているわけです
が、この番地は特別な番地に確保されます。
　ポインタの宣言、利用は次のように行います。

-----
int main (void){

    int test = 0;     /* 変数testの宣言 */
    int *pointer;     /* ポインタの宣言 */
    int temp = 0;     /* 103番地に確保されるものとする */

    pointer = &test;  /* testのアドレスを格納 */
    *pointer = 2600;     /* 解説は後述 */
    temp = *pointer + 1; /* 解説は後述 */

return 0;
}
-----

　変数の前に*をつけることでポインタだと宣言します。pointer = &test;でpoi
nterにtestのアドレスを格納します。

番地  [メモリ]
1   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |   0     |←test
102 +---------+
    |         |
103 +---------+
    |   0     |←temp
    +---------+
    !         !

900 .         .
    |         |
901 +---------+
    |  101    |←pointer（内容は変数testのアドレス）
    +---------+

　ポインタを使ったデータのアクセスには*をつけます。*pointerで、pointerに
格納されているアドレスの中身を表します。それ故に*pointer = 2600;で「poin
terに格納されているアドレスの中身を2600で上書きする」という命令になります。

番地  [メモリ]
1   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |  2600   |←test
102 +---------+
    |         |
103 +---------+
    |   0     |←temp
    +---------+
    !         !

900 .         .
    |         |
901 +---------+
    |  101    |←pointer (内容は変数testのアドレス)
    +---------+

　temp = *pointer + 1;は、pointerに格納されている値（ここではtestのアドレ
スである101）に1を足すという命令になります。それによってtempに格納される
値は102になります。

番地  [メモリ]
1   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |  2600   |←test
102 +---------+
    |         |
103 +---------+
    |   102   |←temp
    +---------+
    !         !

900 .         .
    |         |
901 +---------+
    |  101    |←pointer (内容は変数testのアドレス)
    +---------+

○参考

・初心者のためのポイント学習C言語（http://www9.plala.or.jp/sgwr-t/）
・Wizard Bible vol.22（http://wizardbible.org/22/22.txt）

　ポインタで特に理解しておくべき点は、プログラム中のデータは変数に格納さ
れ、その変数はメモリ上のどこかに必ず配置されるという点、メモリは区画分け
されてデータを格納しており、アドレスを用いてそのデータにアクセスできると
いう点の2点です。これらの知識はハードウェアの基礎を理解するのに役立ち、ア
センブリやほかの高級言語の理解を助けます。また、ハッキング手法を理解する
大前提となります。


■0x07.) アセンブリ言語

　アセンブリ言語は先述のように機械語命令と一対一で対応した低級言語です。
機械語の代わりにニモニックと呼ばれるアルファベット形式の命令を使ってプロ
グラミングします。機械語と一対一で命令が対応しているので、機械語と同レベ
ルのきめの細かいプログラミングが可能であり、なおかつ機械語よりも簡単にプ
ログラミングを行うことができます。
　C言語などの高級言語の出現、ハードウェア性能の飛躍によってアセンブリ言語
は過去の産物ととられがちになりましたが、プログラムは全て一度アセンブリに
変換されたうえで機械語に置き換えられます。プログラムを学んでいくうえでは
決して無視できない言語です。私はアセンブリ言語は特にハッカーがC言語以上に
精通しておくべき言語だと考えています。

●アセンブリ言語の種類

　アセンブリ言語は記述の仕方によっていくつかの種類に分けられます。現在主
に使われている種類を次に列挙します。

○MASM

　MASM（Microsoft Macro Assembler）はマイクロソフト社製のアセンブリ言語で
す。元はインテル社のASM86というアセンブラを起源とし、インテル社のASM（ア
センブラ）と互換性があるアセンブラとして作られました。Windows環境下でプロ
グラミングができ、記述方法も簡単です。

○NASM

　NASM（Netwide Assembler）はケンブリッジ大学のSimon Tathamによって開発さ
れたMASMと互換性のある8086CPU用のアセンブリ言語です。Windows以外にもUNIX
で利用できます。

○GAS

　GAS（GNU Assembler）はDean ElsnerおよびJay Fenlasonが作成したアセンブリ
言語で、x86アーキテクチャで動作します。GNUが開発を行っており、gccでアセン
ブルできます。

○CASL

　基本情報技術者試験で出題されるプログラミング言語であり、COMETと呼ばれる
仮想コンピュータで動作するアセンブリ言語です。学習用言語としての性質が強
く、エミュレータを除いて実際のコンピュータ上で動くプログラムを作成するこ
とはできません。

　このレポートではGASを使って解説します。理由はgccでコンパイルが可能であ
り、プログラマーがよくお世話になるデバッガGDBがリエンジニアリングで吐き出
すコードがGASだからです。

●サンプルコード

　次にGASアセンブリのサンプルコードを示します。このプログラムは「Hello W
orld」を画面に表示するプログラムです。

-----　sample.s
.data
	msg:	.string	"hello world\n"
	len:	12

.text
.global main
main:
	movl $4, %eax
	movl $1, %ebx
	movl $msg, %ecx
	movl $len, %edx
	int  $0x80
	ret
-----

　アセンブリでは変数は「.data」と書かれた部分から「.text」と書かれた部分
までの間で宣言します。正確には変数ではなくラベルという概念です。msgという
変数はASCII文字列でhello world\nという内容を格納した変数と扱えます。「.d
ata」と書かれた部分はデータセグメントと呼ばれるデータ格納用のメモリ領域に
確保されます。セグメントの詳細については次回解説しますので、ここでは変数
は「.data」から「.text」までの間で宣言しなければならないと覚えておいてく
ださい。
　ラベルはメモリ番号に別名をつけることです。ロッカーの例では、7番ロッカー
と呼ぶかわりに「鈴木のロッカー」と呼びかえるようなものです。別名をつける
ことで、番号で呼ぶよりも何のためのロッカーなのかが明確になりました。msgの
宣言でメモリが次のようになります。

番地  [メモリ]
100 .         .
    |         |
101 +---------+
    |  103    |←msgと別名をつけた
102 +---------+
    |         |
103 +---------+
    |   H     |←文字列の先頭アドレス
104 +---------+
    |   e     |
105 +---------+
    !   l     !

　プログラムのコード自体は「main:」以降に記述します。アセンブリのプログラ
ミングではOSが提供するシステムコールを利用して様々な処理を行います。画面
に文字を表示する処理やファイルの内容を読み込むなどの処理はシステムコール
を介して行われます。システムコールとは関数のようなもので、OSが提供する機
能をユーザが利用しやすいようなインタフェースとしたものです。たとえば、OS
が文字を表示する仕組みはわからなくとも定められた値を設定してシステムコー
ルを呼べばOSが文字を表示してくれます。システムコールにはそれぞれ番号が割
り振られており、文字を出力するwriteシステムコールは4番になっています。Li
nuxのシステムコール番号の対応表は/usr/src/linux-2.4.18/include/asm/unist
d.hに保存されています。次にunistd.hの一部を挙げます。

-----　/usr/src/linux-2.4.18/include/asm/unistd.h
#ifndef _ASM_I386_UNISTD_H_
#define _ASM_I386_UNISTD_H_

/*
 * This file contains the system call numbers.
 */

#define __NR_exit                 1
#define __NR_fork                 2
#define __NR_read                 3
#define __NR_write                4
#define __NR_open                 5
#define __NR_close                6
#define __NR_waitpid              7
#define __NR_creat                8
#define __NR_link                 9
#define __NR_unlink              10
#define __NR_execve              11
#define __NR_chdir               12
…（略）…
-----

　システムコールを利用するには、eaxに利用したいシステムコール番号を指定し、
ebxにそのシステムコールが要求する第1引数を、ecxに第2引数を設定し、その後
int $0x80を実行して割り込みを発生させます。eaxやebxはレジスタと呼ばれる高
速な記憶領域をあらわしていますが、変数のようなものだと思っていただければ
結構です。

+-----------------------+---------------+---------------+---------------+
|  eax			|  ebx		|  ecx		|  edx		|
+-----------------------+---------------+---------------+---------------+
|  システムコール番号	|  第1引数	|  第2引数	|  第3引数	|
+-----------------------+---------------+---------------+---------------+

　Manpage（http://www.linux.or.jp/JM/html/LDP_man-pages/man2/write.2.html）
でwriteシステムコールを検索すると、書式は次のようになっています。

-----
write(int fd, const void *buf, size_t count)
-----

　上記より第1引数にはファイルディスクリプタを指定し、第2引数には文字列が
格納されているアドレスの先頭、第3引数は出力する文字の数であることがわかり
ます。標準出力はファイルディスクリプタ1番と定義されていますので、次のよう
に設定して割り込みを発生させればよいことになります。msgやlenは自動的にア
ドレスが渡されることになります。msgのアドレスには文字列が格納されている先
頭アドレスが格納されています。

+-------+-------+-------+-------+
|  eax	|  ebx	|  ecx	|  edx	|
+-------+-------+-------+-------+
|  4	|  1	|  msg	|  len	|
+-------+-------+-------+-------+

　割り込みが発生した後はOSが提供するシステムコールに処理が移行し、画面に
文字が表示されます。システムコールは関数であり、このとき文字列のアドレス
や出力する文字の長さなどはスタックを用いて受け渡されます（スタックの詳細
については次回を参照）。割り込みはレジスタに必要な引数がセットできたこと
をOSに伝え、システムコールへ処理を移行させるための合図です。
　今後のアセンブリプログラミングにおいてもシステムコールを多用して必要な
処理を行っていくことになります。

●命令

　ソースコード中の「movl $4, %eax」という命令を例にとって解説します。mov
lの部分が命令で「〜を〜に移動させる」という意味を持ち、$4および%eaxが命令
に関係するデータです。$4は4という数字自体を現しており、%eaxはeaxレジスタ
を表しています。「$」は数字や文字列を表し、「%」はレジスタを表す記号と思
ってもらえれば結構です。
　主に命令の表記の仕方には2つの方法があります。ひとつはIntel形式と呼ばれ
る記述方法で、もうひとつはAT&T形式と呼ばれる記述方法です。前者はMASMやNA
SMで採用されている記述方式で、後者はGASに採用されています。この2つの方式
の違いはごく簡単なもので、命令の後に続けるデータの順番が逆になるだけです。
例えば「mov a b」のような命令は、Intel形式では「aにbを代入」と解釈されま
すが、AT&T形式では「aをbに代入」と解釈されます。これだけの違いであり、ア
センブリ言語の種類によってどちらか一方の固定ですので、どちらの記述方法を
採用しているか知っていれば、特に難しいものではありません。
　ここではGASを使っていますので、AT&T形式で解釈します。つまり、「eaxレジ
スタに4を代入する」という命令であることがわかります。同様に、「movl $1, 
%ebx」は「ebxレジスタに1を代入する」という命令です。少し毛色が違うのは「
movl $msg, %ecx」という命令です。$msgというのは数字ではなく、.dataのとこ
ろで定義したmsgという配列（正確に言えばアドレス）に宣言された文字列を表し
ています。つまり、「ebxレジスタにmsg配列の先頭アドレスを代入する」という
命令と等価であるといえます。
　次の「int  $0x80」のint命令（interrupt）とは割り込みを発生させる命令で
す。変数をここで呼び出すことをOSに通知するシグナルのようなもので、0x80番
シグナルは先述のシステムコール割り込みの発生を表しています。ここでシステ
ムコール番号4番のwriteシステムコールが呼ばれることになり、画面の文字列を
表示します。
　最後の「ret」は、ここでプログラムが終わりであることを表す特殊な命令です。
基本的にはプログラムの終わりにこの命令を配置することになります。

　少し駆け足でサンプルコードの実行される様子を見てきましたが、ここで理解
しておいてほしいところは実際のアセンブリプログラミングの雰囲気と次の2点で
す。

・アセンブリ言語は単純な命令しか持ち合わせていない点
・高度な処理はシステムコールを利用する点

　アセンブリプログラミングの知識は第3回以降の解説で必ず使います。具体的に
はシェルコードの開発でアセンブリプログラミングの応用技術を使います。この
解説では文法については触れていませんので、よく分からなかったという方や文
法を知らないという方は他の書籍を参考に知識の補充をお願いします。私のちゃ
ちな解説よりもよほど洗練された解説をされている書籍は多いと思いますので、
文法の解説は割愛します。


■0x08.) 参考文献

・「Hacking：美しき策謀」　Jon Erickson著　村上 雅章訳　ISBN4-87311-230-3
　http://www.oreilly.co.jp/books/4873112303/

・「ハッキング対策マニュアル」ISBN4-7973-2145-8

・「セキュリティ夜話　バッファオーバーフロー（BO)系列　（1）Aleph Oneによるスタック破壊の楽しみと恩恵」
　http://www.asahi-net.or.jp/~vp5m-snd/sec/tech/Phrack49-14.html

・オータックス株式会社
　http://www.otax.co.jp/item/if/m.html

・初心者のためのポイント学習C言語
　http://www9.plala.or.jp/sgwr-t/


■0x09.) さいごに

　今回は前回に引き続き、前提知識の確認を行いました。ハッキングにおいて特
に本質となるプログラミングを重点にC言語とアセンブリ言語について解説をしま
した。次回はハードウェアについての基礎部分を解説し、前提知識の確認を終え
ます。まだ、いかにもハッキングといった内容の解説は出てきませんが、前提と
なる知識を詰めることがハッキングの理解を助けるのだと考えています。
　それでは、またお会いしましょう。



