x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第8章: カスタムリソース＋ローダー＝パッカー ---

著者：Kenji Aiko

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　パッカー（packer）とは、実行ファイルを実行できる形式のまま圧縮（暗号化
）するツールであり、UPX、FSG、tElockなど様々なものがあります。しかし、種
類は違えどパッカーの基本的動作原理はほとんど同じで、「ターゲットとなる実
行ファイルを圧縮（or暗号化）して、プログラムの先頭に展開（or復号化）ルー
チンを付加する」だけです。こうすることにより、プログラムが実行されたら一
番最初に展開ルーチンが実行され、本来の実行ファイルのデータをメモリ上に復
元してプログラムが処理されることになります。
　それで、今回はそのパッカーを作成してみようというわけですが、パッカー作
成に関して大いなる壁になるのは「実行ファイルの先頭に付加する展開コードは
アセンブリ言語で書かなければならない」という事態です。
　例えば、暗号化処理がビット反転だったなら、アセンブリ言語でも簡単に復号
化処理を書くことができますが、LHAやZIP（DESやRSA）のような一般的な圧縮（
暗号化）アルゴリズムを使用したい場合、付加する展開コードもさぞかし面倒く
さいことになります。まぁCで書いてアセンブラに変換すれば万時解決ですが、そ
れは置いといて。
　というわけで、その辺りを考慮しつつ、さらに一般的なパッカーとは少し違う
「新しいパッカーを考えてみよう」というのが今回のネタです。


■0x02.) 挑戦される方へ

http://ruffnex.oc.to/kenji/crackme/crackme.zip

　もし、解析に挑戦したい方は上記のプログラムをダウンロードしてチャレンジ
してみてください。ここから先のテキストには少なからずヒントになるようなこ
とが書かれてあるのでご注意ください。
　難易度は低く、速ければ10分程度で解くことができますが、一般的なパッカー
と比べると少し特殊な構造なので、ハマってしまうと無駄に時間をとられるかも
しれません。
　もし解けた方は感想などをくださると有難いです。

http://ruffnex.oc.to/kenji/
http://ruffnex.oc.to/kenji/bbs/bbs.cgi


■0x03.) 動作原理

　ここからは実際の動作原理について解説していきます。といってもソースコー
ドなどは出てきませんが、一応プログラミングに関するテキストなので、読み進
めるためにはWindows APIと多少の解析スキルを必要とします。
　また、解析にチャレンジする方は以降のテキストは解析後に読むことをお勧め
します。解析する前に読むと、だいたいの動作が分かってしまうため面白さが半
減すると思うので。あらかじめご了承ください。


■0x04.) カスタムリソース

　実行ファイルのリソース領域には、本来「ダイアログ」、「メニュー」、「ビ
ットマップ」などを入れることができますが、カスタムリソースというカタチで
バイナリデータを挿入することもできます。よって、この領域に実行ファイルの
データをそのまま格納することができるわけです。
　そして、リソース領域は他のプログラムから変更することが可能です。それは
PEフォーマットを直接書き換えるカタチではなく、Windows APIにより提供されて
いる機能を使うことで実現できます。よって、他のプログラムから「リソース領
域の変更と読み込み」を行うことができるわけです。

　リソース領域の変更と読み込みを行うための具体的な関数を次に示します。

 +------------------+-----------------------------
 |読み込み          | 書き込み
 +------------------+-----------------------------
 |・FindResource    |・BeginUpdateResource
 |・SizeofResource  |・UpdateResource
 |・LoadResource    |・EndUpdateResource
 |・LockResource    |
 +------------------+-----------------------------

　これらはWindows 2000以降でしか使用することができません。しかし、PEフォ
ーマットの知識を持たなくても実行ファイルのリソース領域にアクセスすること
ができるため、なかなか面白い使い方ができると思います。


■0x05.) 暗号化の流れ

　仮にターゲットとなる（パッキングを行う）実行ファイルをtarget.exe、パッ
キングを行う側のプログラムをpacking.exeとします。
　まず、最初にpacking.exeはtarget.exeのデータを読み込み、暗号化します。暗
号化アルゴリズムはなんでもよいですが、ここでは分かりやすくビット反転とし
ます。つまり、packing.exeはtarget.exeをビット反転したデータを持つことにな
ります。

（1）packing.exeがデータを取得し暗号化する

　次にpacking.exeは雛形となる実行ファイルを新しく作成します。その実行ファ
イルをmodel.exeとします。
　model.exeは自分自身のリソース領域からデータを読み込み、それをビット反転
して実行するプログラムにします。つまり、あらかじめ「自分自身のリソース領
域からデータを読み込み、ビット反転して実行する」というプログラムが記述し
てあるmodel.exeを作成しておき、このmodel.exeのデータをpacking.exeに入れて
おくというわけです。そしてpacking.exeはmodel.exeをそのままのカタチで出力
することになります。

（2）packing.exeがmodel.exeを作成する

　packing.exeがmodel.exeを作成したら、今度はmodel.exeのリソース領域を変更
します。model.exeは「自分自身のリソース領域からデータを読み込み、ビット反
転して実行する」プログラムですが、まだ現時点ではリソース領域には何も入っ
ていないので、実行してもエラーになるだけです。よって、packing.exeがmodel
.exeのリソース領域にtarget.exeをビット反転したデータを格納します。

（3）packing.exeがmodel.exeのリソース領域に
     target.exeをビット反転したデータを格納する

　これで、model.exeを実行したら自分自身のリソース領域からビット反転された
target.exeのデータを取り出して実行することになり、つまりは、target.exeを
暗号化した実行ファイルがmodel.exeということになります。これでpacking.exe
の処理は終わります。

-----  （プログラムの一連の流れ）

+---------------+             +---------------+
|               |             |               |
|   model.exe   | <---------- |  packer.exe   |
|               |             |               |
+---------------+             |   +-----------+
                              |   | model.exe |
                              +---+-----------+

（1）packer.exeがmodel.exeを作成


+---------------+             +---------------+
|               |             |  target.exe   |
|   model.exe   |             +---------------+
|               |             +---------------+
|  +------------+             |               |
|  | target.exe | <---------- |  packer.exe   |
+--+------------+             |               |
                              |   +-----------+
                              |   | model.exe |
                              +---+-----------+

（2）packer.exeがtarget.exeを読み込み、
     暗号化してmodel.exeへ挿入
（3）model.exeが暗号化後のtarget.exeとなる
（4）model.exeは自分自身のリソース領域（target.exe）を
     読み込み、実行するコードを持っている

-----

　packing.exeの一連の流れとなります。


■0x06.) ローダー（loader）

　model.exeはリソース領域に存在するtarget.exeを取得して実行するわけですか
ら、つまりはローダーの役割を担うことになります。
　もちろん、target.exeのバイナリデータを一度実行ファイルとして出力し、そ
れをCreateProcessを使って起動してもよいですが、それだとアンチリバースエン
ジニアリングという方面から見るとかなり軟弱になってしまうので、やはりメモ
リ上からそのままロードするカタチがよいでしょう。となると、やはり自前でロ
ーダーを用意することになってしまいます。
　model.exeは「自分自身のリソース領域からデータを読み込み、ビット反転して
実行する」というプログラムと書きましたが、この「実行する」という部分はmo
del.exe自身がローダーの役割を果たすという意味に他なりません。しかし、ちゃ
んとしたローダーを作成するのは少し骨が折れるので、今回はインチキなローダ
ーを作成しました。
　まず、何でもよいので適当なプロセスを起動します。まぁcalc.exe（電卓プロ
グラム）などが手頃でしょう。そして、そのプロセスが実行される前に停止させ、
プロセス空間内のデータをすべて、target.exeのデータに置きかえます。そして
その停止を解除させることで、生成されたプロセスはtarget.exeとして動作する
ことになります。本当の意味でのローダーの処理は行っていませんが、結果的に
ローダーと変わらない動作を行うプログラムとなります。
　このような処理をあらかじめmodel.exeに組み込んでおくことで、リソース領域
内のデータを読み込み、実行させることができます。


■0x07.) 解析の手引き

　以上で、概略的な動作原理の解説は終了です。よってここでは少し解析へのヒ
ントを書くことにします（といってもヒントを書くほど難しくないかもしれませ
んが^^;）。
　まず動作原理が一般的なパッカーとは若干異なるため、セオリー通りに解析し
ていっても解けないかもしれません。アセンブリコードを見ても分かるとおり、
コード自体が難読化されているわけではないので、読み進めるのはかなり容易で
ありその動作原理を解読するのにもさほど時間はかかりません。
　そして、原理が分かってしまえばいとも簡単にオリジナルコードにたどり着け
るため、どれほど正確にマシン語を追い、動作原理を掴むかが攻略のポイントに
なると思います。
　解析する方法はいろいろとありますが、OllyDbgだけで十分こと足ります。
　速ければ10分ほどでパスワードを得られると思いますが、一度ハマってしまう
と1、2時間くらいかかってしまう場合もあるかもしれません。しかし、ソースコ
ードは見えてるも同然なので、ポイントさえ抑えれば問題ないでしょう。


■0x08.) さいごに

　さて、いかがだったでしょうか。今回はこれまでと少し変わってテキストベー
スで進めてみました（ついでにタイトルも変わった感じに）。個人的には「ソー
スコードがないと、というか実際に動作しているプログラムがないと本当に実現
可能かどうかを証明できないじゃん！」という考えなのですが、ソースコードば
っかりのテキストも読むのが辛くなったりするかなぁ、と思いまして、今回はこ
ういったテキスト形式にしてみました。
　ただし文章内でソースコードの解説をしていないだけで、crackmeやpackerのソ
ースコードはちゃんと書いているので、テキストが少ない割に結構な労働力だっ
たりしました(^^;。なので出来ればcrackmeやソースコードも併せて楽しんでもら
えたらと思います。
　さて、最後になりましたが、ここまで読んでくれて本当にありがとうございま
す。

　では、また会う日まで...


