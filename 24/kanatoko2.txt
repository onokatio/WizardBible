x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第1章: SQLエラーによるデータ盗掘 ---

著者：金床

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　SQLインジェクションの攻撃を仕掛ける場合、攻撃者はウェブアプリケーション
やデータベースが吐くエラーメッセージを手がかりにすることが多い。エラーメ
ッセージに登場するテーブル名やカラム名などは、データベースの構造を外部か
ら把握するための大きな助けになる。そのため、エラーメッセージはユーザーに
返さないという対策を採るのがセキュリティを保つための基本事項だ。

　しかしエラーメッセージを返さないようにしても、Blind SQL Injectionと呼ば
れるテクニックによってデータベースに対する攻撃が可能である。Blind SQL In
jectionについて知りたい方はGoogleで検索し、Impervaのテキストを読んでみて
欲しい。


■0x02.) SQL文のエラーを判別できる場合

　エラーメッセージが手に入らない場合でも、SQLの実行自体がエラーになったか
どうかは判別できる場合が多い。例えばログイン画面で、SQLがエラーになった場
合には「データベースのエラーが発生しました」と表示され、そうでない場合に
は「ユーザー名かパスワードが間違っています」などと表示されるようなケース
だ。この場合、サブSELECTなどの結果によって故意にSQLエラーを発生させ、デー
タベースに格納されているデータを取り出すことができる。具体的な方法は次の
ようなものだ。

-----
mysql> select * from db where 1 = ( select max( 0 ) from db union all select 0 from db where Host = 'localhost' );
ERROR 1242 (21000): Subquery returns more than 1 row
mysql> select * from db where 1 = ( select max( 0 ) from db union all select 0 from db where Host = 'localho' );
Empty set (0.00 sec)
-----

　この例では、dbテーブルのHostフィールドの値を取り出している。条件式で"l
ocalhost"という文字列を指定した場合にはSQLエラーが発生し、"localho"の場合
にはエラーが発生しないことがわかる。この事から、"localhost"という値を持つ
レコードは存在し、"localho"という値を持つレコードは存在しないことがわかる。
条件式にはLIKE句や各種の文字列系の関数なども使えるので本格的に攻撃する場
合にはバイナリサーチなどの手法を用いることになるが、ここでのポイントは、
「サブSELECTの結果で故意にSQLエラーを発生させることができる」という点だ。
上の例で使われている手法はhsj氏が2003年の某イベントで発表したものである
が、筆者は2年後の2005年になってようやくその意味、つまりウェブアプリケー
ションの挙動でSQLエラーの有無を判別できる場合に使うことのできるテクニッ
クである、ということを理解した。

　さて前回のWizard Bibleで、RDBMS上でUNIONキーワードを使えなくしてしまう、
というちょっと変わり種の防御手法を紹介した。この手法が用いられていれば、
上の方法での攻撃は不可能ということになる。その理由はもちろん、UNIONキーワ
ードが使われているからだ。では、UNIONキーワードが使えない場合に、サブSEL
ECTの結果を故意にエラーにすることはできるだろうか。そう考え、MySQLとPost
greSQLでいろいろと試してみた。ちなみに上の方法は、hsj氏のレポート中ではO
racleに対して有効と書いてあり、また例に挙げたようにMySQLに対しても有効で
あることを確認した。


■0x03.) DoS穴を発見

　リファレンス本を頼りに、目に付いた関数に片っ端から変な変数を与えて実行
してみた。さまざまな条件でデータベースに格納されたデータを取得することを
考えると、SELECT COUNT(*)を使って条件に合うレコードの数を取得し、その結果
がゼロかどうかが分かれば取りあえずは充分である。例えば「パスワードがAで始
まるレコードの数」を取得し、0以外であれば、次は「パスワードがAAで始まるレ
コードの数」を取得するようなイメージだ。これを繰り返せば、原理的にはいつ
かはパスワード全体を取得することができる。ただしこれではもちろん効率が非
常に悪いので、実際に攻撃を行う際には先述したとおり、LIKE句を使ったり、バ
イナリサーチを使ったりすることになる。

　SELECT COUNT(*)の結果は数字だ。数字が0か、あるいは（例えば）1かという違
いによって故意にエラーを発生させるというのは、少々難しそうに思えた。そこ
で、MySQLのゼロ除算の特徴を利用することにした。MySQLではゼロ除算を行うと
その結果がNULLになるのだ。そこで、まず数字の1（もちろん1以外でもよいが）
に対してSELECT COUNT(*)の結果で除算を行う。SELECT COUNT(*)の結果が0の場合
にはNULLを取得し、そうでない場合には数値を取得することができる。本来数値
や文字列を入力すべきところにNULLを入力するとエラーが発生する関数があれば、
このことを利用してデータを探ることができることになる。そして、この考えは
正しかった。str_to_date()関数がまさにそのような挙動を見せたのだ。

　str_to_date関数は2つの引数を必要とし、通常どちらも文字列である。例えば
両方に"1"という文字列を入力すると、次のようにSQLは正常に終了する。

-----
mysql> select str_to_date( '1', '1' );
+-------------------------+
| str_to_date( '1', '1' ) |
+-------------------------+
| 0000-00-00              |
+-------------------------+
1 row in set (0.00 sec)
-----

　しかし2つめの引数をNULLにすると、SQLの実行がエラーとなる。

-----
mysql> select str_to_date( '1', NULL );
ERROR 2013 (HY000): Lost connection to MySQL server during query
-----

　このことを利用すれば、指定した条件にマッチするレコードがテーブルに存在
するかどうかを、次のようにして調べることができることになる。この例では条
件はhogeというテーブルのpasswordというフィールドの値が「Aで始まる」レコー
ドがあるかどうかを調べている。

-----
（略） where 1 = '' or str_to_date( '1', 1/( select count(*) from hoge where password like 'A%' ) );
-----

　さて望みの動作をする関数が見つかった、と喜んでいたのだが、どうもエラー
メッセージが奇妙である。よく読んでみると「Lost connection」、つまりデータ
ベースサーバーとの接続が切れてしまったようだ。通常、SQL文の実行がエラーに
なったからといって、接続を切られるようなことはない。

　どうやら、なんとも面白いことに、MySQLのセキュリティホールを見つけてしま
ったようだ。str_to_date()の2番目の引数にNULLを指定すると、データベースサ
ーバーであるmysqldプロセスが死んでしまうのだ。mysqldは自動で再起動するも
のの、連続してこの方法でstr_to_date()を呼び出せばデータベースサーバーとし
ての役割を妨害することができるだろう。どうやら任意のコードの実行はできな
いようなので、これはDoSに繋がるセキュリティホールと考えられる。

　このバグはこのまま筆者の胸の中だけにしまっておいてもよかったのだが、と
りあえずは報告することにした。MySQLにはきちんとしたバグトラッキングシステ
ムが導入されているようで、このバグは15828というIDを振られ、次のURLで詳細
を確認できる。おそらく次のバージョンでは修正されることだろう。

http://bugs.mysql.com/bug.php?id=15828

　余談となるが、このバグに対して最初に作られたパッチが失敗作だったのは少
し面白かった。

http://lists.mysql.com/commits/1037


■0x04.) バグに頼らない方法

　str_to_date()にNULLを与えてSQL文を異常終了させる方法はあくまでもバグに
頼ったものであり、おそらく次のバージョンでは使えなくなってしまう。そこで
他の関数を色々試してみたのだが、結局NULLを有効に使うことのできる方法は見
つからなかった。そこで、さらに色々な値を引数に与えてエラーが起こる関数を
探したところ、正規表現を使う際に利用できるREGEXPキーワードで故意にエラー
を起こすことができることを発見した。REGEXPキーワードに対して空の文字列を
与えると、次のようにエラーが発生するのだ。

-----
mysql> select 'HOGE' regexp '^HO';
+---------------------+
| 'HOGE' regexp '^HO' |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 'HOGE' regexp '';
ERROR 1139 (42000): Got error 'empty (sub)expression' from regexp
-----

　この現象を利用すると、次のようにしてデータを探ることが可能になる。

-----
（略） where 'a' regexp ( if( ( select count(*) from hoge where password like 'A%' ), '', 1 ) );
-----

　IFキーワードを利用して、該当するデータがある場合には空の文字列を、そう
でない場合には1をREGEXPに与えている。この例では「Aで始まる」レコードがあ
る場合にはSQLエラーが発生し、そうでない場合には正常終了する。

　このようにして、MySQLではUNIONキーワードが禁止されていても、条件によっ
てSQLエラーを発生させる方法でデータの取得が可能であることがわかった。


■0x05.) PostrgeSQLの場合

　同じように、PostgreSQLで故意にエラーを起こす方法がないか探してみた。す
ると、あっけなく見つかった。ゼロ除算である。MySQLの場合には結果がNULLにな
るが、PostgreSQLではSQLエラーが発生するのだ。

-----
template1=# select 1/0;
ERROR:  floating point exception! The last floating point operation either exceeded legal ranges or was a divide by zero
-----

　これを利用し、次の方法でデータを探ることができる。

-----
（略） where 1 = 1/( select count(*) from hoge where password like 'A%' );
-----

　「Aで始まる」レコードがある場合には正常終了し、そうでない場合にはSQLエ
ラーが発生する。


■0x05.) SQLエラーを判別できない場合

　さて、滅多にないことだが、SQLエラーが発生したかどうかすらユーザー画面か
ら判断できない場合はどうだろうか。実はこの場合でも、MySQLではデータを探る
ことができる。benchmark関数を利用して、「時差攻撃」を仕掛けるのだ。

-----
mysql> select if( 0 < ( select count(*) from db where host like 'A%' ), benchmark( 100000, sha1( 'hoge' ) ), 0 );
-----

　dbテーブルのhostフィールドが「Aで始まる」レコードがある場合にはこのSQL
文の実行には数秒ほど時間が掛かるが、レコードがない場合にはSQL文の実行は一
瞬で終わる。ユーザーに返される画面はどちらの場合でも変わりないが、データ
が返ってくるまでの時間に差が出るのだ。なんとも巧妙な方法である。PostgreS
QLで同様の方法を実現する方法は、おそらく見つかっていない。

　この「時差攻撃」を防ぐために、UNIONキーワードの禁止と同じ方法が使える。
benchmark関数の使用を禁止してしまえばよいのだ。具体的にはUNIONキーワード
の場合と同様にsql/lex.hを編集し、

-----
   { "BENCHMARK",        SYM(BENCHMARK_SYM)},
-----

　の行をコメントアウトするなりしてしまえばよい。


■0x06.) まとめ

　今回はBlind SQL Injectionでデータを盗み出す際に利用される、「結果によっ
て故意にSQLエラーを引き起こす」実験をMySQLとPostgreSQL上で行った。データ
ベース内に格納される重要な情報（パスワードやクレジットカード番号など）は
このような方法で掘り出されかねないので、暗号化した状態で格納する方がよい
と言えるだろう。

　今回、hsj氏にBBS上でたくさんの貴重なアドバイスを頂くことで、最終的にこ
のように記事をまとめることができた。感謝する。技術を掘り下げていく際に、
同じ興味を持つ人間が複数集まることのありがたさをあらためて実感した。

