x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第3章: Ollydbgをはじめよう ---

著者：marodc

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　さて、クラック業界（？）も『クラッキング・バイブル』などの発売でにわか
に活気づいてきた感がありますが、Ollydbgは中でもWindowsでクラックを行う際
には重要度では3本の指に入る（と思う）ツールのひとつです。ところが意外と使
い方にとまどう人がいるらしく、どうも「なんかとりあえず常備してはあるけど、
使ってない」状態になってる人が多いようです。というか、結構使いやすいよう
に作られているので、基本を押さえればかなり応用が利くはずです。
　今回は、crackmeや、その他一般に公開されているソフトウェアを使ってのクラ
ックの紹介ではなく、単純にOllydbgの操作の説明という感じでできる限り汎用性
を持たせて書き進めていきたいと思います。

　なお、以下文中にてはアセンブリ言語の一部知識とある程度のWindowsの操作に
関して知っているものとして説明している箇所がありますので、ご存じなければ
その都度調べていただければと。
　OllydbgはWindows XP上でVersion 1.10を日本語化したものを使用しました。日
本語化されていない場合は、その都度読み替えるか日本語化するかのいずれかの
対応をお願いします。
　またWindows 9x系での解析は、一部解析結果に多少の違いが見られる（らしい）
ので、NT系OSで解析されることをおすすめします。


■0x02.) Ollyの前に

　まず、ウィルスチェックをしましょう。解析の対象がウィルスに感染していた
場合、というかウィルスそのものであった場合感染してしまうおそれが大いにあ
ります。もしこれが面倒なら、VMWareなりVirtual PCなりの上でやればよいでし
ょう。
　続いてパッカーの検出を行うためにPEiD（PE iDentifier）にかけます。UPXな
どが有名ですね。もちろん手動でアンパック（パッカーでパック＝圧縮されたも
のを解凍すること）することもできるのですが、スキル向上にはなるとはいえ大
変面倒です（興味のある方は古今東西大量のチュートリアルがありますので調べ
てみてください）。アンパックツール（UPXならUPX本体からupx -dコマンドで解
凍できます）さくっと解凍してしまいましょう。


■0x03.) 情報収集をする

　まず解析を始めるために、目標を確認しておきましょう。いったい自分は何が
したいのか？「シリアルキーを求め、使用期限制限を解除する」「CDチェックを
解除する」…いろいろありますがともかく確固たる目標を設定するのが大事です。
目標をしっかり設定しておけば、後の解析に必ず役立つでしょう（っていうか、
目標がわからないと何もできません。笑い）。

　さて、実際の解析にはいるのですが、まずはその前に最終目標に行き着くまで
の道のりを考えておくのが賢い方法であると思います。ということは道のりを考
えるに当たって、プログラムそのものの挙動を確かめる必要があるでしょう。と
いうことで、まず解析の最初の最初の第一歩としてプログラムをOllyを通さずに
一度起動してみるという作業が必要になります。そして最終目標に向けての情報
収集を開始するわけですね。例えば、よくあるcrackmeの場合の最終目標は「シリ
アルキーを求める」ことであり（注、シリアルキーを求めることが最終目標でな
いcrackmeも存在します）、さらにそこに行き着くまでのプログラムの挙動を紙
でもnotepad.exeでも何でもかまわないので書いてみるということをしてみる、
という作業が下準備になります。解析の前ですから当然シリアルキーは不明なの
ですが、それでも適当なキーを入力してみたりする作業も必要です。何が必要か
というとエラーメッセージが必要です。エラーメッセージは解析を行うにあたっ
ての大きな鍵、キーポイントになります。ダミーキーを入力した後でたエラーメ
ッセージ（「シリアルキーが違います！」「不正解です！」など）は必ずメモし
ておきましょう。一般化すると、何か目標の挙動（CDROM チェックの解除などな
ど…）をさせるにあたって、解析を行う前は当然正解を知りませんから、その目
標の挙動は行われず、エラーメッセージなどが表示されるわけです。そのエラー
メッセージをメモしておきましょう。これは後で役に立ちます。

　では、解析の対象となるファイルをOllydbgで開くと、まず逆アセンブルされた
リスト、レジスタなどの画面が目につきます。さらに、Ctrl+Nを押すと、ラベル
・ネームの一覧というのが出てきますね。これが対象が使用しているAPI関数の一
覧になります。まずはだいたいメインウィンドウの逆アセンブルリスト、それか
らラベルネームの一覧の2つから情報収集することになります。
　情報収集のためのアプローチは目標によって違いますが、ここで説明の便宜上、
教材を使用することにします。eagle0wl氏が制作されたcrackme Vol.1より#03を
使用したいと思いますので各自調達してください（笑い)。もちろんなくてもあ
る程度は理解できるように書き進めます。

　なお、carckmeはeagle0wl氏のサイトからダウンロードできます。

http://www.mysys.org/eagle0wl/re/crackme/crackme.html

　ところで逆アセンブルリストというのは、上から下へ（ジャンプ命令をのぞけ
ば）順番に実行されていくように出力されています（少し語弊がありますが）。
ということは、逆順に追っていくと逆にプログラムを実行する、タイムラインを
逆に走ることが可能になります。
　目標が「シリアルキーを求める」ことなら、プログラムは「入力されたシリア
ルを取得し、チェックし、正否判定を行い出力する」という風に書かれているは
ずであり、なおかつ逆アセンブルリストもその順に命令が並んでいるはず、と理
解できます。ということは、「出力する」ところを発見すれば、「正否判定を行
う」場所、「チェックする」も発見できる、芋づる式に分かっていくはずです。
ここでシリアルを判定しているルーチンがどこにあるかということも分かります。

　ということで、その「場所」がどこにあるかを特定するためには、そのために
プログラムが書かれてあり、逆アセンブルリストにも当然載っているはずですか
ら、その「場所」にある何らかの行動を表すためのルーチンがあるはずです。言
い換えれば、その場所それぞれでは、必ず「行動」を行うためのルーチンが記述
されているか、あるいはCALL命令で関数が呼び出されているはずです。補足する
と、Windowsでは、煩雑なコードを書くことなく「文字を取得する」とか「メッセ
ージボックスを出力する」といった作業を行うためにAPI関数というものが用意さ
れています。たとえばメッセージボックスを出力している場所での逆アセンブル
コードは「CALL DWORD PTR DS:[<&USER32.MessageBoxA>>; \MessageBoxA」という
ように"MessageBoxA"というAPI関数が呼び出されています。ということは、何ら
かの行動（そしてそれがAPI関数を使用せねばならないような）を起こしている場
所を特定するためには、とっさに思いつくのは「API関数を推測する」といったと
ころでしょうか。たいてい、こういった文字取得系なら、「GetWindowTextA」と
か「GetDlgItemTextA」などとなっていたりします。API関数の名前というのはま
あだいたいはわかりやすいようにつけてあるので、Ctrl+Nで出てくる「ラベルネ
ームの一覧」ウィンドウで眺めて、適当に目星をつけてブレークポイントをセッ
トということです（このあたりは後ほど解説します）。

　しかし、なかなかわからないこともあると。というかわからないことがたいて
いだったりする･･･と。ではどうすればいいでしょう？ということで、この項目で
一番最初にお話ししたエラーメッセージが生きてくるわけです。エラーメッセー
ジは逆アセンブルリストの右側に表示されます。エラーメッセージは当然プログ
ラムの中に書き込まれているからです（シリアルキーのチェックルーチンが単純
にif文で入力文字列と正しいキーを判別しているだけの時など、バイナリエディ
タでエラーメッセージを追っていくと至近距離にシリアルキーが書いてある場合
もあります。このときを通称「倍直」といいます）。

　さて、ここからは例を出して解説します。たとえば、先述のcrackme #03の中に
はこのようなくだりがあります：

-----
00401218   .^72 E6          JB SHORT crkme03.00401200
0040121A   . 6A 00          PUSH 0                                   ; /Style = MB_OK|MB_APPLMODAL
0040121C   . 68 E7304000    PUSH crkme03.004030E7                    ; |Title = "登録情報"
00401221   . 68 FD304000    PUSH crkme03.004030FD                    ; |Text = "正解です！"
00401226   . FF75 08        PUSH DWORD PTR SS:[EBP+8]                ; |hOwner
00401229   . E8 42000000    CALL <JMP.&USER32.MessageBoxA>           ; \MessageBoxA
0040122E   .^E9 6BFEFFFF    JMP crkme03.0040109E
00401233   > 6A 00          PUSH 0                                   ; /Style = MB_OK|MB_APPLMODAL
00401235   . 68 E7304000    PUSH crkme03.004030E7                    ; |Title = "登録情報"
0040123A   . 68 F0304000    PUSH crkme03.004030F0                    ; |Text = "不正解です。"
0040123F   . FF75 08        PUSH DWORD PTR SS:[EBP+8]                ; |hOwner
00401242   . E8 29000000    CALL <JMP.&USER32.MessageBoxA>           ; \MessageBoxA
-----

　このcrackmeを起動して適当なパスを入れ、登録を押すと「不正解です。」とメ
ッセージがでることがわかります。では、プログラムの中で「不正解です」とい
うメッセージを出力している部分は、当然先に示した部分だと分かりますが、で
はこの部分はどうやって探せばよいでしょうか？そこで、先ほどの考え方を引用
してみると、まず「API関数を推測してみる」ことになります。メッセージボック
スを出力するAPI関数は何か？と考えると、MessageBoxAというAPI関数がすぐに思
いつく…ようになりましょう。すると、最初に述べた「ラベルネームの一覧」ウ
ィンドウ内にMessageBoxAも表示されていますから、カーソルを当ててEnterを押
すとMessageBoxAが使われている箇所がずらりと出てきます。CALLで呼び出されて
いるのがメッセージボックス出力部分ですから、ダブルクリックかEnterを押すと
使われているアドレスに飛びます。

　ではなかなかわからないときもあるということは説明したとおりですが、そこ
で「参照文字列」を検索する方法をとります。メインウィンドウに表示された逆
アセンブルリストのどこでも良いですから右クリックして、「検索」→「すべて
の参照文字列」で行き着けるそこには大量のエラーメッセージだのなんだのがい
っぱいありますね。また参照文字列が多すぎる場合は右クリックして「テキスト
を検索」を選択すると検索も可能です。すなわちこのときにエラーメッセージが
生きてくるということです。エラーメッセージの文字列を手がかりに検索をかけ
るとヒットするということです。これも同様にEnterかダブルクリックで該当のア
ドレスに飛べます。

　このように、情報収集の手段としては、まず「API関数の名前」を手がかりにす
ること。また「ダイアログボックス内の文字」「メッセージボックスに表示され
た文字」も同様に手がかりになり得ます。この辺ではまだ情報収集の意味は「？」
だと思いますが、後々のブレークポイントの設定や、ステップ実行の話をすると
きに大変重要となるので先に説明しておくことにしてみました。情報収集の手段
はここで紹介した限りではもちろんなく、eXeScopeやProcess Walkerなどを使う
こともできます。その方法に関してこの文章中では扱いません。


■0x04.) かしこいブレークポイントの設定

　では、ブレークポイントの設定の話に移りますが、ブレークポイントはきちん
と設定してますか（笑)？　なんか設定しない人もいるようですが、設定しない癖
がつくとやっかいとはとてもいえませんが、まあ、常に設定するくせをつけてお
いた方が良いのではないかなと（個人的には）思います。さらに、重要なことで
すが、「かしこいブレークポイントが設定できると、かしこいステップ実行によ
るかしこい解析が可能になる」というなんかカシコカシコな法則が導き出されま
す。

　さて、ブレークポイントを置く場所ですが、「ブレークポイント以前がどうで
もいい処理で、ブレークポイント以後がステップ実行で見たい場所」に置けば間
違いないでしょう。そのほかにも目印として使ったりすることもできますが、基
本的な置き方は先の通りです。ビデオを見ているとき、気になったシーンで一時
停止するのと同じようなものだと思っていただければ大丈夫です。感覚的にいう
ならドラえもんの道具で「時を止める」みたいな感じで使えばいいです（笑い）。

　ところで、ブレークポイントを設定する前に、Ollyの上では大まかに分けて3通
りにプログラムを実行することができます。まずひとつめはブレークポイントま
で一切止まらずに実行する「実行（F9キー）」、2つめはアドレス通り1行ずつ実
行し、1行ごとに止まる「ステップ実行（F8キー）」、同じステップ実行でも、C
ALL命令の内部に潜る「詳細ステップ実行（F7キー）」ですね。ステップ実行と詳
細ステップ実行の違いは後ほど説明したいと思いますが、ブレークポイントは基
本的に、逆アセンブルリストが膨大な量になるプログラムを解析する際に、「ブ
レークポイント前まではどうでもいい処理」「ブレークポイントをおいたところ
から先が（目標達成にあたって）重要な処理」となるところにブレークポイント
を置いておくと、まず最初にF9キーを押してブレークポイントまですっ飛ばし、
そこからステップ実行、または詳細ステップ実行で解析を進めることができ、大
変効率的です。もちろんそれだけでなく、単なる目印に使うこともできます。マ
インスイーパの旗のように、乱発してどうにかなるようなものではないので、と
りあえず迷ったら置いておけば良いです。しかし解析を進めていくうちに取捨選
択を進めることは大事です。先ほども言ったように賢いブレークポイントを設定
するというのは賢い解析のために必須条件なのですから。

　さて、では実際にブレークポイントをどこに置くかですが、基本的にはAPI関数
におくのがまあ定石なのかな、といったところなのですが、どのAPI関数におくか
も目標によっては変わってきます。その場合にも、「どこまでがどうでもいい処
理で、どこからがじっくり見ていきたい処理なのか」を念頭に置いてブレークポ
イントを設置すれば問題ありません。たとえばcrackmeだと、「シリアルがプログ
ラムに取得されるまでがどうでもいい処理で、シリアルが取得された後がじっく
り見ていきたい処理」となりますからブレークポイントを設置する場所は「シリ
アルを取得するAPI関数」になります。しかし、ナグ消しのたぐい、あるいはエラ
ーメッセージを消すたぐいのものは、メッセージ出力部分にブレークポイントを
仕掛けた方がよいこともあります。これは特にCD-ROMチェックにおいてよくある
パターンですが、下のチャートのように、OKがクリックされると戻るというパタ
ーンにおいて、メッセージボックス部分にブレークポイントを仕掛けておくと便
利なこともあります。

CDが入っているか→入ってない→エラーメッセージ（CD-ROMを入れてください）
→【ブレークポイント】→OKがクリックされると戻る→入ってる→起動

　いずれにせよ、この辺はかなり経験に左右されますから、とにかくどんどんブ
レークポイントを設定して使ってみるというのが上達にもっとも近い道でしょう。
　ところでこの後ステップ実行にあたって、ブレークポイントがきちんと仕掛け
られていた場合、調査も容易に進むのですが、全く的はずれなところに設定され
ていた場合Ollyにうまく処理が移ってくれないこともあります。こういうときは
ブレークポイントの設置からやり直しでしょう。F9を押したときに、たとえばシ
リアルのクラックならシリアルが入力された状態でOllyに処理が移るとか、CD-R
OMチェック回避のクラックならCD-ROMチェック部分で処理が移る、そういうのが
理想的だと思います。


■0x05.) かしこいステップ実行の仕方

　ステップ実行は先ほどさらっと書きましたが、要するにF9/F8/F7の使い分けの
話です。ブレークポイントは先の章で述べたとおり使ってもらえると思いますが、
ようするに最初はF9でブレークポイントまで飛ぶと。そしてブレークポイントか
ら先はステップ実行で詰めていくことになります。
　ここで、ステップ実行と詳細ステップ実行の違いを簡単に説明しておきますが、
まずCALL命令はご存じかと思います。要するに別の場所に書かれてあるルーチン
を呼び出す…感覚的には「数行にまたがった命令を一行に圧縮している」と考え
てもよいと思います。CALLは何らかの土産を持って帰ってきます。それは値であ
ったり、様々ですね。このルーチンの内部に入るのが詳細ステップ実行、ただの
1命令として処理するのがステップ実行です。API関数を呼び出しているCALL命令
はF8でスルーした方がよいでしょう。プログラム内部のアドレスが呼び出されて
いる場合は、場合によって判断しますが、たいていは潜った方が何か見つけられ
ることが多い（ような気がします）。
　ステップ実行中は、特にレジスタ・フラグの変化と、逆アセンブルリストの下
とダンプウィンドウの上に表示されている白いボックスに注目しましょう。逆に
いえばそれ以外はあまり注視する必要はありません。
　ブレークポイントから先は、逆アセンブルリストをじーっと見つめて解析して
みる、場合によっては紙に書き写してトイレなり電車なりで解析してみるという
のもおもしろいですが、まあとりあえず一行ずつ実行してフラグやらレジスタの
値を変化させて正解に（無理矢理）導くというのが結構楽しいですし、中身を書
き換える（パッチを作る）場合には、そういった試行錯誤が重要なこともありま
す。たとえば、先ほど例に出した crackme #03ですが、パス取得のAPI関数（ブレ
ークポイント設定地点）から先数行のリストをみてみます。

-----
004011F4   . E8 6B000000    CALL <JMP.&USER32.GetDlgItemTextA>       ; \GetDlgItemTextA
-----

ここで入力したパスを取得して、

-----
004011F9   . BE 2C304000    MOV ESI,crkme03.0040302C                 ;  ASCII "qwertyu"
-----

でレジスタに入れてるようですね。

-----
004011FE   . 33C9           XOR ECX,ECX
-----

ECXレジスタを初期化（XOR ?,?は初期化ですから覚えておきましょう）

-----
00401200   > BF 08314000    MOV EDI,crkme03.00403108                 ;  ASCII "vP12NGgoQa"
-----

これは…正解っぽいものが代入されてますね。

-----
00401205   . 8A0439         MOV AL,BYTE PTR DS:[ECX+EDI]
-----

先ほどの正解っぽいパスから1文字が代入されています。

-----
00401208   . 8BD9           MOV EBX,ECX
0040120A   . 83E3 01        AND EBX,1
0040120D   . 03C3           ADD EAX,EBX
0040120F   . 3A0431         CMP AL,BYTE PTR DS:[ECX+ESI]
-----

そしてこれがおそらく比較部分であろうということは容易に想像がつきますね。
CMP命令が特にアヤシイです。

-----
00401212   . 75 1F          JNZ SHORT crkme03.00401233
-----

さらに、00401233＝不正解メッセージを出力するアドレスに飛ぶことから、この
時点でZフラグが立っているか降りているかが即これが正解か不正解かを分ける境
目になるということです。

-----
00401214   . 41             INC ECX
00401215   . 83F9 0B        CMP ECX,0B
00401218   .^72 E6          JB SHORT crkme03.00401200
-----

で、1文字比較した後は次の文字を調べるのでしょうか。

（以下は上の方に書いたので省略）

となっています。

　ここで、00401200〜00401218がシリアルをチェックするルーチンになっている
ことはもうおわかりだと思いますが、ステップ実行を進めていくと、命令に応じ
て、どんどんレジスタやフラグが変化していくのがわかります。さらに、レジス
タはダブルクリックで書き換えウィンドウがでますし、フラグは一度クリックし
てやると0と1が変化します。付け加えると、逆アセンブルリストの下にあるボッ
クス野中に表示されているレジスタの中身などですが、右クリックしてデータ修
正を選ぶと書き換えウィンドウが出現します。このようにどこからでもOllyの上
で踊っているプログラムは書き換えが効きますので、とにかく書き換えしながら
進めて行くと、いずれ強制的に正解にたどり着くでしょう。逆に考えれば、書き
換えた箇所がパッチを当てるべき箇所となります。パッチを当てるには該当の命
令の上にカーソルを当ててSpaceキーを叩くと書き換え画面が出てきますから任意
の命令に書き換えてやればよろしいです。


■0x06.) とりあえずおさらい…

・実行する前にウィルスチェックをして、パッカーを検出しておくこと。
・とりあえずOllyを通さず解析対象を起動してみて眺めて情報収集をしてみるこ
と。
・ブレークポイントを試行錯誤しながらきちんと設定し、煮詰めること。
・ブレークポイントを参考に、値やフラグを書き換えたりしながらパッチの対象
を探し、あるいはシリアルを算出しているルーチンを探して目標を達成すること。

　eagle0wl氏が制作されたcrackmeは、Vol.1にせよVol.2にせよ、一応定石みたい
なものが存在します。もちろん、こういったcrackmeにかぎらず、ほとんどのクラ
ックシーンで定石になるやり方なのですが、まず最初にターゲットのソフトウェ
アを起動し、どういう形でシリアルが取得、あるいはキーファイルでもなんでも
ですが、どういう関数が使用されているか想像します。たいていは"Getなんたら
かんたら"とかですし、キーファイルなら"CreateFileA"になっています。そこで
Ollyのラベルネームの一覧でその関数名を探し、とりあえずブレークポイントを
仕掛けて、後はステップ実行とレジスタ・フラグの処理を重ねながら煮詰めてい
くという作業になるかと思います。


■0x07.) おわりに

　さて、ここまでとりあえず読んでいただけたら大まかな流れはつかめる…かな
？　と思いますので、「Digital Travesia」さんのコンテンツ、Ollydbg Q&Aをと
りあえず一読すれば基礎知識としてはほぼ完成になると思いますので、是非読ん
でおいてください。また応用力を養うためにcrackmeにもどんどん挑戦していけば
自ずと身に付くはずです。その際は是非そこら辺にあるeagle0wl's crackme tut
orialを拾ってきましょう。とりあえず一定のレベルに達するためには経験がもの
をいうはずなので、とにかく数をこなせばレベルアップすること請け合いです。
　さて、以上何か質問などあれば受け付けますので、ほかにも感想とか、あと重
要ですが間違いなどあればメールぜひお願いします。

　ではまたお会いしましょう。


