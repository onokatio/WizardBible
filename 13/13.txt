[-]=======================================================================[-]

                      Wizard Bible vol.13 (2004,11,1)

[-]=======================================================================[-]


x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

  ---- 第０章：目次 ---

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

○第１章：BLACK HAT JAPAN レポート                            金床 著

○第２章：Linuxを読んでみよう　〜 bootsect.S篇 〜       Kenji Aiko 著

○第３章：アタッカーのためのサバイバルマニュアル          IPUSIRON 著

○第４章：オークション詐欺　詐欺師を詐欺した元詐欺師           MaD 著

○第５章：お知らせ

○第６章：著者プロフィール



x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第１章: BLACK HAT JAPAN レポート ---

著者：金床

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　ハッカーの祭典として名高いDEFCON。毎年夏になるとラスベガスで開催され、
世界中からハッカーやセキュリティ研究者、スクリプトキディが集まり、40度近
い暑さの中でさまざまなハッキング談義に花を咲かせます。…らしいです。すみ
ません、行ったことないので聞きかじりです。少なくともハッカージャパンを読
む限りはそんな感じらしいです。
　DEFCONの主催者はダーク・タンジェントことジェフ・モス氏ですが、彼が主催
するもう一つのセキュリティカンファレンスがBLACK HATです。BLACK HATはDEFC
ONと比べてよりプロフェッショナルな客層をターゲットとしており、内容はテク
ニカルで、スピーカーや講師陣は誰しもが認める高スキルの持ち主ばかりとなっ
ています。BLACK HATはアメリカやヨーロッパ、シンガポールなどで開催されてき
ましたが、2004年の10月についに日本でも開催されることになりました。今回日
本で開催されたBLACK HAT JAPANは本来のBLACK HATよりも小規模での開催となっ
たこともあり、料金も6万円と比較的参加しやすいものだったため、思い切って参
加してみることにしました。今回はこのBLACK HAT JAPANのレポートをお送りしま
す。


■0x02.) 一日目

　今回BLACK HAT JAPANが開催された会場はお台場の近くで、初日は昼の12:00に
受付開始というスケジュールでした。受付で手続きを済ませると各プレゼンテー
ションの資料（主にパワーポイントで作成されたもの）が収録されているらしい
CD-ROMと、それらが印刷された分厚い冊子などがもらえます。これはつまり事前
にプレゼンテーションの内容が全て確認されているという意味であり、この時点
で「なかなかしっかりしてるんだな」という印象を受けました（若干名資料が間
に合わなかった人もいるみたいです）。会場はそれほど広くはなく、120人くらい
入りそうなホールともう少し小さな部屋、そしてそれらを結ぶ空間だけです。知
り合いがいないか探してみましたが意外なほどに知っている顔が少なく、普段僕
が参加するような料金の安いイベントと、今回のようにある程度値段の張るイベ
ントの違いを感じました。参加者の年齢は20台後半から40歳くらいまでの人が多
く、スーツと私服が半々といった感じでしょうか。

　12:30になると、いよいよBLACK HAT JAPANのスタートです。ステージにダーク
・タンジェントが上がり、代表の挨拶が始まります。当然ながら挨拶は全て英語
で行われました。ところで今回のBLACK HAT JAPANではヘッドセットで日本語の同
時通訳音声が聴けるようになっていて、英語がダメな人でも内容が理解できるよ
うに配慮されています。僕も最初はヘッドセットを借りたのですが、英語でもな
んとか分かりそうだったので結局使わずに過ごしました。ダーク・タンジェント
のスピーチは「以前から日本でBLACK HATを開催したいと思っていた」とやや熱の
こもった感じです。BLACK HATはテクニカルであることにこだわり、ベンダーニュ
ートラルなイベントであること。また、参加者が何かしらを得て帰って欲しい、
などと続けました。そしてスピーカーに質問がある場合には積極的に訊くべきで
あり、開催者側も参加者が質問などをしやすいように、それぞれのスピーチの合
間などの時間には顔を出すようにする方針である、と語り、これにはとても良い
印象を受けました。全体を通して、本当に参加者のことを考えているな、と思わ
せるイベントであり、この点が予想以上でした。
　その後プレゼンテーションを行うスピーカー全員がステージに上がり、紹介と
質疑応答が行われました。間接的にではありますがSQL Slammerで世界中の管理者
を休日出勤させた（？）ディビッド・リッチフィールド氏をはじめとする世界中
のセキュリティプロフェッショナルが並ぶ様は圧巻です。また、その中にeEyeの
鵜飼氏やSecurityFridayの佐内氏、関氏がいるのはなかなか良い気分です。質疑
応答では最近Windows XPに実装された（らしい。良く知らない　笑）バッファオ
ーバーフロー防止機能の話や日本のネットワークに対するアジア方面からの攻撃
などに関する話題が出ました。質疑応答はプレゼンテーションとは異なりごく普
通の（？）英会話なので、内容についていくのはなかなかしんどいものがありま
した。日本人からの日本語での質問がある場合にはスピーカー陣もヘッドセット
を使い、英訳された音声を聴いて内容を把握しているようでした。

　この後いよいよ各スピーカーによるプレゼンテーションが開始されます。2つの
会場で2つのプレゼンテーションが同時に行われるため、テーマやスピーカーから
考えて好きな方を選んで参加することになります。僕は最初はディビッド・リッ
チフィールド氏のプレゼンテーションを選ぼうかと思っていたのですが、テーマ
がOracleということでやめました。僕の会社は貧乏でOracleなんて触る機会がな
く、役に立たないことが明らかだったからです。そんなわけでゲルハルト・エッ
シェルベック氏の「統計が示す内部ネットワークの脆弱性の法則」というプレゼ
ンテーションを見てみることにしました。彼は過去の膨大なネットワーク上の攻
撃に関するデータについてさまざまな考察を行い、ワームの活動に半減期がある
事などを示しました。僕個人にとっては残念なことに、あまりテクニカルなプレ
ゼンテーションではありませんでした。

　次にクリス・イーグル氏の「IDA Proを使用しての、"難読化"が施されたプログ
ラムの解析と対策」に参加しました。参加する前は「難読化なんて興味ないな」
と思っていたのですが、結果的には非常に興味深く、インスパイアされる内容で
した。IDA Proはクラッキングやリバースエンジニアリングで良く使用される有名
なツールです。今回のプレゼンテーションではこのIDA Proを実際に動かし、デモ
ンストレーションをやってくれました。やはりパワーポイントのページをめくる
だけのプレゼンテーションより、デモ有りの方がいいですね。彼は悪意あるプロ
グラムに施された難読化を破るためにIDA Proのプラグインとして動くx86のエミ
ュレータを開発しており、今回のプレゼンテーションはその具体的な使用方法が
中心となっていました。IDA Proがとても面白そうに見えたので家に帰ったら使っ
てみよう、と思いきや、どうやら有償のツールのようでがっかり。貧乏人はOlly
Dbgで我慢するしかないのでしょうか。テーマの中心である「難読化」は「難読」
というほどではなく、IDA Proをだますための小技といった感じでした。

　この後、内閣の偉い人のスピーチがあったらしいのですが、久しぶりに会った
某U氏と某h氏と会場の外で盛り上がってしまい、結局聴かずじまいでした。時間
は早くも夕方の18:00となり、スポンサー企業である住商エレクト●ニクス（一部
伏せ字）によるレセプションとなります。いわゆる夕食会のような感じで、「ス
ポンサーにより、食べ物と飲み物が用意される」「スピーカーもいるので、捕ま
えて話を訊くべし」ということでしたが、用意されていた食べ物（クッキーとか
クラッカーとか　笑）が本当にびっくりするほどホンのちょっとで、かなりウケ
ました。にも関わらず飲み物のグラスに「SS●」（一部伏せ字）というステッカ
ーが貼ってあって「このレセプションのスポンサーは俺たちだぜ！」というアピ
ールがされていたのですが、これは残念ながら「S●E＝ケチ」（一部伏せ字）の
印象を植え付けるという、いわば逆効果となっていました。

　ここで翌日に「Google Hacking」をテーマにプレゼンテーションを行う予定の
ジョニー・ロング氏を捕まえて、少し話をすることができました。個人的に興味
があったのが、いわゆるウェブサイトなどからの個人情報漏洩が、海外でも大き
な問題となっているのか？　ということでした。国内では情報セキュリティを企
業等が検討する際の理由として間違いなく上位にランクインする個人情報漏洩で
すが、海外ではあまり騒がれていないような印象を受けていたからです。特に、
Apacheの設定ミスでディレクトリ中のファイル一覧が丸見えで、csvファイルが2
chから流出…みたいな図式は海外でもポピュラーなのかが気になっていました。
ジョニー氏につたない英語でなんとかこのことを訊いてみると、「少なくともUS
Aではそういったこと（掲示板などをきっかけとした情報の流出）はポピュラーで
ない」とのこと。どうやらそもそも2chみたいなものが無いようです。「日本には
巨大な匿名掲示板サイト、2ちゃんねるというのがあって、そこに情報漏洩を見つ
けたやつが書き込むと、そこから爆発的に個人情報漏洩が始まるんだぜ」と伝え
ると、「oh、サイアクだな」と言われてウケました。日本人の心の闇、2ch。セキ
ュリティをテーマに来日する外国人にも是非ともその存在を知って欲しいもので
す。


■0x03.) 二日目

　さて2日目です。2日目は朝の9:30に最初のプレゼンテーションが開始されまし
た。ここでは昨日話をすることができたジョニー・ロング氏の「Googleを使った
ハッキング手法の子細」に参加しました。「どうせ、Googleに適当なキーワード
を入れて、出てきたものを見るだけだろう」と甘く見ていたのですが、入力する
キーワードと出てくる結果が僕の予想を大きく上回っており、ニヤニヤさせられ
ました。個人的にウケたのは「PRIVATE CERTIFICATE」で検索して証明書が出てき
てしまい「Maybe, no more private」と結論づけていたり、データベースのダン
プファイルがまるごとインターネット上に置いてあったりするネタでした。また、
SnortのウェブベースコンソールアプリケーションであるACIDの管理画面が出てく
るのも面白かったです。そしてやはりというかクレジットカードの番号も少なか
らず検索によって見つかってしまうようで、Google様の恐ろしさを再認識しまし
た。

　休憩を挟んで、SecurityFridayのプレゼンテーションに参加しました。テーマ
は「NTLM2 Session Responseのリアルタイムパスワード解析とXP SP2への攻撃の
可能性」です。僕はWindowsの認証系の知識は全くゼロだったので「たぶん何も理
解できないだろう」と気軽に臨んだのですが、パワーポイントの資料が分かりや
すく、また説明も的を得ていたおかげで大まかに理解することができました。OS
ごとに実装やサポートするプロトコルが微妙に異なる点や、プロトコルの正式名
称が不明な点などはマイクロソフトらしいなと感じました。SecurityFridayは
Windows系の様々な実験・研究を自分たちが楽しんでやっているんだな、という雰
囲気が伝わって好印象でした。公開されていないプロトコルを興味ある人間が解
析していく過程はまさに「ハッキング」だな、と感じます。結局Windowsの認証
系は、僕が大好きなPOP3やFTPなどよりも遙かに安全であることが分かりました
（笑）。

　昼休みはお弁当が配られ、皆建物の外のベンチなどでのんびり食事を楽しみま
した。その後13:10から、「Turn the table」と題されたシャール・ヴァン・ワル
ト氏のプレゼンテーションに参加しました。彼は南アフリカからはるばる来日し
て自分がセキュリティについてスピーチできることが非常に光栄だ、と語り、ゆ
っくりと丁寧な英語でプレゼンテーションを開始しました。僕が見た中では唯一
彼だけが同時通訳の音声（つまり、日本語）を聴きながら、自分の話す速度を調
節してプレゼンテーションを行っていました。彼にとって英語は第二言語だそう
で、言葉の問題に対する考えがネイティブスピーカーとは違うようです。
　彼のプレゼンテーションのテーマは、いかにして攻撃者に手間をかけさせるか
ということでした。通常、攻撃者は思いついたときに好きなだけ攻撃して飽きた
時点でやめることができますが、防御する側は24時間365日ネットワークを守らな
ければなりません。つまり攻撃と防御にかかるそれぞれのコストの差は歴然とし
ている、と彼は言います。そこで、少しでも攻撃する側（どうも、スクリプトキ
ディレベルを想定しているようでしたが）にもコストをかけさせたいということ
で、様々な小技を披露してくれました。このような小技はセキュリティコミュニ
ティの中ではあまり評価されない印象があるのですが、僕は個人的に小技・小細
工が大好きなので、途中からかなりニヤニヤしながら聴いていました。例えば、
DNSゾーン転送を許可しているようなフリをして嘘の情報を提供するJava製のダミ
ーDNSサーバープログラムや、全てのHTTPリクエストに対して200のステータスコ
ードを返信してウェブサーバーに対する（特に、NiktoやNessusなどのありふれた
ツールによる）スキャンを無効化する方法などが挙げられました。また、Armpit
と名付けられた、ウェブサーバーに対するアクセスが人によるものかツールによ
るものかを判断する仕組みは比較的込み入った作りをしており、なかなか興味深
いものがありました。彼のプレゼンテーションは非常に洗練されており、途中た
くさんのデモを非常にスムーズにこなしていました。また資料としてパワーポイ
ントのものだけでなくペーパーまで用意されている点も素晴らしかったです。
　プレゼンテーション終了後、彼を捕まえて個人的に話を訊くことができました。
彼が子供のころ、彼の父親は日本の某大企業関連の仕事をしており、何度か出張
ではるばる日本まで来たそうです。その際におみやげとして買ってきてくれる日
本のオモチャは（たぶん、彼の周りにあったオモチャに比べて複雑であったり、
よく出来ていたりして）、彼にとって最高の宝物だったそうです。

　さてBLACK HAT JAPAN最後のプレゼンテーションでは、eEyeの鵜飼氏（そう、
ｳﾆｭﾝﾁｮさんです）が登場しました。テーマは「WindowsシステムのExploitにおけ
る環境依存性」ということで、僕が最も興味あるテーマのうちの一つです。eEye
はいくつものプラットフォームで共通して利用可能なアドレスを抽出するための
プログラム、EEREAPを完成させたらしく、その結果などが発表されました。…肝
心なアドレス一覧にはボカシが入っていてウケました。やはり、ただ普通に
「jmp ebx」などを検索（「シンプルサーチ」と呼ばれていた）するのに比べて大
量のアドレスが発見されており、実際にその仕組みを作ったeEyeスタッフの根性
には脱帽です。ｳﾆｭﾝﾁｮさんとかﾃﾞﾚｸとかがいかにも好きそうなネタです。IDA関係
のプレゼンテーションでも登場していたし、どうやら世間ではx86エミュレータが
アツイようです。
　共通のアドレスを使用するExploitに対抗するための対策としてDLLベースアド
レスの変更とDLL中の関数の移動などが提案されていましたが、これは両方ともま
だ研究段階だそうです。DLLベースアドレスの変更はアプリケーションの起動時間
が長くなる可能性があるというネックがあり、また関数の移動は「移動した後に
まともに動く保証がない」という問題を抱えているようです。DLLベースアドレス
の変更は「自分だけは助かりたい」と思っている僕のような人間にとっては試し
てみる価値のありそうな方法なので、今度時間があれば手を出してみたいと思っ
ています。…そういえば、EXE本体のベースアドレスは変更できるんでしょうか。
　eEyeとSecurityFridayのプレゼンテーションは、どちらもそれぞれのテーマの
元となる研究（ハッキング）がしっかりと行われた上でその報告として行われて
いるもので、その内容の濃さ、斬新さでは海外のスピーカーによるプレゼンテー
ションを上回っていたと感じました。どちらも自分たちが好きな、興味ある分野
を極めるためにやってるんだなぁという雰囲気があり、うらやましく感じました。

　最後に閉会式として、ダーク・タンジェントからスポンサー各企業へプレゼン
トが贈られたりしました。今回のプレゼンテーションの資料や音声は3週間以内を
目安にBLACK HATのサイトからダウンロードできるようになること。来年以降も引
き続きBLACK HAT JAPANを開催したいのでフィードバックが欲しいこと。また、
BLACK HATステッカーを帰りがけにもらえること（笑）などが彼の口から語られ、
2日間に渡るBLACK HAT JAPANは終了しました。


■0x03.) おわりに

　さて今回2日間参加してみての僕の感想ですが、一言でいうと「BLACK HATイカ
ス」です（笑）。はっきりいって予想以上に素晴らしいイベントでした。まず、
「テクニカルであること」に対してこだわっている点。今回発表されたそれぞれ
のネタが特にどうのこうのというわけではなく、常にその時点で新しい技術を取
り上げていくというコンセプトが良いです。イベントの名前こそ「BLACK HAT」で
あり多少のアンダーグラウンド臭さを感じさせますが、中身は完全に技術のみに
フォーカスしたもので、「一発ネタ」みたいなプレゼンテーションは皆無であり、
僕のような技術オタにぴったりです。そして、仕切りが非常にしっかりしている
点。プレゼンテーションの中身は冊子で確認できるし、終了後にはウェブサイト
から全てのコンテンツにアクセスが可能になります。これらは実際に参加できな
い人にとってもありがたいことです。このレポートを読んで興味を持った方は、
ぜひBLACK HATのサイトのアーカイブを見てみて下さい。2年前、3年前のものなど
でも、意外と興味深いものが並んでいます。

　こんな感じで、BLACK HAT JAPANリポートは終わりです。来年も日本でやってく
れるといいな。


【編注】関連URLを次に列挙します。

・「BLACK HAT」
http://www.blackhat.com/ 

・「BLACK HAT JAPAN」
http://www.blackhat-jp.org/

・「Black Hat Japan Briefingsにかける意気込みを語るジェフ・モス氏」
http://www.itmedia.co.jp/enterprise/articles/0408/27/news051.html



x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第２章: Linuxを読んでみよう　〜 bootsect.S篇 〜 ---

著者：Kenji Aiko

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　Linuxユーザーならば、一度はLinuxのソースコードを解読してみようと考えま
す（考えますよね^^;）。LinuxのソースコードはThe Linux Kernel Archives
（http://kernel.org/）からダウンロードすることができますので、「よし早速
ダウンロードして読んでみよう」と意気込んでみたりします。しかし、いざtarボ
ールを展開して、ディレクトリを覗いてみると、ソースコードは果てしなく膨大
な量であることを実感します。ダウンロードしたは良いが、いったいどこから読
めばよいのか、どのファイルが何をしているのか、そもそもどこから始まるのか、
と疑問ばかりが膨らんでしまい、結局読む気が失せてしまいます。

　当たり前のことですが、LinuxはOSです。通常のアプリケーションならば、プロ
グラムはmain関数から始まりますから、まずは、main関数を探してそこから一歩
ずつプログラムを解読していけば、いずれはプログラムの全貌が見えてくるかも
しれません。しかし、OSはソフトウェアではありますが、通常のアプリケーショ
ンとはいろいろな部分で異なります。もちろんmain関数もありませんし、アプリ
ケーションプログラマにとっては、そもそもどうやって起動するのかも分かりま
せん。よって、たとえプログラミング（アセンブラやC言語）をマスターしていた
としてもソースを解読するのは至難のワザです。この文章では、そのような「Li
nuxソースを読みたいが、ちょっとハードルが高くて読めない」という人を対象に、
Linuxソースの中で一番最初に実行されるプログラムであるbootsect.Sをの解説を
行っていきたいと思います。

　この文章を読むために必要な知識は、まず、アセンブラが読めること（特にgas）
そして、16ビットプログラミングに関してある程度の知識を持っていることです。
特にリアルモードでのセグメントとオフセットの関係などの知識は最低限必要で
す。C言語の知識は必要ありませんが、gasが使えるならばgccも使えるかと思いま
す。Linuxは、起動部分以外はC言語で書かれてあるので、C言語が読めるにこした
ことはないですが、この文章を読むためにはさほど必要ありません。

　この文章では、Linuxバージョン2.4.23を例にとっています。しかし、今回使用
するbootsect.Sは、Linus氏が書いた1992年以降、ほとんど変わっていないらしい
ので、特にどのバージョンでも変わりありません。適当なバージョンをDLしてく
ださい。一応、私がこの文章を書くために使用したbootsect.Sをアップロードし
ましたので、よろしければ利用してください。

http://kenjinet.s26.xrea.com/assemble/bootsect.S

　では、いよいよLinuxソース解読への第一歩を踏み出してみましょう。


■0x02.) そもそもどこから始まるのか

　まずは、LinuxのソースをDLしてください。LinuxのすべてのソースコードはThe
 Linux Kernel Archives（http://kernel.org/）からDLすることができます。tar
ボールで固められていますので、適当に展開してください。

　さて、ソースコードを読む最初の問題として、「いったいプログラムはどこか
ら始まるのだろう？」という疑問がわきます。その問いに対する答えは簡単です。
「linux-2.4.23/arch/i386/boot/bootsect.S」のbootsect.Sというソースファイル
からLinuxは始まります。あなたがPCの起動ボタンを指で押した瞬間、bootsect.S
の処理は始まります。いや、もしあなたがハードディスクからLinuxを起動してい
るのならば、bootsect.Sは始まりさえしないかもしれません。もしあなたがフロ
ッピーディスクからLinuxを起動しているならば、bootsect.Sはかなりの高確率で
実行されるでしょう。そして数秒後には（もしかしたら1秒後かもしれない）終わ
っているでしょう。

　Linuxの起動プロセスの中では、ほんの一瞬の出来事ですが、その一瞬をこれか
らひとつひとつ紐解いていくことにしましょう。


■0x03.) 0x07C00から0x90000へ

　PCの起動ボタンを押したときに、まずはCPUなどのハードウェアに電気が流れま
す。そして、いろいろとハードウェアの初期化や検査などが行われます。これら
は、OS作成者の仕事ではありません。そして、それらが一通り終了すると、ハー
ドウェアはOS作成者（つまりソフトウェア開発者）が書いたプログラム（命令）
を実行することになりますが、その実行すべきプログラムはもちろんメモリ上に
はありません。当たり前ですが、最初、実行すべきプログラムはハードディスク
やフロッピーディスクやCD-ROMにあり、メモリ上にはありません。よって、まず
実行すべきプログラムをメモリに読み込まなければなりません。

　よって、ハードウェアは、プロッピーディスクの最初のセクタ（512バイト）を
メモリの07C00H以降の512バイトへ読み込みます。そして、メモリの07C00Hから実
際に（ソフトウェア開発者が書いた）プログラムを実行し始めるのです。では、
ソースを読んでいきましょう。

　bootsect.Sの冒頭には、いろいろとコメントが書かれてありますが、それは飛
ばします。読んでも意味が分かりませんし、そもそも英語で読めなかったりもし
ます（笑）。実際のプログラムは以下から始まります。

-----
# First things first. Move ourself from 0x7C00 -> 0x90000 and jump there.

    movw    $BOOTSEG, %ax
    movw    %ax, %ds        # %ds = BOOTSEG
    movw    $INITSEG, %ax
    movw    %ax, %es        # %ax = %es = INITSEG
    movw    $256, %cx
    subw    %si, %si
    subw    %di, %di
    cld
    rep
    movsw
    ljmp    $INITSEG, $go
-----

　コメントにも書かれてあるとおり、07C00Hから90000Hに自分自身を転送する処
理です。どういうことかというと、この部分は、PCが起動したときに実行される
処理です。さらに言うなれば、PCの起動ボタンを物理的にあなたの手（あるいは
指）が押したときに実行される命令なのです。コンピュータは最初に物理的にPC
の起動ボタンが押されて、まず始めに、物理的なハードウェアの診断テストを行
います。これはPOST（Power On Self Test：電源投入時自己診断テスト）と呼ば
れていて、ここはソフトウェアを扱うプログラマには関係の無い（制御できない）
部分です。POSTが終了すると、BIOSはフロッピーの最初の1セクタ（つまり512バ
イト）をメモリ空間の07C00H以降にコピーし、07C00Hに書かれてあるプログラム
を実行し始めます。ここからがプログラマが扱うべき部分となります。

-----
BOOTSEG = 0x07C0        /* original address of boot-sector */
INITSEG = DEF_INITSEG   /* we move boot here - out of the way */
-----

　07C00H以降の512バイトに書かれてある実行プログラムは、そのまま90000Hへコ
ピーします。$BOOTSEGは0x07C0とソースの上の方に定義されているので、%dsは
0x07C0となります。$INITSEGはDEF_INITSEGとなっているが、まちがいなく0x9000
（asm/boot.hより）なので%esは0x9000となります。つまり、「%ds = 0x07C0」
「%es = 0x9000」「%cx = 256」「%si = %di = 0」ということになります。cld命
令は、EFLAGSレジスタの中のDFフラグを0にします。rep命令は、次のmovsw命令を
%cxの数だけくり返す命令です。movsw命令は、「%ds:%si」から「%es:%di」へデ
ータを2バイトコピーする命令なので、それをrepによって%cx（256）回くり返せ
ば、512バイトが90000Hへコピーされることになります。DFフラグが0ならば、%si
と%diには、転送したバイト数が加算されます。現時点でDFフラグが1になること
はありえないので、加算されることになります。ちなみにmovsw命令が実行される
ごとに%cxはデクリメントされていきますので、コピーが完了した時点での%cxは
0となります。無事コピーが終わったら「$INITSEG:goラベル」へジャンプします。

　つまりこの部分の処理は、FDの最初のセクタが07C00H以降の512バイトに読み込
まれているので、そのデータを90000H以降の512バイトへコピーする処理です。ま
さに自分自身をコピーしているわけです。そして、コピーし終わった90000Hにあ
るgoラベルへジャンプしているわけです。


■0x04.) メモリ関係の設定

　goラベルは、もちろんすぐ下に書かれてありますので、ここから続きの処理が
実行されることになります。ここではDS（データセグメント）やSS（スタックセ
グメント）、そしてSP（スタックポインタ）などを設定しています。

-----
go: movw    $0x4000-12, %di # 0x4000 is an arbitrary value >=
                            # length of bootsect + length of
                            # setup + room for stack;
                            # 12 is disk parm size.
    movw    %ax, %ds        # %ax and %es already contain INITSEG
    movw    %ax, %ss
    movw    %di, %sp        # put stack at INITSEG:0x4000-12.
-----

　とりあえず、%di = %sp = 0x4000-12, %ds = %ss = 0x9000 となります。ここ
で出てくる$0x4000という数値は、bootsect.Sが利用するのに十分なだけのスタッ
ク領域を確保するという意味です。つまり適当な数値です。さらに減算している
12という数値は、次にでてくるパラメータディスクテーブルのサイズです。これ
については次のソースを見てください。


■0x05.) パラメータテーブルの設定

　ここでは、フロッピードライブのパラメータ設定を変更しているようです。ど
うやらデフォルトの設定では気にくわないようですので、お気に召すように変更
しているわけです。

-----
    movw    %cx, %fs        # %fs = 0
    movw    $0x78, %bx      # %fs:%bx is parameter table address
    pushw   %ds
    ldsw    %fs:(%bx), %si  # %ds:%si is source
    movb    $6, %cl         # copy 12 bytes
    pushw   %di             # %di = 0x4000-12.
    rep                     # don't worry about cld
    movsw                   # already done above
    popw    %di
    popw    %ds
    movb    $36, 0x4(%di)   # patch sector count
    movw    %di, %fs:(%bx)
    movw    %es, %fs:2(%bx)
-----

　コメントには、BIOSのデフォルトディスクパラメーターテーブルがどうたらこ
うたらと意味不明なことがかかれてありますが、良く分からないので無視しまし
ょう（笑）。「%fs（セグメント）:%bx（オフセット）」はパラメータテーブルの
アドレスのようなので、それを元に、ldsw命令を使って、「%ds:%si」にパラメー
タテーブルの場所をいれ、お決まりのrepとmovswを使って「%es:%di」へ転送して
います。「%cl = 6」であることから、12バイトをコピーすることになります。こ
の12バイトが、0x4000-12の減算されている12バイトです。そして、そのアドレス
を新しいパラメータテーブルとして、00078へ書き込みます。


■0x06.) セクタ数を調べる

　次はフロッピーディスクのセクタ数を調べます。コメントを読んでみると「ま
ず36で試してみてエラーが出たら18で試し、それでもエラーがでたら15で試し、
それでもダメだったら9で決め打ちする」というようなことが書かれてあります。

-----
# Get disk drive parameters, specifically number of sectors/track.

# It seems that there is no BIOS call to get the number of sectors.
# Guess 36 sectors if sector 36 can be read, 18 sectors if sector 18
# can be read, 15 if sector 15 can be read.  Otherwise guess 9.
# Note that %cx = 0 from rep movsw above.

    movw    $disksizes, %si # table of sizes to try
probe_loop:
    lodsb
    cbtw                    # extend to word
    movw    %ax, sectors
    cmpw    $disksizes+4, %si
    jae     got_sectors     # If all else fails, try 9

    xchgw   %cx, %ax        # %cx = track and sector
    xorw    %dx, %dx        # drive 0, head 0
    movw    $0x0200, %bx    # address = 512, in INITSEG (%es = %cs)
    movw    $0x0201, %ax    # service 2, 1 sector
    int     $0x13
    jc      probe_loop      # try next value
-----

-----
sectors:    .word 0
disksizes:  .byte 36, 18, 15, 9
-----

　$disksizesは、ソースの下の方に36,18,15,9と定義されているので、最初%siに
は、36という値のアドレスが入れられます。lodsb命令は、「%ds:%si」のアドレ
スにあるデータを%axにいれる命令であり、さらにDFフラグが0なら%siをインクリ
メントします。%dsは0x9000ですね。つまり「%ds:%si」は$disksizesの36のアド
レスとなるので、%axには36という値が入ることになります。そのデータをsectors
に代入し、そして%siはインクリメントされて、%ds:%siは、次の18という値のア
ドレスを示すようになります。

　$disksizes+4と%siが同じならば、36と18と15すべてで失敗したわけだから、9
に決め打ちしてgot_sectorsにジャンプします。しかし、まだ%siの値は18のアド
レスなので$disksize+1とは同値ですが、$disksize+4とは同値ではないので、ジ
ャンプせずにプログラムは進みます。

　さて、次は始めてのBIOSコールです。「Ralf Browns Interrupt List」
（http://www.delorie.com/djgpp/doc/rbinter/ix/）から検索して、動作を調べ
てください。「int $0x13」で%ahが0x02であるBIOS命令を調べてみると、
「http://www.delorie.com/djgpp/doc/rbinter/id/13/6.html」ですね。どうやら
フロッピーディスクのセクタをメモリへ読み込むBIOSのようです。jc命令は、CF
フラグがたってたらジャンプします。CFフラグが立っているということは、BIOS
コールのエラーであり、CLレジスタに設定したセクタ番号が大きいということで
すので再度チャレンジということでジャンプします。CFフラグが立っていなかっ
たらそのままループを抜けて、次へ進みます。ちなみにxchgw命令は、オペランド
同士の値を交換する命令です。つまり%cxと%axの値が入れ換わるわけです。

　では、get_sectorsへ進んでみます。


■0x07.) フロッピーの構造

　ここで、ちょっとソース解読を中断して、フロッピーの簡単な構造を学ぶこと
にします。現在（2004/10/14）もっとも主流なフロッピーディスクの容量は1.44
MBです。そしてフロッピーディスクは、セクタとトラックという単位によって管
理されています。ちなみに1セクタは512バイトです。

　さて、1セクタは512バイトですが、1トラックのセクタ数は、ソースにも書か
れてあるとおり、36, 18, 15, 9 という4つ可能性が存在します。これは、その
まま2.88MB, 1.44MB, 1.20MB, 720KBのフロッピーディスクそれぞれに対応して
いることを意味しています。トラック数は片面80個あります。つまり、フロッピ
ーディスクは両面使えるので、両面で160トラック存在することになります。1ト
ラックが何セクタであるかを求めることによって、そのフロッピーディスクがど
の規格であるかが分かります。

-----
512byte * 36(sector/track) * 160(track) = 2949120byte( = 約2.88MB )
512byte * 18(sector/track) * 160(track) = 1474560byte( = 約1.44MB )
512byte * 15(sector/track) * 160(track) = 1228800byte( = 約1.22MB )
512byte *  9(sector/track) * 160(track) =  737280byte( = 約720KB )
-----

　上記のことから、現在の主流である1.44MBのフロッピーディスクは、1トラック
あたり18セクタあることがわかります。Linuxはフロッピーディスクがどの規格で
あっても対応できるように工夫されているわけです。


■0x08.) 文字列の出力

　さて、セクタ数が分かったところで、次は実際にフロッピーディスクからデー
タを読み込みます。BIOSがブートセクタとして最初の512バイトのみメモリへ読み
込んでくれましたが、それ以外はすべて読み込みのプログラ厶を書いて読み込ま
なければなりません。

　しかし、その前に「現在フロッピーディスクから読み込み中ですよ」という文
字列をディスプレイに表示しなければなりません。

-----
got_sectors:
    movb    $0x03, %ah   # read cursor pos
    xorb    %bh, %bh
    int     $0x10
    movw    $9, %cx
    movb    $0x07, %bl   # page 0, attribute 7 (normal)
                         # %bh is set above; int10 doesn't
                         # modify it
    movw    $msg1, %bp
    movw    $0x1301, %ax # write string, move cursor
    int     $0x10        # tell the user we're loading..
-----

　コメントからもわかるとおり、最初の3行で現在のカーソル位置を読み込んでい
ます。「Ralf Browns Interrupt List」から検索してみると、
「http://www.delorie.com/djgpp/doc/rbinter/id/93/0.html」となっています。
そのあとは、文字列の書き込みの処理です。ディスプレイに文字列を出力します。
「http://www.delorie.com/djgpp/doc/rbinter/id/15/2.html」を見てください。
「%es:%bp」が文字列があるアドレス、%cxは文字列の長さ、%blはページ、こんな
感じで文字列を表示します。

-----
msg1:   .byte 13, 10
        .ascii "Loading"
-----
        
　ちなみに出力する文字列は「\r\nLoading」で、ソースの最後に定義されていま
す。


■0x09.) セットアップルーチンの読み込み

　ここから実際にフロッピーの情報をメモリへ移動させていくことになります。
まずは、「int $0x13」で%axが0であるBIOS命令は
「http://www.delorie.com/djgpp/doc/rbinter/id/11/6.html」となるので、初期
化処理となります。フロッピーディスクシステムのリセットとか書かれてありま
すが、まぁフロッピーから読む込む処理を行うときは、最初にこれを呼び出すと
覚えておけばよいかと。

-----
# Load the setup-sectors directly after the moved bootblock (at 0x90200).
# We should know the drive geometry to do it, as setup may exceed first
# cylinder (for 9-sector 360K and 720K floppies).

    movw    $0x0001, %ax    # set sread (sector-to-read) to 1 as
    movw    $sread, %si     # the boot sector has already been read
    movw    %ax, (%si)

    xorw    %ax, %ax        # reset FDC
    xorb    %dl, %dl
    int     $0x13
    movw    $0x0200, %bx    # address = 512, in INITSEG
-----

　最初の3行は、sread変数へ1を代入しています。コメントを読むと「ブートブロ
ックの後にセットアップの処理を読み込む」とあります。bootsect.Sの最初に
90000H以降の512バイトへ自分自身（つまりbootsect）をコピーしたので、そのあ
と、つまり90200H以降にセットアップの処理を追加するというわけです。

00000H  07C00H               90000H         90200H           A0000H      100000H
+-------+--------------||----+--------------+----------------+-----------+--------
|       |bootsect(512) ||    |bootsect(512) |setup           |MemoryHole |
+-------+--------------||----+--------------+----------------+-----------+--------

　bootsectの部分はbootsect.Sのコード、そしてsetupの部分はsetup.Sのコード
を意味しています。MemoryHoleはメモリホールと呼ばれるもので、詳しくは検索
してください。主にハードウェアが利用しているメモリ空間で、プログラマは利
用できません。さらにリアルモードでは基本的に100000H以降へのメモリ空間のア
クセスはできません。しかしBIOSを利用するとリアルモードでも100000H以降への
アクセスも可能です。実際あとで圧縮されたカーネルを100000H以降へ転送します
が、それはまたあとでやります。さて、とりあえずはフロッピーにあるsetupを
90200H以降へコピーする処理となります。

-----
sread:    .word 0    # sectors read of current track
head:     .word 0    # current head
track:    .word 0    # current track
-----

　これらの変数は、これから大いに利用されます。trackには現在のトラックが、
sreadには、現在のトラック内でまだメモリへの読み込みが行われていないセクタ
数が入ります。headは0と1しかなく、フロッピーの裏と表を表しています。

-----
next_step:
    movb    setup_sects, %al
    movw    sectors, %cx
    subw    (%si), %cx        # (%si) = sread
    cmpb    %cl, %al
    jbe     no_cyl_crossing
    movw    sectors, %ax
    subw    (%si), %ax        # (%si) = sread
-----

-----
setup_sects:   .byte SETUPSECTS
-----

　setup_sectsはsetupルーチンのサイズが入っています。サイズといっても単位
はbyteではなくセクタです。つまり、512バイト単位で表されています。デフォル
トではSETUPSECTSは4（つまり2048バイト）ですが、この値は、コンパイル時に適
切なsetupルーチンのセクタ数が書き込まれます。setup_sectsは先頭から497バイ
ト目に定義されているので、コンパイル時に先頭から497バイト目にsetup.Sのサ
イズをセクタ単位で書き込むわけです。

　sectorsには、さきほど取得した1トラックあたりのセクタ数が入っています。
「(%si)」はコメントにあるとおりsread変数の値を示します。ちなみにsreadは1
です。少し前にsreadへ代入しましたよね。%cxには1トラックあたりのセクタが入
っているので、ここでは1.44MBのフロッピーディスクを使ったと仮定して
「sectors = 18」としましょう。すると「18 - 1 = 17」よって、%cxには17が入
ります。この%cxは「まだメモリへの読み込みが行われていないセクタ数」を表し
ています。最初の1セクタ（512バイト）はブートセクタとして読み込みが終了し
ていますので、残りは17セクタです。そして%alにはsetup_sects、つまりsetup.S
が利用しているセクタ数（setupルーチンのサイズですね）が入っています。

　さて、ここでのポイントはおそらくcmp命令の部分です。現在のトラックにおけ
る「まだメモリへの読み込みが行われていないセクタ数（%cl）」と「セットアッ
プルーチンのセクタ数（%al）」とを比較しています。ということは、このcmp命
令は「セットアップルーチンがトラックをまたいで書き込まれているかどうか？」
を調べていることになります。トラックをまたいでいなければジャンプし、また
いでいれば、sectorsの値を利用することになりますので、%axにsectorsの値を入
れています。ここで、%axには読み込むべきセクタ数が入っていることを覚えてお
いてください。

-----
no_cyl_crossing:
    call    read_track
    pushw   %ax            # save it
    call    set_next       # set %bx properly; it uses %ax,%cx,%dx
-----

　read_trackを呼び出しています。

-----
read_track:
    pusha
    pusha    
    movw    $0xe2e, %ax    # loading... message 2e = .
    movw    $7, %bx
     int    $0x10
    popa
-----

　pushaとpopaは、すべての凡庸レジスタをスタックに待避、復元する命令です。
まぁpushやpopを何回も書くより楽というだけです。 「int $0x10」は
「http://www.delorie.com/djgpp/doc/rbinter/id/11/1.html」です。コメントに
あるように2eとは'.'のことなので、ディスプレイに'.'と表示させる処理という
わけです。

-----
# Accessing head, track, sread via %si gives shorter code.

    movw    4(%si), %dx    # 4(%si) = track
    movw    (%si), %cx     # (%si)  = sread
    incw    %cx
    movb    %dl, %ch
    movw    2(%si), %dx    # 2(%si) = head
    movb    %dl, %dh
    andw    $0x0100, %dx
    movb    $2, %ah
    pushw   %dx            # save for error dump
    pushw   %cx
    pushw   %bx
    pushw   %ax
    int     $0x13
    jc      bad_rt

    addw    $8, %sp
    popa
    ret
-----

　read_trackは実際にデータをフロッピーディスクからメモリへ読み込む処理を
行います。とりあえずint命令は「http://www.delorie.com/djgpp/doc/rbinter/id/13/6.html」
です。int命令の次のjc命令は、エラー発生時のジャンプであり、int命令の前に
ある4つpush命令はそのための処理です。エラーが発生しなかった場合に（通常は
発生しない）このpushを帳消しにしているのが、スタックポインタである%spに8
加算している部分ですね。

　%cxにはsread（=1）が代入されますが、次に%cxがインクリメントされます。そ
れは、セクタ数は1から始まるからです。つまり1から18までがセクタ数であり、
1番目のセクタにはbootsectルーチンが入っていますので、読み込みは終了してい
ます。つまり2番目のセクタから読み込むわけです。よって%cxに2を設定していま
す。

　%alには読み込むセクタの数、%es:%bxには、読み込んだデータを格納するメモ
リアドレスを渡しています。思いだしてください。ちょっと前に%axには読み込む
べきセクタ数を代入していましたよね。それをそのまま利用します。エラーは発
生した場合はbad_rtへジャンプします。

-----
bad_rt:
    pushw   %ax            # save error code
    call    print_all      # %ah = error, %al = read
    xorb    %ah, %ah
    xorb    %dl, %dl
    int     $0x13
    addw    $10, %sp
    popa
    jmp read_track
-----

　フロッピーディスクからメモリへの読み込みに失敗した場合にここに処理が移
ります。print_allを呼び出していますが、これは、デバッグ関係の処理で、汎用
レジスタのデータをディスプレイに表示する関数です。次はディスクドライブの
初期化処理で「http://www.delorie.com/djgpp/doc/rbinter/id/11/6.html」です。
前回でてきました。そして再びread_trackへ戻ります。

　では、今度は成功したとしてソースを読んで行きましょう。

-----
no_cyl_crossing:
    call    read_track
    pushw   %ax            # save it
    call    set_next       # set %bx properly; it uses %ax,%cx,%dx
    popw    %ax            # restore
    subb    %al, setup_sects    # rest - for next step
    jnz     next_step
-----

　とりあえず、read_trackで%es:%bxにセットアップルーチンが読み込まれたわけ
です。具体的にいうと、0x9020:0x0000へセットアップルーチンが読み込まれたわ
けです。

　そして、次に呼び出されているのはset_next関数です。

-----
set_next:
    movw    %ax, %cx
    addw    (%si), %ax        # (%si) = sread
    cmp     sectors, %ax
    jne     ok3_set
-----

　read_trackはメモリへの読み込みでしたが、set_nextは変数の更新です。いき
なり%axの値を%cxに代入してるけど、%axってなんだっけ？　と思われた方は思い
出してください。read_trackが読み込んだセクタ数です。sectorsは1トラックあ
たりのセクタ数（36 or 18 or 15 or 9）なので、実際に読み込んだセクタ数を比
較しているわけです。cmp命令は、同値であるならばZFフラグを1にし、jne命令は、
ZFフラグが0ならばジャンプします。つまり、同値であるならばジャンプしません。
ということは、「トラックのすべてのセクタをread_trackが読み込んでいたなら
ば、ジャンプしない」ということになります。これは、分かりやすく読むと、つ
まり「まだトラックの中にメモリへ読み込んでいない（未読み込みの）セクタが
存在するならばok3_setへジャンプする」ということです。

-----
    movw    $0x0001, %ax
    xorw    %ax, 2(%si)       # change head
    jne     ok4_set
    incw    4(%si)            # next track
ok4_set:
    xorw    %ax, %ax
-----

　ここで、もしジャンプしなかったら、つまりトラック内のすべてのセクタを読
み終えたならば、headが変更されます。headは0or1しかありません。xor命令はZF
フラグを変更します。xorの結果が0ならばZFフラグが1、xorの結果が0以外ならば
ZFフラグは0となります。jne命令はZFフラグが0ならジャンプしますので、とりあ
えず最初にここのプログラムが実行されたらxor命令によってheadは1になり、よ
ってZFフラグが0となり、ジャンプします。ちなみに2度目に実行されたらxorによ
ってheadが0になるのでZFフラグが1となりジャンプしません。となると、trackが
インクリメントされ、次のトラックへ進みます。これは、headが0ならば表、1な
らば裏と考えれば良いです。1トラック目の表、裏、2トラック目の表、裏、とい
うように読み込まれていくわけです。

-----
ok3_set:
    movw    %ax, (%si)        # set sread
    shlw    $9, %cx
    addw    %cx, %bx
    jnc     set_next_fin
    movw    %es, %ax
    addb    $0x10, %ah
    movw    %ax, %es
    xorw    %bx, %bx
set_next_fin:
    ret
-----

　では、ok3_setへ進みましょう。%axはread_trackが読み終えたセクタ数なので
それをsreadへ代入し、変数を更新します。shlwは左シフト命令、よって%cxを9ビ
ット左へシフトします。9ビットは512バイト、つまり%cxを512倍するということ
であり、%cxには読み終えたセクタ数が入ってるので、読み終えたデータのバイト
単位の数値となります。その読み終えたデータを%bxに加算すれば、次に書き込む
べき場所が算出されます。

　jncはCFフラグが0ならばジャンプします。しかし基本的にCFフラグが1になるこ
とはないので、以下のプログラムが実行されることはありません。なぜ無いのか
というと、CFフラグは、add命令で繰り上がりが起こった場合に1になります。し
かし繰り上がることはありえません。setupルーチンが読み込まれる前の%bxの値
（初期値）は0x0200です。もし繰り上がるならば、setup.Sのサイズは、0xFDFFバ
イトより大きいことになります。十進数に直すと65024バイト、約63.5KBです。
こんなデカイsetup.Sはありません。でもカーネルならばもちろん十分ありえます。
カーネルの読み込みでもread_trackは使われるので、そのための処理だと考えて
ください。あとでカーネルの読み込み処理も読んでいきますので、そのときに思
い出してください。

　jnc命令以下は、ソースを読めばわかりますね。%esに0x0100を加算してオフセ
ットである%bxを0にすることで、次のセグメントへ進めています。

-----
no_cyl_crossing:
    call    read_track
    pushw   %ax            # save it
    call    set_next       # set %bx properly; it uses %ax,%cx,%dx
    popw    %ax            # restore
    subb    %al, setup_sects    # rest - for next step
    jnz     next_step
-----

　つまりread_trackは、指定された分のセクタ数をフロッピーからメモリへ読み
込む処理で、set_nextはその読み込んだデータ量などを変数などに格納（反映）
させる関数ということです。setup_sectsはもちろんsetup.Sのサイズなので、そ
のサイズになるまでnext_stepで処理をループさせることになります。

　さて、ここからちょっとややこしくなってくるので、これまでの流れをまとめ
ておきます。

（１）メモリの07C00Hへフロッピーの最初の512バイトが読み込まれる（bootsect.S）。
（２）コピーされたデータを07C00Hから90000Hへコピーする。
（３）%ds, %ss, %cs などを設定する。
（４）フロッピードライブパラメータの設定を変更する。
（５）フロッピーの1トラックあたりのセクタ数を調べる。
（６）setupルーチンを90200H以降へ読み込む。

　このような感じになっています。ここまではいわば小手調べのようなもので、
ここからが本番です。これから実際にカーネルを読み込む処理を行っていくので
心して読んでみましょう。といってもこれまでの処理を熟知していれば、大した
ことはないのですけどね(^^;。


■0x10.) カーネルの読み込み

　いよいよフロッピーディスクからカーネルを読み込みます。しかしカーネルと
言っても所詮0と1の羅列ですから、setup.Sを読み込むときと、さほど変わりませ
ん。あえて言うなれば、サイズが64KB以上は確実に大きいので、セグメントを変
更しながら読み込むことになるくらいでしょうか。

　基本的にsetupルーチンの読み込み処理を熟知していれば、問題ありません。で
はカーネル読み込みを見ていきましょう。

-----
SYSSEG = DEF_SYSSEG   /* system loaded at 0x10000 (65536) */
-----

-----
    pushw   $SYSSEG
    popw    %es            # %es = SYSSEG
    call    read_it
    call    kill_motor
    call    print_nl
-----

　$SYSSEGの値は、コメントに書かれてあります。「system loaded at 0x10000 (65536)」
とありますので、つまり、0x1000ということですが、これはカーネルが読み込ま
れる場所です。つまりフロッピーディスクから読み込まれたカーネルはメモリ上
の10000H以降にコピーされるということです。そして、%esに0x1000を代入したあ
と、3つの関数が呼ばれてますが、とりあえずread_itは置いておいて、先に
kill_motorとprint_nlをみてみましょう。

-----
kill_motor:
#if 1
    xorw    %ax, %ax        # reset FDC
    xorb    %dl, %dl
    int     $0x13
#else
    movw    $0x3f2, %dx
    xorb    %al, %al
    outb    %al, %dx
#endif
    ret
-----

　kill_motorはソースのいちばん下にあります。要するにフロッピーディスクド
ライブの初期化をしているだけです。
　詳しくは「http://www.delorie.com/djgpp/doc/rbinter/id/11/6.html」を参照
してください。何故、#if-#elseで分けているのかは私も分かりません。

-----
print_nl:
    movw    $0xe0d, %ax      # CR
    int     $0x10
    movb    $0xa, %al        # LF
    int     $0x10
    ret
-----

　print_nlはディスプレイに改行を出力させる処理です。説明の必要はありませ
んね。参照元は「http://www.delorie.com/djgpp/doc/rbinter/id/11/1.html」で
す。

　では、read_itの解読に進みましょう。

-----
read_it:
    movw    %es, %ax         # %es = SYSSEG when called
    testw   $0x0fff, %ax
die:  jne   die              # %es must be at 64kB boundary
    xorw    %bx, %bx         # %bx is starting address within segment
rp_read:
#ifdef __BIG_KERNEL__
                             # look in setup.S for bootsect_kludge
    bootsect_kludge = 0x220  # 0x200 + 0x20 which is the size of the
    lcall   bootsect_kludge  # bootsector + bootsect_kludge offset
#else
    movw    %es, %ax
    subw    $SYSSEG, %ax
    movw    %bx, %cx
    shr     $4, %cx
    add     %cx, %ax         # check offset
#endif
    cmpw    syssize, %ax        # have we loaded everything yet?
    jbe    ok1_read

    ret
-----

　「なんか読みづらいな」と思うのは多分コメントが多いからだと思います。そ
のコメントが以外に良い情報だったりするので、きちんと読んでいきましょう。

　まずはtest命令ですが、これは要するにand命令です。でもオペランドは変化さ
せません。つまりtest命令とはオペランドを変化させないand命令なわけです。簡
単ですね。じゃあ何が変化するのかというと、オペランドの変わりにフラグが変
化します。次の「die: jne die」という行はご覧のとおり無限ループです。jne命
令はZFフラグが0のときにジャンプします。そしてジャンプしたら最後、無限ルー
プの突入です。なのでtest命令は絶対にZFフラグを1にさせるはずです。ちなみに
test命令は、andの結果が0ならZFフラグを1にし、結果が0以外ならZFフラグを0に
します。

　では、考えてみましょう。%esは（つまり%axは）0x1000です。よって、x0fffと
0x1000でand命令を行うと以下のようになります。

-----
0x0fff: 0000 1111 1111 1111
0x1000: 0001 0000 0000 0000
-----

　結果はまぎれもなく0です。見事に0です。よってZFフラグが1になるので、結果
jne命令はジャンプしません。このdieへのジャンプは何のためにあるのか分かり
ませんが、多分デバッグなんかに使うのかと思います。64KBに起因してるのかも。
次に%bxが初期化されてますが、これはあとで、read_trackを呼び出すので、その
ためのコピー先のアドレス（%es:%bx）の%bxを0にするためです（%esはすでに0x1000
です）。ちなみに__BIG_KERNEL__は定義されてます。

　さて、問題の場所に来ました。ある意味、bootsect.Sの中で最もややこしい部
分です。コメントに「look in setup.S for bootsect_kludge」とあります。どう
やら「setup.Sをみろ」と書かれてあります。さらにlcallという不可解な命令が
あります。setup.Sを開いて、bootsect_kludgeを検索してみてください。

-----
bootsect_kludge:
        .word  bootsect_helper, SETUPSEG
-----

　こんなものが見つかります。SETUPSEGは0x9020です（setup.sの最初に定義され
ています）。さらにbootsect_helperというものがあるので、これをまたsetup.s
の中で検索にかけてみます。

-----
bootsect_helper:
    cmpw    $0, %cs:bootsect_es
    jnz     bootsect_second

    movb    $0x20, %cs:type_of_loader
    movw    %es, %ax
    shrw    $4, %ax
    movb    %ah, %cs:bootsect_src_base+2
    movw    %es, %ax
    movw    %ax, %cs:bootsect_es
    subw    $SYSSEG, %ax
    lret                    # nothing else to do for now
-----

　bootsect.Sから呼び出されているsetup.Sに書かれてある関数bootsect_helper
が見つかりました。つまりlcall命令とは、0x90220（0x9000:0x0220）にあるプロ
グラムを呼び出すのではなく、0x90220（0x9000:0x0220）に書かれてあるアドレ
ス（0x9020:bootsect_helper）にあるプログラムを呼び出す命令なのです。「い
やー、ややこしくなってきたなぁー」と思われるかもしれませんが、なんとかつ
いてきてください(^^;。

　整理すると、bootsect.Sで使用する関数が、何故かsetup.Sに書かれてあるとい
うことです。何故bootsect.Sで使用する関数なのにsetup.Sに書いているのでしょ
うか？　ちなみにbootsect_helperは、setup.Sでは一度も呼び出されていません。
まったくのbootsect.S専用の関数なわけです。

　実は、これには深い理由があります。bootsect.sはその名の通りブートセクタ
なわけです。ブートセクタとは、フロッピーの最初の512バイトなわけで、つまり、
bootsect.sのサイズは512バイト以下（正確には510バイト以下）に抑えなければ
なりません。しかし、そんなちいさい領域には、bootsect_helperまでは入らない
のです。いや、推測ですけどこれ多分真実です（笑）。だから仕方なくbootsect_helper
をsetup.Sへ移動させたわけです。Linusさんもいろいろと試行錯誤したわけです。
OS業界もきびしいのです。

　では、bootsect_helperの処理を見ていくことにしましょう。と言っても、一回
目の呼び出しは変数の初期化などを行うだけで大した処理はしません。二度目の
呼び出し以降は、リアルモードでは制御できない1MB以降のメモリ空間へ64KB単位
でカーネルデータを転送する処理を受け持ちます。そして、今までコピーしたデ
ータ量を%axに入れてくれます。ただし、くり返しますが最初の一回目の呼び出し
では初期化しか行いません。

　bootsect_secondは、二度目以降の呼び出し時に処理されます。bootsect_esは0
です。よってcmp命令はイコールとなりZFフラグが1となり、jnzはZFフラグが0の
ときジャンプなので、ジャンプせずに次の処理が実行されます。
「type_of_loader = 0x20」となり、%esは0x1000なので、「%ax = 0x1000」とな
ります。そして%axは右に4シフトで0x0100となり、%ahは0x10なので、
bootsect_src_base+2に0x10が代入されます。再び「%ax = 0x1000」として、
bootsect_esに0x1000を代入します。この処理で必然的に二度目の呼び出しは
bootsect_secondへジャンプすることになります。%axから$SYSSEGを減算すると
「%ax = 0」になり、lret命令で呼び出し元のbootsect.Sのread_itへ返ります。

-----
    cmpw    syssize, %ax        # have we loaded everything yet?
    jbe     ok1_read

    ret
-----

　read_it関数の続きです。syssizeはカーネル（と圧縮されているカーネルを展
開するルーチン）のサイズが入っていますが、ここでは%axは0なので、syssizeの
方が大きいです。jbe命令は、CFもしくはZFフラグが1ならジャンプします。つま
りC言語風に書くと、if(syssize >= %ax){ jmp ok1_read; }となります。つまり、
すべてのカーネルルーチンを1MB以降のメモリ空間へ転送できたら、jbeはジャン
プしないので、そのまま処理が終わるということです。read_itの処理が終われば、
kill_motorでフロッピードライブ停止、print_nlで改行と続いて、最終処理の「ル
ートパーティションのデバイス番号を決定する」に進んで、bootsect.S終了となり
ますが、最初はジャンプするので、次のok1_readと続きます。では、ok1_readへ進
みましょう。

-----
ok1_read:
    movw    sectors, %ax
    subw    (%si), %ax        # (%si) = sread
    movw    %ax, %cx
    shlw    $9, %cx
    addw    %bx, %cx
    jnc     ok2_read

    je    ok2_read

    xorw    %ax, %ax
    subw    %bx, %ax
    shrw    $9, %ax
-----

　最初の2行で、現在のトラックのまだ読み込んでいないセクタ数を%axに入れま
す。sectorsは1トラックあたりのセクタ数で、sreadは読み込み完了したセクタ数
です。よって、%ax（= %cx）には未読み込みセクタ数が入れられます。さらに左
へ9シフト（512倍）して%bxに加算しています。そして、ここで桁溢れが発生する
かどうかを判定します。桁溢れが発生しなければそのままで良いのでok2_readへ
ジャンプし、発生すればちょとした処理を加えてok2_readへ進みます。jnc命令は、
jae命令と同じでCFフラグが0だとジャンプします。je命令は、ZFフラグが1だとジ
ャンプします。

　たとえば、現在のトラックの未読み込みセクタ数が2だったとします。すると
「%cx = 1024（0x0400）」となります。そして%bxが0xFDFFだったならば、あと1
セクタ分しか受けつけないので、add命令で桁溢れします。結果ジャンプしません。
「%ax = 0」として、%axから%bxを減算します。

-----
0x0000 - 0x0001 = 0xFFFF
0x0000 - 0x0002 = 0xFFFE
....
0x0000 - 0xFDFF = 0x0201
（さて、0x0201を二進数で表すと）
0x0201:0000 0010 0000 0001
（さらに右に9シフトすると）
0x0001:0000 0000 0000 0001
-----

　結果「0x0000 - 0xFDFF = 0x0201（= %ax）」となります。0x0201を右へ9シフ
トすると、1となります。答えはでましたね。1セクタ分だけ読み込むということ
です。未読み込みセクタ数は2なのですが、桁溢れが発生したので、読み込める最
大数である1セクタを算出したというわけです。

-----
ok2_read:
    call    read_track
    call    set_next
    jmp     rp_read
-----

　read_trackとset_nextですね。これは、setup.Sルーチンの読み込みと同じ手法
ですので説明ずみですね。そして、rp_readへとジャンプしています。rp_readは
read_it関数の途中で定義されていました。そして二度目のbootsect_kludgeが呼
び出されます。

-----
bootsect_helper:
    cmpw    $0, %cs:bootsect_es
    jnz     bootsect_second

  ...（省略）...

bootsect_second:
    pushw   %cx
    pushw   %si
    pushw   %bx
    testw   %bx, %bx      # 64K full?
    jne     bootsect_ex
-----

　今度はbootsect_secondへジャンプします。push命令が続きますが、これは気に
しないでください。そして、コメントにあるように64KBがフルに溜っていたらジ
ャンプしません。64KB溜った時点でそのデータ1MB以降へ転送します。つまり以下
は転送処理となります。もし64KB溜ってなかったら64KB溜まるまで転送はおあず
けです。

-----
    movw    $0x8000, %cx            # full 64K, INT15 moves words
    pushw   %cs
    popw    %es
    movw    $bootsect_gdt, %si
    movw    $0x8700, %ax
    int     $0x15
    jc      bootsect_panic          # this, if INT15 fails

    movw    %cs:bootsect_es, %es    # we reset %es to always point
    incb    %cs:bootsect_dst_base+2 # to 0x10000
-----

　64KB溜っていたらint15を利用して、1MB以降のメモリ領域へデータを転送しま
す。リアルモードは1MB以上のメモリは扱えないのですが、でも何故か転送できて
ます（笑）。「なんで？」と思ったら、どうやら、BIOSの機能を利用しているよ
うです。「http://www.delorie.com/djgpp/doc/rbinter/id/35/15.html」「プロ
テクトモードじゃなくても、転送できてるやん」という突っこみは置いておいて、
便利なBIOSがあるんだなぁと素直にコンピュータの進化を堪能しましょう(^^;。
転送が成功したら、転送先のアドレスに64KBを加算します。失敗したら、
bootsect_panicへジャンプしてますが、この関数もsetup.Sにあります。関数名か
ら分かる通りエラー処理です。

-----
bootsect_panic:
    pushw   %cs
    popw    %ds
    cld
    leaw    bootsect_panic_mess, %si
    call    prtstr
    
bootsect_panic_loop:
    jmp     bootsect_panic_loop
-----

　適当なデバッグ情報を出力して、無限ループに入っています。まぁエラー処理
は、置いといてbootsect_helperに戻ります。　

-----
bootsect_ex:
    movb    %cs:bootsect_dst_base+2, %ah
    shlb    $4, %ah     # we now have the number of
                        # moved frames in %ax
    xorb    %al, %al
    popw    %bx
    popw    %si
    popw    %cx
    lret
-----

　bootsect_dst_baseはどうやら4バイトなので、前から3バイト目の1バイトが%ah
に入れられます。さらにそれを4ビット左にシフトして%alを0にしています。

　さて、ここまで読んでみて、「なるほどなぁ」と理解できた人はおそらく10年
にひとりの天才か、もしくは16ビットアセンブラプログラミングを熟知された方
のどちらかでしょう。一般的な日本人は、1回読んだだけではまず分かりません。
なのでソースを何回も読んでみたり、実際にプログラムを自分で書いてみたりし
なくてはなりません。でも普通のアプリケーションプログラムじゃないんだから、
自分でプログラムなんて書けないじゃん、と思ってしまいます。が、しかし、世
の中にはエミュレータというものが存在します。フリーではBochsというものがあ
ります。OS開発などをする人は、結構使ってると思いますので、興味があれば検
索してみてください。

　setupルーチンは、read_trackでフロッピーからデータを読み込み、set_next
で変数を更新してメモリへの読み込みを行っていました。同じようにカーネルも
read_trackを使ってフロッピーからデータを読み込み、set_nextを使って変数を
更新するわけですが、カーネルの場合、さらに64KB溜まったら、データを1MB以降
のメモリへ転送する処理が必要になります。それがbootsect_helperというわけで
す。

　つまりカーネル読み込みといっても、やっていることはsetupルーチンとほとん
ど同じということです。一応カーネル読み込みがbootsect.Sの山場というか、メ
イン部分というか、一番分かりにくいところですので、何度が読み直してみてく
ださい。


■0x12.) ルートパーティションのデバイス番号を決定する

　やっと最後の処理へ辿り着きました。ここではルートパーティションのデバイ
ス番号を決定しています。root_devには、ソースの最初に0と定義されてますが、
コメントをみるとビルド時に値を書き込む方法をとってるようです。カーネルが
起動したあとのルートパーティションのデバイス番号を決定するらしいですが、
正直よくわからんです（笑）。あんまり重要じゃない気がするので、適当に「ふ
ーん」という感じで流して良いと思います。

　最後に$SETUPSEG、つまりは、セットアップルーチンである9020H:0000Hへジャ
ンプしてbootsect.Sは終了です。

-----
# Segments are as follows: %cs = %ds = %ss = INITSEG,
#    %es = SYSSEG, %fs = 0, %gs is unused.

    movw    root_dev, %ax
    orw     %ax, %ax
    jne    root_defined

    movw    sectors, %bx
    movw    $0x0208, %ax      # /dev/ps0 - 1.2Mb
    cmpw    $15, %bx
    je      root_defined

    movb    $0x1c, %al        # /dev/PS0 - 1.44Mb
    cmpw    $18, %bx
    je      root_defined

    movb    $0x20, %al        # /dev/fd0H2880 - 2.88Mb
    cmpw    $36, %bx
    je      root_defined

    movb    $0, %al           # /dev/fd0 - autodetect
root_defined:
    movw    %ax, root_dev

# After that (everything loaded), we jump to the setup-routine
# loaded directly after the bootblock:

    ljmp    $SETUPSEG, $0
-----

　コメントをみる限りでは、フロッピーディスクドライブのデバイス番号を設定
しているような気もするんだけど。ブートセクタの部分というより、もっと後の
方で役に立つシステム設定のようにも思えます。

　とまぁ、以上で一応bootsect.Sは終了です。これからの処理は90200H以降に読
み込まれたsetup.Sへと移っていきます。プロテクトモードへの以降や、圧縮され
たカーネルの展開など、まだまだやるべきことはたくさんあります。さらにinit
プロセスが起動するまでには、より長い長い道のりがありますが、bootsect.Sを
解読することによって、その道程の最初の一歩は踏み出せたのではないでしょう
か。道は遠いですが、一歩ずつ進んでいけばいつかは辿り着けるでしょう。そし
てその道を進んでいくこと、それ自体が楽しいはずです。

　よいHacking Lifeを。


■0x13.) さいごに

　さて、いかがだったでしょうか。振り返ってみると、アセンブラが分かってて
も難しい内容だった気がしますが、まぁ一応Linuxのソースコードですので、一筋
縄ではいかないでしょう。私が最初にLinuxのソースを読みたいと思ったのは、確
か中学生くらいのときで、まだC言語も覚えたてで簡単なゲームなどを作ってた頃
でした。当時話題のLinuxというのがオープンソースだと聞いて、ちょっと読んで
みたいと思ったのがきっかけでしたが、まぁC言語をちょっとかじった程度の中学
生じゃLinuxなんて簡単に読めるはずもなく、その時はすぐに諦めてしまいました
が、現在、ようやく読める実力がついてきたんだなぁと自分の成長ぶりに少し関
心しました(^^;。紆余曲折を経て、再びここに戻って来ましたが、「やはりオー
プンソースっていいなぁ」と今更ながら実感しました。さて、最後になりました
が、ここまで付き合って読んでくださった方本当に有り難うございました。いず
れはカーネルハッカーとしてLinuxをイジり倒してください。私自身もこれからの
Linuxの進化を楽しみにしています。

　では、また会う日まで...


■0x14.) 参考文献

・「はじめて読む486」浦地輝尚 著
・「詳解Linuxカーネル」Daniel P Bovet, Marco Cesati 著
・「Linuxのブートプロセスをみる」白崎博生 著



x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第３章: アタッカーのためのサバイバルマニュアル ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　今回も前回に続きPDAの無線LANネタでいこうかと思いましたが、新潟県中越地
震が起こってしまったので、急遽内容を変更することにしました。
　ということで、今回は災害対策の基本的知識を学ぶとってもらうことを目的と
します。タイトルには「アタッカーのため」とついていますが、あくまで興味を
ひくための煽りであって、PCユーザー全般に役に立つと思います。以前、トップ
ページに掲載した「特集：災害に備えよう（2003年5月29日）」の改訂版です。


■0x02.) 心構え

　数日前に、新潟県で大きな地震がありました。
　日本は、環太平洋造山帯に属するので地震が発生しやすい地域ということはご
存知だと思います。
　阪神大震災や今回の地震を教訓として、ちょっと災害に備えておくだけで、今
後災害が再び起こった時、生存する確率が大幅に増えるはずです。また、

　大地震があなたが生きている間、住んでいる地域で今すぐ起きる可能性は低い
かもしれませんが（低いだけで明日起きる可能性もある）、いつかは十中八九起
きるはずです。実際に地震が発生したときに、日頃忘れている自然に対する畏怖
感を感じてからでは遅いのです。

　災害対策の備蓄をするにはコストがかかります。いつ発生するかわからない事
態に備えて、お金と時間を費やすのは無駄と考える人も多いことでしょう。また、
備蓄すべきだと思っても、なかなか行動に移せない人もいることでしょう。
　これは何かに似ていませんか？　感のいい人ならすでに気づいていると思いま
すが、コンピュータセキュリティを似ています。コンピュータセキュリティを高
めるためには、多くの時間とお金がかかります。フリーのセキュリティソフトウ
ェアも充実していますが、それをインストールし、そして設定し、さらに日々チ
ェックしていくのは人材費がかかることは明白です。それを自分ひとりで行って
人件費が浮いたとしても、多大な時間を必要とします。このWizard Bibleの読者
の方は、セキュリティに関して理解がある人が大半だと思いますが、一般的には
あまり多くはありません。会社では、セキュリティに投じる費用などないと断言
する経営者も多かれ少なかれいます。実際に、ネットワーク管理者として活躍し
ている方なら実感していることだと思います。

　セキュリティは、ソフトウェアセキュリティとハードウェアセキュリティに分
類されます。前者のソフトウェアセキュリティとは、ネットワーク越しのアタッ
クを防止することです。そして、後者のハードウェアセキュリティとは、実際に
コンピュータシステムにアタッカーが触れることを防止すること、触れたとして
データを防衛することです。また、災害からコンピュータシステムを守ることも
含まれます。

　最近はファイアウォールやアンチウイルスソフトウェアのようにソフトウェア
セキュリティについては精通しているPCユーザーも多いですが、そのような彼ら
もハードウェアセキュリティをないがしろにしていることがたびたび見られます。
その顕著な例が無線LANセキュリティだと思います。無線LANはソフトウェアセキ
ュリティにも関連しますが、不正なAPを勝手に設置するだけでバックドア化して
しまうことなどがそうです。

　今回は、生き残ることを大前提としての備蓄・装備、そして災害時に重要なデ
ータを守るための知識を紹介します。参考にしていただければ幸いです。


■0x03.) 備蓄・用意すべき装備

　まず、災害発生時、生きるための道具やアイテムを揃えます。
　楽天市場などで防災グッズを売っているショップが幾つかありますので、それ
らを利用すれば、家から出ずに購入できます。また、細かいものは自分で揃えて
いく楽しみ（不謹慎ですみません）があるので、日々地道に日曜道具屋や雑貨屋
を見て周るのもよいでしょう。
　最低限、1人当たり5,000円〜1万円程度の装備が必要だと思います。もちろんお
金をかければよいというものではありませんが、モノはあるに越したことはあり
ません。ただし、リュックに入り、背負って歩くことができる程度にします。

　私が個人的に購入しておくとよいと思われるアイテムを次に示します。

・保存食などの食料
　お湯でなく水でも解凍できるものがよい。

・飲み物
　水などの飲料水。水は必須なので、保管用ポリタンクを購入するのもよい。ま
た、味噌汁やスープの缶の飲み物も市販されています。災害時はそれでなくても
不安でいっぱいなので、味噌汁などを飲んで安心感を求めるのもよいでしょう。
プラスプラセボ効果も緊急時に生きる活力の一要因であるからです。

・災害手帳
　氏名、住所、顔写真、硬貨（災害時、公衆電話は硬貨しか使えない）や緊急時
に役に立つメモが載っているものを用意します。

・粉塵マスク
　300円程度で売っています。災害直後は粉塵が舞い上がりがちで、粉塵マスクが
無いと、移動が困難になり、体力を消耗してしまいます。それを防止します。

・防煙マスク
　火事では煙が一番危険なので、火災現場から避難する時に使います。

・ラジオ
　情報収集に必要です。防災用ラジオだと、懐中電灯とセットになっていて、手
回しで電池いらずのものもあります。最近だと各キャリアに対応した携帯電話充
電機能もあるようです。これは非常に役に立つはずです。

・照明道具
　懐中電灯、ロウソクなど用意しておくことが重要です。

・食事道具
　食料だけあっても食べる道具がないと意味がありません。はし、フォーク、ス
プーン、缶切りなどを用意しておきます。これらセットになったものもあるので
それでもよいと思います。

・救急道具
　ばんそうこう、包帯、薬などを袋にまとめて、リュックに入れておきます。サ
バイバルショップで売っているワンキットを購入するのもよい。ただし、土壇場
で初めて開封していたのでは戸惑う可能性があるので、2セット購入し、1セット
は平常時に開封して中身を確認しておくとよい。また、女性の方は生理用品も用
意しておくとよいだろう。

・防災頭巾あるいはヘルメット
　火が髪に移るのを防いだり、瓦礫やガラスなどが上から降ってくるときに防い
でくれます。


　以上に挙げたもの以外に、あれば理想的なものを次に示します。

・簡易トイレ
　水洗トイレは流れないので、家のトイレは使えなくなると思ってください。そ
こで役に立つのが簡易トイレです。簡易トイレ用ダンボール、専用袋、脱臭剤の
セットで5千円ぐらいで売ってると思います。専用袋は予備として2セットぐらい
買っておくと1週間はトイレで困らないはずです。

・ロープ
　緊急時に意外に役に立ちます。ボーイスカウトで教えられる縄の結び方をあら
かじめ知っておくと有利です。

・受信機や無線機
　消防無線や災害時に出動するヘリなどの無線を傍受して、他の人より有利な立
場で行動できます。さらに無線機を所有していれば、送信することも可能なので、
近隣の無線所有者と連絡を取り合うこともできます。携帯電話では通話が不可能
なので、無線機は災害時はもちろん、人類が滅亡する危機であっても活躍するこ
とは必定です。

・シューズ
　地震でガラスが割れて、その上を歩くことになったり、火災箇所を通ることも
あるので、専用のシューズがあるとよい。

・GPS受信機
　災害時は日常方角に見当つけるために目印にしていた建物が崩壊している可能
性があります。方角に関しては方位磁石を使えば解決します。
　しかし、職場で災害が発生し、自宅に戻りたい時、あなたは徒歩で帰ることが
できるでしょうか？　電車は不通、自動車はもちろん不通です。当てになるのは
自宅の緯度経度しかありません。日頃から災害を想定して徒歩で歩く特訓してお
けばいいわけですが、前述したように建物の崩壊によって道が分からなくなる可
能性もあります。その場合に利用できるのがGPS受信機です。最近の携帯電話には
GPSが内蔵されているものもありますが、あくまで簡易的なものであり、実際にG
PS衛星からの電波を受信して緯度経度を計算しているわけではありません。つま
り、電話が不通になると同時にその携帯電話のGPS機能も使い物にならなくなるわ
けです。

　方位磁石もGPS受信機もないちょっとした裏ワザとしてTVアンテナを利用すると
いうものがあります。建物の上に設置されているTVアンテナは必ず東京タワーの
方角を向いてます。この性質を利用すれば大雑把に方角を把握することができる
かもしれません。


　これらを揃えるのが面倒だ！という方は、リュックとセットになって売ってい
るものも多くあるので、それを購入するとよいでしょう。もちろん、家族4人なら
4人分必要になります。


■0x04.) コンピュータの災害対策

　災害時のコンピュータセキュリティで一番重要となるのはデータの保全です。
マシン自体が破壊されても、それらはまた買えば戻ってきます。しかし、データ
は一旦失われたらもう戻ってきません。といってもPC本体、特にタワー型のデス
クトップPCやモニターが倒れてくると危険ですので、耐震グッズを利用して固定
するのは基本中の基本です。

　自宅が水没してしまう可能性、火事場泥棒に盗まれる可能性があるため、非難
時には重要なデータを持ち歩く方が確実です。ただ、持ち歩くということはリム
ーバルメディアまたはHDDで持ち歩くことになります。つまり、災害リュックの重
量を増やしてしまう結果となります。ということで、次に列挙する点を考慮すべ
きです。

・小型かつ大容量のHDD
　2.5インチHDDが適当。または、小型のノートPCがよいでしょう。

・外付けHDDまたはリムーバブルHDD
　非難時に内蔵HDDを取り出している暇はありません。すぐ非難できるようにUSB
タイプの外付けHDDか、リムーバブルHDDが無難です。リムーバブルHDDの場合、鍵
付きのものが一般的です。いざ鍵を探したりするより、USBケーブルを抜く方が早
いので、USBタイプの外付けHDDが非難時には有利です。ただし、USBタイプの外付
けHDDの場合、ACコンセントも抜かなければ移動できないはずなので、ちょっとそ
れで時間をロスすると思います。
　そして、通常はPCの電源を付けたまま、HDDを抜き差ししてはなりませんが、緊
急時には仕方がないので電源が投入されたままでHDDを抜くしかないでしょう。

・重要なデータなら暗号化機能有りのものを選ぶ
　「Cipher Shield 3.5inch 120GB（64ビット）USB2.0/FW External HDD」は、デ
ータをリアルタイムで暗号化しながら保存できるUSB外付けHDDです。ハードウェ
アキー方式を採用しており、キーを抜いておけば他人はデータにアクセスできな
くなります。アタッカーならば人、特に警察には見られたくない機密情報なども
所有していることでしょう。そんな方でもこれなら簡単に秘密にしてしまうこと
ができます。暗号鍵を抜いてそれを取られない限り中身を覗かれても復元させる
ことができなくさせることができるわけです。
　詳細は次のURLを参照してください。
http://online.plathome.co.jp/detail.html?scd=11701343
http://www.ciphershield.com/


　データを自分で持ち歩くというアプローチの他に、遠隔地のサーバーにデータ
を日頃バックアップしておくというアプローチもあります。データのバックアッ
プのためだけにWeb/FTPサーバーを借りると金銭的に損なので、ストレージサービ
スを提供するサーバーを借りる方がよいと思います。ストレージサービスならば
数GB単位で安価でレンタルできます。もし、Webサーバーで数GB利用するとなると
専用サーバーという選択しかなくなり、ということは毎月数万円かかることにな
ります。ストレージサービスなら1GBであっても月2,000円以内だから、その差は
歴然です。

　ついでに、パスワードのメモ帳など存在するときはそれも忘れずに非難しまし
ょう。


■0x06.) おわりに

　最後になりますが、いくら備蓄・装備を整えても、冷静に行動できなければ何
にもなりません。冷静に行動するためには実際に経験を詰むのが最適ですが、災
害を実体験する機会は少ないはずです。日頃の体力作り、サバイバルの知識・能
力の習得、脳内でのイメージトレーニングなど欠かせません。日頃から特訓して
おきましょう。


x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第４章: オークション詐欺　詐欺師を詐欺した元詐欺師 ---

著者：MaD

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　いよぉ！　いいタイトルでしょ。自分でも意味わからんけど。
　いぷろん氏が佐渡島から上京して、相変わらず会社で泊まり込み（一緒の布団
では寝ていない）、新刊を制作していたときのこと。
　「詐欺師・泥棒　矢崎マサユキ　白鶴まる」として高い評価を誇るMaDさんがオ
ークション詐欺に遇ってしまったのら〜ヽ(;ﾟДﾟ)ﾉ。
　しかも「最新詐欺撃退マニュアル」（http://www.gartheimer.com/betrug.html）
という書籍の編集をしている最中のことだから、マヌケさ二倍ヽ(;´Д`)ノ。
　「嘘つき、低能、キチガイ」と三拍子揃った天然記念物がブチ切れたのだから、
さぁ大変！

　この憎き犯人、当初はネットから親族、ご近所に至るまで実名で晒しまくるつ
もりだったが、年齢も若く、将来を考えた末、より良い詐欺師になってもらいた
いので、ここでは敢えて名前は伏せてあげようかと思う。まぁ、若手育成という
ところ。


■0x02.) オークション詐欺【マヌケな被害者の実例】

　ネットオークションでは、詐欺などのトラブルが付きモノだ。
　数千円の落札ならば大した問題ではないが、これが数万円といった商品の詐欺
となるとダメージはデカイものとなる。それにより、高額商品の落札の際、細心
の注意をはらうことが常識となっている。
　当然「評価欄」を確認することは非常に重要となる。悪い評価の相手との取り
引きを避けて、できるだけ良い評価の相手と取り引きをしたいのは誰でも同じは
ずだ。
　だが「その評価もアテにならない」というのが今回の物語なのである。

　では、経緯の説明から。

●日曜日

まど「今度の水曜日、18インチのパソコンも見れる液晶テレビが届くねん」
いぷ「へぇ、じゃ、グラディウスＶをそれでするのね」
まど「オークションで金曜日に32000円で一発落札した。野球も見れる！」
いぷ「へぇ、安いなぁ。普通は40000円くらいするでしょ？」
まど「自慢だけど、オークションのプロとはそんなもんさ」

●月曜日

まど「……ただいまー。今、銀行で代金を振り込んできたよ」
いぷ「評価は大丈夫なの？　確認した？」
まど「入札のとき見たよ。『悪い』はゼロだった。大丈夫！」
いぷ「……一応、見せて」
まど「うっせージジィだな！　おら、見ろ！　これ！　……れれ？」
いぷ「スゴイことになってる！　土曜日から『非常に悪い』が連発してる！　プ」
まど「グワーン！！　詐欺やんけっ！　騙された〜！　ブッ殺すー！」
いぷ「まだ、振り込んだばかりだから銀行に行けばどうにかなるのでは？」
まど「おし！　いてくる！　……ていうか、さっき『プ』て言うたやろ！」
いぷ「早く行かないと間にあわないですよ！」
まど「うん！」

　　・・・数分後・・・

まど「だめだって、あっちの銀行にいったゼニは、あっちの銀行の話だと……」
いぷ「じゃ、振り落とされたら終わりだ。32000円は痛いですね（微笑）」
まど「ぁぅー！　……ていうか、テメェ、今、微笑んだやろ？」
いぷ「それより、対策を立てないと」
まど「うん！」

　　・・・数分後・・・

●ウエブメールをハック！

　犯人には、これ以上ないくらいの怒りがあり、カミソリで全身の皮膚を0.5ミリ
ずつ削っていって、最後に脳みそをゴマ油で炒めて塩と唐辛子（一味のほう）か
けて食べてしまいたいところだが、取り引きの間、相手は「hotmail」を使ってい
た。
　そうなると、おそらく携帯はプリ携、銀行口座と住所は架空、アクセスはネカ
フェを使っている可能性がある。これは自分がおじいちゃんになったらオークシ
ョン詐欺で人生を建て直そうと計画していたため大方の察しはつく。
　だから、こうしたアイテムを揃えて、かつ、完璧に動いていたら一巻の終わり
となる。まだまだ冷静に振る舞わなければ犯人の特定ができない。
　そこで、厨房たちのいうところの「ハック」を実行するしかない。いよいよ、
これまでひたすら隠してきたネットワークのスキルをフル活用するときがきた。
自慢じゃないが、この道に入って早五年。黙ってはいるが、それなりのことはで
きる。
　まず、着目したのは「hotmailを使っている」という部分だ。メールボックスの
データはネット上に残っているはずだ。「いくつかの情報が手に入るかもしれな
い……」。そう考え、メールボックスを覗くためにパスワードを色々入れてみた。

まど「……ちぇ、どれもあかんやんけ！　まぁ、予想通りだけどな(´ｰ`)y-~~」

　当然、次に、オンラインでブルートフォースをかけるツールを使った。

まど「……ちぇ、使い方分からへんやんけ！」
まど「……ちぇ、しんどいから全部やーめた！(;´ｰ`)y-~~」

　そんなわけで、今回は、そういうチマチマしたテクニカルな方法は自分の哲学
から外れるため、まずは見送ることにした。
　「頭脳戦で勝負」と心に決めた。

●犯人に宛てたメール

まど「……………………。いや、まだ手がある。ワシは元詐欺師やから詐欺師の
心理は分かる。今なら振り込んだばかりや！　すぐにカマシを入れてみる。今日、
これだけ被害者が出ている中で振り込んだという部分が唯一、他の被害者とは違
うファクターなわけや。詐欺だと分かっていてわざと振り込んだという方向で動
いてみる」

　詐欺師からして、常識で考えるとそんな奴がいるわけがない。
　「この詐欺師！　すぐに返せ！」なんて被害者であれば誰でもいうこと。詐欺
をはたらくからには、それくらいの言葉は予測しているのは当然。痛くも痒くも
ないはずだ。だから、その反対の論理で攻めて、犯人の頭を混乱させることを考
えた。
　詐欺師を追い込む「詐欺師バスター」のようなノリでいくことにした。

　色々と考えたが、あまり時間がない。結果として、次のようなメールを送るこ
とにした。

_____________________________________________
かかったな（笑）。
今、君の口座に32000円振り込んできた。君のことを調べとったんや。
君の状況証拠がすべて揃ったんで、さっきゼニをそっちの口座に振り込んだ。

　×××銀行　××支店　普通××××××××
　××××

ただ、振り落とすときはトラップに気を付けてやらなあかんで。
まずはとにかくゼニを下ろせ。最初の指令や。いうまでもないが慎重に動けよ。
蛇足やけど、ネット使って、口座にアクセスだけはするなよ。一番ヤバイから。
ネカフェはもうアカンで。あそこは刑事が張り込んどるから危険や。
ビデオもログも保全されとる。ネカフェは同じとこを二回使ったらあかん。これ
基本や。

詳しくは以下の本を読んどけ。

・コンピュータ悪のマニュアル・ビギナーズ
・ハッカーの教科書
・Windowsのハッキングマニュアル

ぜんぶ、わしがイジった本や。
君の手口もこの本の中にあるはずや。まだまだ勉強や。完璧な犯罪はない。

・非合法ドラッグ教本

んで、これはパクられたらどうするかをワシがレクチャーしとる。
ほな、じっくり観察させてもらうわ。
　
　mad@backsection.net
_____________________________________________

　まぁ、最大限のハッタリですわ（笑）。
　……とか、いいつつ、心中はドヨ〜ンとした感じ。

●事態急変

　しかし、翌日、事態は急変。こんなメールが届いた。

_____________________________________________
********こと××××が出品した商品を落札された皆様に緊急連絡です！
私、********こと××××本人です。
久し振りにオークションを見たら、私の名前が勝手に使われており、品物が多数
出品されていて驚きました。
当方は、先月、車上荒らしに遭い、ファイルに入れていた銀行口座への入金を請
求するものでした。ファイルの中には私の個人情報を記載した書類が入っていま
した（暗証番号やヤフーＩＤ等）私の口座は先月新しく作ったもので残高も無く、
銀行へ停止の願いもしていませんでした、私の落ち度だと考えています。
もし、指定された口座に振込みをされた方、振込みを予定されている方がおられ
ましたら振込みはしないで下さい。明日私は銀行に行って口座の停止をしてきま
す。
後は、警察にも連絡をして対処してまいりますのでしばらくお待ちください。

大阪府××市××　×−××−××　××ハイツ×棟×××号
××　××
０９０−××××−××××　いつでもご連絡ください。
_____________________________________________

まど「ゴルァ！　いぷろん！　起きろ〜！　勝った勝った〜！」
いぷ「……はぁ。なるほど、住所まで書いてあるね。電話するの？」
まど「当たり前やんけ。得意の血圧上がりまくりチンピラ関西弁で（笑）」

　このメールを読む限りでは、このメールを送った人物が「ヤフーＩＤ」「暗証
番号」「銀行口座」などが車上狙いにより盗まれ、第三者により詐欺に使われた
ということを理由にして窮地を切り抜けたいようだ。そんな眠い話しは通させな
い。
　自転車泥棒をして初めて捕まったとき、警官に「自転車は捨ててあったと思い、
それを拾っただけです……」と、誰もが思いつく見え見えの言い訳と同じ。

　そして、このメールはHTML形式となっており、自宅のパソコンからOutlook 
Express6を使用してBCCで一斉送信していることが分かった。さらにヘッダーを見
ると、バイダは顧客情報が漏洩しても被害者に商品券でナシをつけるセキュリテ
ィの高いところを使っているようだ。ここまで見ると、犯罪経験も初心者、パソ
コンも初心者であることが分かる。

　この犯人は、予想外の展開により、口座のお金を触るのが怖くなったわけだ。
　犯罪をおこなっている者は、一般の人が思う以上に神経がピリピリしている。
　予測の範囲内であるなら、それなりの対応はできるが「返せ！」というところ
を「いらない」と言われると不安にならない方がどうかしている。一歩間違える
と、逮捕されるわけだから、それは「トラップがあると思って動く」しか方法が
ない。
　結果論だが、「自分なら、どう考え、どう動くか？」、それを考えてみると自
然な話しだといえる。

　ここまで掴めば、追い詰めたも同然だ。最低限、お金は戻ることが約束された
わけだ。……かなり余裕がでてきた。

●犯人

　まず、本人を確かめるために、電話をかけてみなければならない。
　○○用のプリ携から電話をしてみると、相手が出た。

まど「もしもし、××さんですか？　こちらシロウサギヤマトの宅配便集荷セン
ターですが、荷物が戻ってきているのですが、そちらの住所確認をさせてくださ
い。えっと、大阪府××市××　×−××−××　××ハイツ×棟×××号○○
　××に間違いありませんか？　名字はあるのですが下の名前の部分が読めない
のです」
相手「……××だけど」
まど「わかりました。至急、配達します」

　ここで完璧に相手が掴めた。
　そして、いよいよ、あたっく〜。

相手「もしもし××です」
まど「おい××やな？　例のメールの差出人や。ビビったやろ？」
相手「この度は、私の不注意で申し訳ありま……」
まど「眠い話ええから。……話し進めよや」
相手「ですからメールのとおりで……」
まど「お前、関西やの？　わし、尼や。わしから行こか？　とりあえず、近所に
張り紙や。あとな、住民票も取ったぞ。陸運局はこれからやけどな。」
相手「尼は知っています。ですから！（少しキレ気味）」
まど「なんや？　ヤマ踏んで、ヘタ売って逆ギレかい？　わしもキレよか？（笑）」
相手「いや、私がやったわけではなくて……」
まど「能書きいらん。詐欺なんてもんは騙された方が悪いわけや。どうでもええ
んや。お前、わしの口座わかっとるやろ？　そこにゼニ振り込んどいて。ほんで
許しといたる。君の謝罪の気持ちを先に見せといて。ほな、頼むで！（ガチャン）」

　本当は、もっと色々言いましたが、この顛末は書けません。
　まぁ、詐欺犯を詐欺未遂にしたのですから、それはそれで立派な社会人として
の役割を果たしたかと思います。
　なんだか簡単に事が運んでいるので、脚色された話しのように思えるかもしれ
ないが、これはIPUSIRONさんがずっと経緯を生暖かく見守っていたことを付け加
えておきます。横にいながらなにもしてくれなかったIPUSIRONさんには本当に感
謝の気持ちで一杯です。

　詳しくは下記参照。
　ここの掲示板でアホの被害者がウダウダ騒いで「自分たちで解決できた」と思
い込んでいる様子。
　
　→http://bbs4.cgiboy.com/koreajp88/

　アホがガン首揃えて、手の内を明かしている勘違いとイキり様を見て笑ってく
ださい。自分としては単なる集団心理によるイジメにしか見えませんでした。
　ちなみに「oikomi」というハンドルで書き込みをしている唯一の犯人の味方も
いたようです。この人だけは冷静に物事を見据えていたようです。キャハ！

「ゼニが戻ってよかったな！　烏合の衆！」


■0x03.) おわりに

　……ということで、金床さん。blackhatでは色々とご迷惑をおかけしました。
　今後も、なにかのイベントがあるたびに注意してください！

　ケンジさん、phpありがとう！
　外部リンクで自爆しない部分はエレガント！


【編注】関連URL

・「せくしい〜あかでみあ」
http://ruffnex.oc.to/kenji/bura/upbbs.php

・「ブラウザクラシャ〜保存館」
http://ruffnex.oc.to/ipusiron/cgi/forum/patio.cgi?mode=view&no=216


x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

 --- 第５章：お知らせ ---

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

○Wizard Bible（http://akademeia.info/wizardbible/）では随時、執筆ライタ
ーを募集しています。
　扱う内容のテーマは広義での「under ground」です。例えば、ハッキングから
サリンガスの合成法などと幅広い内容を考えています。また、各種、特殊な職業
や趣味を持った方のレクチャーなども含まれます。
　一回きりでも構いません。また、必ず、毎回連載する義務もありませんのでで
きる範囲で構いません。気軽に声をかけてください。もちろん一回書いたことが
ある人も気軽に声をかけてください（全く気にしていない性格なので）。

○Kenji AikoさんがQ&Aを作ってくれました。初めて参加する人でもわかりやすく
書かれていますので、参考にしてください。

http://akademeia.info/wizardbible/wbQandA.html

○支援者、参加希望者用のスレッドを立てました。

http://ruffnex.oc.to/ipusiron/cgi/forum/patio.cgi?mode=view&no=17



x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

  ---- 第６章：著者プロフィール ---

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

　今回は各著者に使用しているアンチウイルスソフトウェアを紹介してもらいま
した。

■金床
●Job: プログラマー
●Web: http://guardian.jumperz.net/, http://www.jumperz.net/
●Mail: anvil@jumperz.net
●Team（Group): JUMPERZ.NET
●Comment:
　今回初めて執筆させていただきます、金床です。どうぞよろしくお願いします。
最近はHTTPやウェブアプリケーションのセキュリティを中心にゴソゴソしていま
す。
●お気に入りのアンチウイルスソフト：無し
　アンチウイルスソフトウェアは使っていません。ウイルス・ワームが手元に来
る経路として「メール経由」「直接ネットワーク経由」の2つがありますが、前者
は添付ファイル付きメールは全部ゴミ箱行き、後者はファイアウォールで防いで
います。毎日（数えていませんが）100単位でウイルスメールが来るので、アンチ
ウイルスソフトウェアがインストールされていたらメールの受信がきっと大変な
ことになると思います。怪しいファイルをダウンロードしたりはしないので、こ
れで問題なく生活できています。毎年一度くらいミスって感染して、あわててウ
ェブで調べて手動で削除したりしています。

■Kenji Aiko
●Job: Student
●Web: http://ruffnex.oc.to/kenji/
●Mail: kenji@ruffnex.oc.to
●Team（Group): N/A
●Comment:
　今回はLinuxソース解読の話でした。私のモチベーションが続けばsetup.S篇、
startup_32篇と続けていきたいなぁとは思っていますが、予定は未定です(^^;　
それはそうとあと1ヶ月でドラクエ８が発売されるみたいです。やばい...また日
常生活に支障が...ドラクエとFFだけは新作がでるとついプレイしてしまいます。
ところでFF12はいつ発売なんだろう。
●お気に入りのアンチウイルスソフト：Norton AntiVirus
　ノートン先生です。一番信頼できる気がします。でも少し感度が良すぎてすぐ
反応しちゃうのが玉にキズ。
　体験版が「http://www.symantec.com/region/jp/trial/nis.html」から無料で
手に入るらしいですけど、これっておいしいですよね。だって30日限定といって
も何度でも削除してインストールし直せば使えるわけですから。いや体験版は使
ったことないので正確には分からないですけど。ウイルスに感染したときだけDL
して削除してもらうとかできないのかなぁ。

■MaD
●Job:DATA HOUSE
●Web:http://www.data-house.co.jp/
●Mail:mad@data-house.co.jp
●Team（Group）:ruffnex
●Comment:
　元ハカージャパソと危ない28号の百円ライター。趣味は、空き缶拾いと牛乳瓶
のフタ集め。２ちゃんねるでは「矢崎マサユキ」、「白鶴・丸」、「大同曲芸人
」、「泥棒・詐欺師」として通っている。ウソばかりつくので友達はいない。
　現在は会社でヒッキーをしているが、将来はネットカフェの店員なるという目
標に向かってまっしぐら。とぁっ！(`Д´)。
●お気に入りのアンチウイルスソフト：後で更新予定。

■IPUSIRON
●Job:サイト更新
●Web:- Security Akademeia -（http://akademeia.info/）
●Mail:ipusiron@ruffnex.oc.to
●Team（Group）:TeamSA,ruffnex
●Comment:
　最近ネットで面白いこともないことですし、今度ブラクラコンテストを開催し
ようと思っています。運営はMaDさん、アップローダーはWBでもお馴染みのKenji
さんが製作したものです。開催日、決まり、コンテストの審査員、賞品などはま
だ決定していませんが、MaDさんのサーバーにアップローダーが移転次第、進めて
いきたいと思っています。仮設置として、Kenjiさんのディレクトリにアップロー
ダーが用意されているのでチェックしてみるとよいでしょう。コンテストの開催
日時決定次第、セキュリティアカデメイアで宣伝したいと思います。
http://ruffnex.oc.to/kenji/bura/upbbs.php
●お気に入りのアンチウイルスソフト：Norton AntiVirus
　昔からノートン使っています。複数台のPCにインストールすると更新期限切れ
がばられてしまい、ネットで更新しようとパス発行してもそのパスは2週間しか対
応しないので、最近は更新するのも面倒になってきました･･･。フリーのアンチウ
イルスソフトである「AVG 6.0 Free Edition」もあるから、そちらに移行しよう
か思案中。
