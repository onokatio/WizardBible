x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第4章: Rapid Development of Packer Vol.1 ---

著者：suma

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　WindowsのPEフォーマット向けのパッカーの作成について、ソースコードを追い
ながら説明します。言語にはC/C++とインラインアセンブラを組み合わせて使い、
圧縮アルゴリズムにC言語ライブラリのzlibを使用します。また、DLL・VBなどの
パックには対応しません。Windows XP SP2（32ビット版）の環境で動作を確認し
ており、コンパイラにVisual Studio .NET 2003を使用します。


■0x02.) Rapid Development

　「素早いパッカーの開発」について念頭におきます。まず、私が使い慣れてい
るという理由で言語にC/C++を使い、アセンブリ言語の使用を控えました。そして、
ライセンス・C言語で呼び出せることかあら圧縮ライブラリにはzlibを採用しまし
た。


■0x03.) パッカーの流れ

　パッカーという名前を聞くとひとつのプログラムのように思えますが、パッカ
ー本体とローダーのふたつの独立プログラムからできています。おおまかに次の
ような流れです。

●パッカー

1：ターゲットの実行ファイルを開く
2：パックする
3：ローダーを付加する
4：保存する

●パックされた実行ファイルの動作

1：ローダーが実行される
2：ローダーがメモリ上にアンパックする
3：ローダーから元のプログラムへ実行が移る


■0x04.) 何をパックするのか

　実行ファイルに含まれるデータをパックします。今回はコードのみパックしま
す。必要に応じてデータセクション、インポートセクション等をパックしてもか
まいません。以下に主なセクションを紹介します。これらすべてが実行ファイル
に含まれているとは限りません。

・コードセクション：実行されるコード
・データセクション：参照される文字列・初期化された値など
・リソースセクション：アイコン・メニュー・画像・バージョン情報などのリソ
ースデータ
・インポートセクション：インポートするDLL・関数名の情報
・エクスポートセクション：エクスポートする関数の情報


■0x05.) フォーマットとヘッダー

　PEフォーマットとはWindows用の実行ファイルのフォーマットで、Windowsの実
行ファイルのほとんどがこのフォーマットです。ヘッダーはファイル先頭に含ま
れる、そのファイルの情報を示すものです。PEフォーマットに準拠した実行ファ
イルの場合、先頭にDOSヘッダー、次にPEヘッダーという順でヘッダーが格納され
ています。実行ファイルのセクションを参照したり、操作する時にはPEヘッダー
を参照します。ヘッダーをテスト用の自分だけのプログラムとしてなら問題ない
かもしれませんが、オフセットアドレスが読み込んだファイルサイズを超えない
ようチェックしたり、数値のオーバーフロー・アンダーフローに気をつけてくだ
さい。

　PEフォーマットについては以下のサイトを参考にするとよいでしょう。また、
解説を読まずにパッカーのソースコードを直接読んで理解してもよいかもしれま
せん。

・マシン語大研究
http://hp.vector.co.jp/authors/VA015412/

・WinAPI Database for VB Programmer
http://www.winapi-database.com/special/2001_10_11/index.html


■0x06.) パッカーの作成と実装

　パッカー、ローダーは個別のプロジェクトとして作成しました。ふたつが独立
したプログラムであることと、後述するローダー作成のためです。そして、これ
らふたつのプロジェクトをひとつのソリューションでまとめます。また、プロジ
ェクトの中間ファイルの生成ディレクトリはそれぞれ分別し、実行ファイルの生
成ディレクトリは同じものを指定します。これはパッカー・ローダーの動作を確
認する際に役立ちます。

　作成したパッカーは次のファイルにまとめています。

http://beautiful.homelinux.net/~sky-software/wb/rdp/pack_20060430.zip


■0x07.) パッカーの作成

　パッカー本体のプログラムの作成はさほど難しくありません。しかし、実行フ
ァイルのヘッダーを参照して操作するという細かい処理が非常に多くあります。
そこでパッカー本体の処理が膨れ上がらないよう、PEヘッダーを操作する部分は
ライブラリとして作成しました。ライブラリとパッカー本体はpackフォルダ内に
あります。


■0x08.) ローダーの作成

　パッカーとローダーは独立したプログラムです。特にローダーは、パックする
実行ファイルに付け加えるものであるため、単独で実行可能である必要がありま
す。それにもかかわらず、圧縮ライブラリにzlibを使用するため、単独での実行
は困難になります。

　ローダーの単独での実行とは、コードだけで動く必要があるということです。
絶対アドレスを指定するような、グローバル変数は使えず、静的なデータ（文字
列・配列の初期値など）を含んだり、Win32APIの呼び出しも困難になります。こ
れらすべては克服可能ですが、インラインアセンブラを使用する上、制限もあり、
それが労力に見合うかどうかはわかりません。

　まず、グローバル変数の使用、静的なデータの使用ですが、これはコード中に
データを埋め込むことが可能です。

-----
#include <stdio.h>
#define db _asm _emit
void main()
{
	_asm {
		jmp data_end
	data:
		db 'h' db 'o' db 'g' db 'e' db 0
	data_end:
		push offset data
		call [printf]
		add esp, 4
	}
}
-----

　次に、Win32APIの呼び出しも不可能ではありません。これはWizard Bible vol
.17でmuffinさんの記事「ウイルスプログラミングへの招待 〜インポートセクシ
ョンを持たずにAPIを使う方法〜」で解説された原理を使います。

　このようなテクニックを使うと、データを含めることは可能となります。しか
し、zlibの内部では静的なデータを多用しているのでこの方法は使えません。そ
こで、次のZloaderとFirstLoaderという名前のローダーあわせてふたつのローダ
ーを作成するという手段を考えました。

・ZLoader
　コードセクション・データセクションなどをひとつのセクションにまとめ、ベ
ースアドレスを指定して生成。

・FirstLoader
　ZLoaderのベースアドレスと同じアドレスに、VirtualAllocでメモリを確保して
コピーし、実行させる。

　結果的にはうまくいきましたが、メモリを確保するアドレスがいつも有効に使
えるという保証はありません。そこで、アドレスの再配置をすることで克服する
ことができます。


■0x09.) アドレスの再配置

　DLLはいつも同じアドレスにロードされるとは限らないため、そのための再配置
セクションというセクションを持っています。アドレスを再配置によって異なる
アドレスにロードされても、同じコード・データを参照することができる仕組み
です。


■0x0A.) アドレス・データの受け渡し

　パックされたデータは、セクションとして実行ファイルに追加します。ローダ
ー側からはこのデータのアドレスや、アンパック先のアドレスを知る必要があり
ます。これを実現するために、ローダーの変数の初期化領域を上書きします。

　アドレスの受け渡しに使う構造体をLoaderInfo.hで定義しています。ローダー
のコード内ではグローバル変数としてLoaderInfoを使い、初期値を適当な値で初
期化しています。パッカー側から初期化した値を検索することで、どの部分を書
き換えるか見つけることができます。

　または、生成したローダーの実行ファイルからせクションを抽出し、バイナリ
エディタで初期化した値がセクションの先頭部分に存在することを確認してくだ
さい。実装が簡単なため、今回はパッカーで「構造体の値はセクションの先頭に
ある」ということを利用しました。注意しなければならないことは、これはコン
パイラの実装上こうなっただけで、条件によってはこの方法が使えないことも考
えられます。

-----  ZLoader.c
static LoaderInfo LInfo = { 0x44332211, 0x88776655 };
-----

-----  LoaderInfo.h
typedef struct {
	DWORD_PTR DataAddress;
	DWORD     DataLength;
	DWORD_PTR CodeAddress;
	DWORD     CodeLength;
	DWORD_PTR CodeEntryPoint;
} LoaderInfo;
-----


■0x0B.) 簡単なテストと、手間のかかるデバッグ方法

　パッカーが正しく動作するように見えても、それが正しく動いているかは実際
に動かしてみないとわかりません。そこで、すぐに実行を確認できる環境を準備
しておきます。パッカーを作成しながら、Debugディレクトリに適当な実行ファイ
ルをコピーしておき、そのプログラムをパック・実行して正しくパッカーが動作
するか確認します。

　パッカー本体が何もなく動いても、ローダーの方に問題があればパックされた
実行ファイルは正しく動きません。パックされた実行ファイルをデバッガで地道
にトレースし、おかしな動作がないか確認します。


■0x0C.) おわりに

　プログラムを作る前には「素早いパッカーの開発」なんて考えていませんでし
た。私がこのパッカーを作成して気付いたことは、実行ファイルの操作の処理が
複雑で、バグを誘発しすく、デバッグに手間がかかること、パッカー・ローダー
を正しく作ることが難しいことでした。パッカー作成に慣れないことも原因だと
考えられますが、細かい処理が多く積み重なるパッカー作成で、素早くバグを発
見できる体勢を整えていなかったことが問題でした。次回ではこの素早いバグの
発見について考察、実行していきます。

　プログラムの解説は少なく、「パッカー作成のためのチュートリアル」として
は物足りなく感じるかもしれません。ソースコードの量は決して多くないので、
ぜひすべて読んでみてください。また、ソースコードを見ながらパッカー自作に
も挑戦してみてください。


