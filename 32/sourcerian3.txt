x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: バイナリプロテクション3　～解除されにくいアンチデバッギングの実装～ ---

著者：sourcerian

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回ではアンチデバッギングを実装しましたが簡単に解除されてしまうので、
デバッガ部分が動作しないとデバッギ部分が動作しないように改良しましょうと
いう話で終わりました。今回はその改良方法の説明です。

●使用するファイル

・http://wizardbible.org/32/AntiDebugging.v3.zip


■0x02.) PackedFileLoaderとアンチデバッギングを組み合わせる

　第1回のPackedFileLoaderと第2回のアンチデバッギングを組み合わせて、デバ
ッガ部分にローダを担当させることでエントリポイントを修正しただけでは解除
できないようにします。PackedFileLoaderのローダ部分をデバッガ部分に組み込
むので処理の流れは次のようになります。

①自プログラムをデバッギとして起動する。
②ファーストチャンスイベントでエントリポイントにブレイクポイントを設置す
る。
③エントリポイントに設置したブレイクポイントに到達したらデバッギプロセス
にスマートイメージファイルをロードする。
④スマートイメージファイルのロードが完了したらデバッギのスレッドのEIPをオ
リジナルエントリポイントに変更する。

　ここで色々と問題が発生します。
　PackedFileLoaderではインポートアドレステーブルのバインドにLoadLibrary(
)APIとGetProcAddress()APIを使っていました。ところが、今回は別プロセスにD
LLをロードさせるわけですから、LoadLibrary()APIとGetProcAddress()APIは使用
できません。そこで別プロセスにDLLをロードさせるInjectLibrary()関数と、別
プロセスにロードされたDLLのエクスポート関数のアドレスを取得するGetProcAd
dressEx()関数を作ります。
　しかしここで別の問題が発生します。InjectLibrary()関数はCreateRemoteThr
ead()関数にスレッドルーチンとしてLoadLibraryを指定してスレッドをつくり、
DLLのロードが完了するまでWaitForSingleObject()APIで待機します。しかし、デ
バッグイベントの処理中はデバッギの全スレッドが停止されることを思い出して
ください。つまりデバッグイベントの処理中にInjectLibrary()関数を使うことは
できないのです。そこでスマートイメージをロードするのは別スレッドに担当さ
せ、デバッガを担当するスレッドはデバッギのスレッドをSuspendThread()APIで
停止させた後、スレッドの続行・デバッグイベントの待機に入ります。そうする
ことで、CreateRemoteThread()APIで作られたスレッドが動き出してDLLをロード
するのです。そしてスマートイメージファイルのロードが終わった時点でデバッ
ギのスレッドのEIPをオリジナルエントリポイントに変更してResumeThread()API
でスレッドを再開させます。

　以上を反映させるとデバッガ部分の処理の流れは次の通りです。

①自プログラムをデバッギとして起動する。
②ファーストチャンスイベントでエントリポイントにブレイクポイントを設置す
る。
③エントリポイントに設置したブレイクポイントに到達したらSuspendThread()A
PIでデバッギのスレッドを停止、デバッガ側の別スレッドでスマートイメージフ
ァイルをデバッギのプロセスにロードする。
④スマートイメージファイルのロードが完了したらデバッギのスレッドのEIPをオ
リジナルエントリポイントに変更してResumeThread()APIによりデバッギのスレッ
ドを再開させる。

　これまでの内容を実装したAntiDebugging.v2.zipを用意しました。AntiDebugg
ing.v2.zipにはPackedFileLoaderと同じソリューション構成のソースが入ってい
てloader以外は全く同じです。Loaderプロジェクトには以下のソースファイルが
含まれています。

・Except.h/Except.c
　今回からエラー処理の簡略化に構造化例外処理（SEH：Structured Exception 
Handling）を使うことにしました。SEHのラッパの宣言と定義がこの2ファイルに
なります。

・ApiWrapper.h/ApiWrapper.c
　ReadProcessMemory()やWriteProcessMemory()などのAPIのラッパ関数の宣言と
定義です。APIコールに失敗するとSEHの例外を投げるようにしただけの単純なも
のです。

・InjectLibrary.h/InjectLibrary.c
　前述したInjectLibrary()関数とGetProcAddressEx()関数の宣言と定義です。

・LoadSmartImageEx.h/LoadSmartImageEx.c
　スマートイメージファイルのロードを行う関数とそれに付随する関数の宣言と
定義です。第1回のLoadSmartImage()関数のメモリI/OをひたすらReadProcessMem
ory()APIとWriteProcessMemory()API(のラッパ関数)で行うようにし、それらを別
スレッドで実行するようにしたものがLoadSmartImageEx()関数です。

・Loader.c
　WinMain()関数とデバッガ部分です。前回はEntryPoint()関数をエントリポイン
トとしましたが、VisualC++でSEHを使うとCランタイムライブラリを使うことにな
るためWinMain()で定義してあります。

　実際にスマートイメージファイルを実行させてみてOllyDbgなどでデバッギング
できないことを確認してみてください。


■0x03.) ダンプ対策にAPIコールをフックする

　PackedFileLoaderそのものの弱点ですが、スマートイメージファイルがロード
された後にメモリをファイルにダンプしてPEファイルフォーマットの整合性をと
ることで、そのまま実行できてしまいます。それをデバッギングされてしまって
は意味がありません。
　そこで一部のAPIにブレイクポイントを仕掛けて、そのブレイクポイントに到達
した時点で本来とは異なる動作をするように変更します。当然、デバッギ側は変
更された動作でないと正しく動作しないようにします。
　抽象的にいっていてもわかりにくいので具体的な説明をしましょう。今回、私
が目をつけたのはLoadResource()APIです。PackedFileLoaderのローダ部の説明で、
次のように記述しました。

-----
リソースデータのアドレスはRVA(relational virtual address:実アドレスからイ
メージベースを引いた値)で表現されており、実アドレスは「イメージベース（リ
ソース関連のAPIに渡されたHMODULE）＋RVA」となるのでそのままでは正しい実ア
ドレスを取得できません。「ロードされたアドレス＋RVA」となるようにRVAに「
ロードされたアドレス－自分のイメージベース」を足してやります。
-----

　この説明の実アドレスを取得するAPIがLoadResource()APIで、そのほかのLoad
String()APIなどリソースを取得するAPIは全てLoadResource()APIをコールしてい
ます。LoadResource()APIは第二引数のHRSRCからRVAを取り出し、第一引数のモジ
ュールハンドルにそのRVAを足したものを返します。つまり、ロード時にRVAを修
正しなくてもLoadResource()の戻り値に「ロードされたアドレス－自分のイメー
ジベース」を足してやれば良いことになります。戻り値を修正するにはAPIのコー
ル元(戻り先)にブレイクポイントを設置してそのブレイクポイントに到達した際
にEAXレジスタの値を書き換えます。
　したがって、処理の流れは次のようになります。

①LoadResource()APIにブレイクポイントを設置する。
②LoadResource()APIに設置したブレイクポイントに到達したら以下の処理を行う。
②－①スタックから戻り先を調べて戻り先にブレイクポイントを設置する。
②－②LoadResource()関数本来の動作をさせるためにブレイクポイント設置前に
戻し、EIPを一つ前(INT 3実行する前)に戻す。
②－③ブレイクポイント設置前の動作を行わせた後に再度ブレイクポイントを設
置するために、スレッドのシングルステップフラグをオンにする。
③②－③で設定したシングルステップフラグのせいでスレッドは1命令実行毎にシ
ングルステップ例外を発生します。この時LoadResource()APIにブレイクポイント
を再設置してシングルステップフラグを解除します。
④②－①で設置した戻り先のブレイクポイントに到達し、戻り値が自分のリソー
スを指しているようだったら、戻り値（EAXの値）を修正します。

　これでメモリをダンプしてもリソースのRVAが正しくないのでリソースのロード
に失敗して正常に動作してくれません。ただし、逆アセンブルはできますのでシ
リアルナンバーのチェック部分などクリティカルな部分は隠しておきましょう。
　上記を実装したAntiDebugging.v3.zipを用意しました。v2からの修正箇所はス
マートイメージファイルのロード時にリソースのRVAを修正しないのと、デバッガ
部分で上記の流れを追加したものになります。


■0x04.) 最後に

　というわけで、アンチデバッギングの話は終わりです。SoftIceなどのカーネル
デバッガによるデバッギングは防げませんが、OllyDbgなどを防げるだけでも非常
に効果が高いと思います。個人的にはこれにアンチカーネルデバッガが（巧妙に）
ついていたらもう解析する気が起きないです。
　そういえばSoftIceの開発・販売が終了したようですね。64ビットの転換期が近
くクラッカご用達のSoftIceがなくなってしまった解析の世界はどのようになって
いくのでしょうか。



