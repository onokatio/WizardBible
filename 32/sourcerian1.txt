x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: バイナリプロテクション1　〜Packed file loader〜 ---

著者：sourcerian

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　はじめまして、sourcerianと申します。解析から引退して6年の月日がたち、V
BやVB.NETで業務アプリを書くつまらない日々が続いておりましたが、目にとまっ
たWizard Bibleを読んで冷え切っていた魂がふつふつと燃え上がり、自分も何か
書きたいと思った次第です。
　しかし解析から遠ざかったこの身では、解析の説明は荷が重いと感じましたの
で、プロテクションに焦点を置いて説明していきたいと思います。説明で登場す
るコードはすべてC言語で書いてあるため理解しやすいと思います。それでは、ま
ずはpacked file loaderから始めます。

●使用するファイル

・http://wizardbible.org/32/AntiDebugging.v1.zip
・http://wizardbible.org/32/PackedFileLoader.zip


■0x02.) Packed file loader

　Packed file loaderとはパッカの一種です。端的に説明すると、パックされた
実行可能ファイルを読み込んでメモリに展開およびマップし、パックされる前の
動作を行います。アプローチとしてはWizard Bible vol.22の「自前でDLLをプロ
セスへマッピングさせる方法 〜LoadLibrary関数の作成〜」に近いものがありま
す。逆アセンブルを難しくするとともに機能制限版と製品版を分けてロードする
といったことを可能にします。

　ソースファイルはVS.NET 2003用のソリューションで3つのプロジェクトがあり
ます。

・target：テスト用に作成したパック対象。Win32アプリケーションのデフォルト
構成で作られたものです。
・packer：ターゲットとなる実行可能ファイルをパックしてファイルに保存しま
す。
・loader：パックされたファイルをロードして実行します。

　各々を順に追って説明していきます。


■0x03.) target

　Packed file loaderでパックできるファイルは限られていて、ベース再配置情
報が含まれていることが条件になります。ベース再配置情報とは実行可能ファイ
ルが想定していたメモリアドレスとは異なる位置にロードされた時に、コード内
で参照されているアドレスを修正するためのデータです。また、そのアドレスを
修正することをベース再配置といいます。
　一般的なパッカはターゲットがロードされるメモリアドレスを変えずにローダ
ーを埋め込みますが、Packed file loaderではターゲットを異なるアドレスにロ
ードするためにベース再配置情報が必要となるのです。
　ベース再配置情報はDLLには付与されますが、EXEファイルには通常付与されま
せん。一番最初にロードされる実行可能ファイルなのでロードに失敗することが
ないためです。ですからビルドするときはリンカーオプションに/FIXED:NOを追加
してベース再配置情報を付与してやります。


■0x04.) packer

　処理の流れとしては次のようになります。

イメージファイルの読み込み
　↓
不要なヘッダ情報を削除
　↓
圧縮
　↓
ファイルに保存

　EXEファイルをそのままパックしてしまうと、ロードされた後にメモリをダンプ
することで簡単にアンパックすることができてしまいます。それを防ぐために不
要なヘッダ情報は削除してやります。実際にロードするために必要なデータは次
のようになります。

・ヘッダのサイズ
　セクション数によってヘッダサイズが可変になるから必要です。

・セクションの数
　これがわからなければセクションをロードできません。

・エントリポイント
　これがないとロードした後にどこから開始すればよいかわかりません。

・イメージベース（想定していたロードされるアドレス）
　ベース再配置に必要です。

・イメージファイルをロードするために必要なサイズ
　ロードするためのメモリを確保するためです。PEファイルフォーマットではヘ
ッダを含めたサイズですが、ロードした後はヘッダが不要になるので全セクショ
ンをロードするためのサイズとします。

・インポートアドレステーブル（IAT）のデータディレクトリエントリ
　IATをヘッダに含ませてセクションから削除したほうが強固になりますが面倒な
ためセクションにそのまま残してバインドすることにします。

・リソースのデータディレクトリエントリ
　リソース関連のAPIに必要なために必要です。

・ベース再配置情報のデータディレクトリエントリ
　ベース再配置に必要なために必要です。。これもIAT同様ヘッダに含ませてセク
ションから削除した方がより強固になるでしょう。

・セクション
　コードやデータなどのプログラム本体なので当然必要です。

　PEファイルフォーマットと比べると随分すっきりしました。本来ならマルチス
レッド用にTLS初期化情報のデータディレクトリエントリも必要ですが、今回は対
象外としました。
　これを圧縮したファイルを私はスマートイメージ（Smart Image）と名づけ、拡
張子はSEXにしました。今回使用した圧縮はランレングスです。単純なアルゴリズ
ムで圧縮率も良くありませんが、暗号化という点ではそこそこ効果があります。


■0x05.) loader

　処理の流れとしては次のようになります。

ファイルをロード
　↓
ランレングスを展開
　↓
VirtualAlloc()でメモリを確保
　↓
セクションをロード
　↓
インポート関数のバインド
　↓
ベース再配置
　↓
自分自身のリソースディレクトリへのアドレスを変更
　↓
セクションのアクセス保護属性を適用する
　↓
オリジナルエントリポイントにジャンプ

　全体を通してそれほどややこしい点はありませんが「自分自身のリソースディ
レクトリへのアドレスを変更」では注意が必要です。リソース関連のAPIはリソー
スディレクトリへのアドレスがイメージ内にあるかどうかチェックしているため、
自身のPEヘッダのイメージサイズをリソースを含めるように変更してやる必要が
あります。また、リソースデータのアドレスはRVA（Relational Virtual Addres
s：実アドレスからイメージベースを引いた値）で表現されており、実アドレスは
「イメージベース（リソース関連のAPIに渡されたHMODULE）＋RVA」となるのでそ
のままでは正しい実アドレスを取得できません。「ロードされたアドレス＋RVA」
となるようにRVAに「ロードされたアドレス−自分のイメージベース」を足してや
ります。「VirtualAlloc()でメモリを確保」する際にはフラグにMEM_TOP_DOWNを
指定しましょう。MEM_TOP_DOWNを指定するとVirtualAlloc()はできるだけ上位の
アドレスにメモリを確保します。ツールを使ってイメージをダンプするとサイズ
が2Gバイト近いファイルになるので嫌がらせになります（ネタばらしすると簡単
に解除されますが）。


■0x06.) 最後に

　解析を防ぐにはPacked file loaderだけでは不十分です。いくつもの妙技を組
み合わせてより強固なものにしていきましょう。次回はアプリケーションデバッ
ギングを防ぎます。「デバッギングされるのが嫌＝デバッガにアタッチされるの
が嫌」ということですのでアタッチされる前に自分でアタッチしてしまえばよい
のです。



