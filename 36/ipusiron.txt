x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座・第11回 〜原始元判定アルゴリズム〜 ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　今回も前回に引き続き、暗号の実装においてよく使われるアルゴリズムを紹介
する。今回紹介するアルゴリズムは原始元判定アルゴリズムである。素数判定ア
ルゴリズムから比べれば地味だが、暗号の実装においては重要なアルゴリズムである。

　すでに原始元の概念は解説済みだが、復習として定義から入りたいと思う。


■0x02.) 原始元

　法p（素数）の世界で考えたとき、その世界には{0,1,…,p-1}（これをZ_pと表
記する）のp個の数が存在する。このとき、0を除いた{1,…,p-1}（これはちょう
どZ_p^*と一致している）の中で、p-1乗したとき初めて1になるような元のことを
原始元という。

　例えば、p=5とすると、Z_5^*={1,2,3,4}の世界には4つの数がある。それぞれの
数において、何乗したら1に一致するか確かめてみる（1になったらストップさせ
ている）。

・1^1=1
・2^1=2、2^2=4、2^3=8≡3 mod 5、2^4=6≡1 mod 5
・3^1=3、3^2=9≡4 mod 5、3^3=12≡2 mod 5、3^4=6≡1 mod 5
・4^1=4、4^2=16≡1 mod 5

　1は1乗で1に一致してしまうので、原始元ではない。2と3は4乗（=p-1=5-1）で
初めて1になったので、原始元である。4は2乗で1に一致してしまうので、原始元
ではない。よって、Z_5^*の原始元は2と3ということになる。


*原始元と元の位数の関係

　元の位数とはa^x≡1 (mod p)となる最小の正整数xのことであり、aの位数とい
う。これはx=ord_p(a)と表される。

　上記の例の結果をord表記で表すと、次のようになる。

・ord_5(1)=1
・ord_5(2)=4
・ord_5(3)=4
・ord_5(4)=2

　この表記で原始元を定義するとord_p(a)=p-1のときであるから、p=5のときは
ord_5(a)=4を満たすようなaが原始元である。つまり、a=2,3が原始元とわかる。

　a∈{1,2,3,4}のときのord_5(a)の値に注目して欲しい。aが1から4まで変化する
と、ord_5(a)の値は1,4,4,2となる。この4つの値はすべて4（=p-1=5-1）の約数に
なっている。この事実に気付くには数値をもう少し大きくして考えなければなら
ないが、ここでは天下り式に次の数学的事実があることを示す。

[定理]
pは素数とする。
このとき、aの位数d（=ord_p(a)）は、p-1の約数である。
即ち、d|p-1が成り立つ。


■0x03.) 原始元の個数

　pが具体的に決まると集合Z_p^*も具体的に決まってくる。すると、その集合に
含まれている原始元も決まってくる。ここで気になるのが、このpと原始元の個数
には関係があるのではないかということである。実際には関係があるのである。
Z_5^*の例では、元1〜4についていちいち累乗して調べてから、個数を求めていた。
しかし、pの値と原始元の個数に関係があるので、実はそのようなやり方をしなく
ても簡単に求める方法があるのである。ただし、あくまで原始元の個数であって、
どの元が原始元かということについてではないことに注意してもらいたい。
　それではpの値と原始元の個数の関係の定理を次に示す。

[定理]
Z_p^*の原始元の個数はφ(p-1)個である。

　φ( )はオイラー関数である。オイラー関数φ(n)とは、nと互いに素である正の
整数の個数を意味する。

　この結果はものすごい興味深く感じるかもしれない。Z_n^*で考えると興味深さ
が増すと思う。まず、Z_n^*の要素の個数はφ(n)である（定義から明らか）。さ
らに、φ(n)の中で原始元の数はφ(φ(n))個になる。φが2重になっていることに
対してエレガント性を感じてしまう。

　以上のことから、原始元は全体の数から見ても、比較的たくさんあることがわ
かる。例えば、p=7で考えれば、原始元の個数は次のように計算できて2個になる。
つまり、Z_7^*の中に原始元は2個存在することになる。

φ(7-1)=φ(6)=φ(2・3)=φ(2)φ(3)=(2-1)(3-1)=1・2=2

　φ(n)はnによって異なる値になるが、平均すると6n/n^2（≒0.6）という事実が
ある。よって、φ(φ(n))は平均すると約0.36ということになる。つまり、全体の
36%が原始元と考えることができる。


■0x04.) 原始元の累乗で構成される集合

　暗号理論に密接な関係にある、原始元に関する数学的事実がある。それは、原
始元gを選び、それを0乗〜p-2乗して作られた数の集合{g^0=1,g^1 (mod p),g^2 
(mod p),…,g_(p-2) (mod p)}は、Z_p^*={1,2,…,p-1}と一致するということであ
る。

　この事実の恩恵がどう嬉しいのかについては、今後の記事において暗号プロト
コルが登場したときに説明したいと思う。

　ここでは、この数学的事実に慣れてもらうために、先ほどの例と同様にp=5で考
えてみる。p=5のときのZ_5、Z_5^*、Z_5^*の原始元はすでに上記の例で解説済み
である。その結果を次にまとめておく。

・p=5
・Z_5={0,1,2,3,4}
・Z_5^*={1,2,3,4}
・原始元g=2,3（∈Z_5^*）

[1]g=2のとき

・g^0=2^0=1
・g^1=2^1=2
・g^2=2^2=4
・g^3=2^3=8≡3 (mod 5)

　よって、{g^0 mod 5,g^1 mod 5,g^2 mod 5,g^3 mod 5}={1,2,4,3}={1,2,3,4}と
なり、Z_5^*と一致している。

[2]g=3のとき

・g^0=3^0=1
・g^1=3^1=3
・g^2=3^2=9≡4 (mod 5)
・g^3=3^3=12≡2 (mod 5)

　よって、{g^0 mod 5,g^1 mod 5,g^2 mod 5,g^3 mod 5}={1,3,4,2}={1,2,3,4}と
なり、Z_5^*と一致している。

　したがって、いずれにしても、gの値がいずれにしても定理が必ず成立すること
が確かめられた。


■0x05.) 原始元の生成アルゴリズム

　暗号の世界では原始元が活躍する。そのためコンピュータで効率的に原始元を
生成する必要が生じる。例えば、ElGamal暗号などにおいては、大きな素数pに対
して、Z_p^*の原始元gを生成する必要がある。

　原始元を生成する素朴なアプローチは全数探索である。まず、g∈Z_p^*をラン
ダムに選択肢、次にそれが原始元かどうかを判定すればよい。原始元の定義から、
g≠1,g^2≠1,…,g^{p-2}≠1 (mod p)が成り立てば、gは原始元である（∵原始元
の定義より、g^{p-1}が法pの世界で初めて1になるgが、原始元であるから）。し
かし、この方法ではp^κの計算量がかかってしまう（κ：ビット数）。指数時間
の計算量ではチューリングマシンにとって効率的ではない。

　そのため、多項式時間で原始元を判定するような効率のよい方法を考えなけれ
ばならない。判定アルゴリズムが効率的ならば、ランダムに選択するのも効率的
なので、生成という全体で見ても効率的になる（図1参照）。

（図1）http://security2600.sakura.ne.jp/main2/image3/gensi1.jpg


■0x06.) 原始元の判定アルゴリズム

　原始元の判定アルゴリズムに使えそうな次の事実がある。

[補題]
p-1がp-1=(q_0)^(e_0)×(q_1)^(e_1)×…×(q_t)^(e_t)のように素因数分解され
たとする。このとき、次が成り立つ。

「gがmod pの原始元である」⇔「0≦∀i≦t; g^{(p-1)/(q_i)}≠1 (mod p)」　←(*)

　証明は省略して、例で考えておこう。p=11とすると、p-1=10の素因数分解は2^1
×5^1である。

[1]2が原始元かどうかを調べる

・2^{(11-1)/5}=2^2=4≠1 (mod 11)
・2^{(11-1)/2}=10≠1 (mod 11)

　どちらの結果も1に一致しないので、2は原始元である。

[2]3が原始元かどうかを調べる

・3^{(11-1)/5}=3^2=9≠1 (mod 11)
・3^{(11-1)/2}=3^5=9・9・3=81・3=4・3=12≡1 (mod 11)

　1に一致するものがあったので、3は原始元ではない。

　この定理を使うと、(*)をt+1回チェックするだけで、原始元かどうかを判定で
きることになる。

　ところが、この定理は原始元の判定アルゴリズムに利用できそうだが、実際に
は使うことはできない。なぜならば、ElGamal暗号のときはp=1,024ビットなので、
pを素因数分解することは無理である。この定理を使うためには、p-1の素因数分
解を知らなければならないため、直接使うことは不可能である。そこで、実装に
おいては図2のように行う。

（図2）http://security2600.sakura.ne.jp/main2/image3/gensi2.jpg

1：qをランダムに選び、素数判定アルゴリズム（次回のWBで解説する予定）で判
定する。普通にMiller-Rabinアルゴリズムを使えばよい。

2：次にp=2q+1を計算し、このpが素数かどうかを素数判定アルゴリズムで判定す
る。

3：もしp,qどちらも素数ならば、p-1の素因数は2とqとすでに知っているので、上
記の原始元かどうかを判定するアルゴリズムを利用できる。図2の原始元生成アル
ゴリズムはgの選択と原始元判定アルゴリズムの組合わせを意味としている。

　ちなみに、たった2つの素因数なので、g^2≡1 (mod p)とg^q≡1 (mod p)のたっ
た2回のチェックのみで原始元の判定ができる。もし両方の合同式が満たされない
場合は、gはmod pの原始元となるわけである。


■0x07.) 終わりに

　暗号実装する際には、一般にライブラリを利用するはずなので、このようなこ
とを意識しないかもしれない。しかし、暗号理論とその背景となる数学の学習に
はうってつけなので、WBではあえて取り上げた。
　次回は、暗号理論に関するアルゴリズムの中で花形のひとつとも言える素数判
定アルゴリズムについて解説する予定である。



